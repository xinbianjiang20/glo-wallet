{"version":3,"file":"static/chunks/16fa6afc.32c00392e942e391.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@vechain/sdk-core/dist/index.mjs"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/core.ts\nvar core_exports = {};\n__export(core_exports, {\n  ABIContract: () => ABIContract,\n  ABIEvent: () => ABIEvent,\n  ABIFunction: () => ABIFunction,\n  ABIItem: () => ABIItem,\n  Account: () => Account,\n  Address: () => Address,\n  Blake2b256: () => Blake2b256,\n  BloomFilter: () => BloomFilter,\n  BufferKind: () => BufferKind,\n  Certificate: () => Certificate,\n  Clause: () => Clause,\n  Coin: () => Coin,\n  CompactFixedHexBlobKind: () => CompactFixedHexBlobKind,\n  ERC1155_ABI: () => ERC1155_ABI,\n  ERC20_ABI: () => ERC20_ABI,\n  ERC721_ABI: () => ERC721_ABI,\n  FixedHexBlobKind: () => FixedHexBlobKind,\n  FixedPointNumber: () => FixedPointNumber,\n  HDKey: () => HDKey2,\n  Hex: () => Hex,\n  HexBlobKind: () => HexBlobKind,\n  HexInt: () => HexInt,\n  HexUInt: () => HexUInt,\n  Keccak256: () => Keccak256,\n  MAINNET_NETWORK: () => MAINNET_NETWORK,\n  Mnemonic: () => Mnemonic,\n  NUMERIC_REGEX: () => NUMERIC_REGEX,\n  NumericKind: () => NumericKind,\n  OptionalFixedHexBlobKind: () => OptionalFixedHexBlobKind,\n  Quantity: () => Quantity,\n  RLP: () => RLP,\n  RLPProfiler: () => RLPProfiler,\n  Revision: () => Revision,\n  SOLO_NETWORK: () => SOLO_NETWORK,\n  ScalarKind: () => ScalarKind,\n  Secp256k1: () => Secp256k1,\n  Sha256: () => Sha256,\n  TESTNET_NETWORK: () => TESTNET_NETWORK,\n  ThorId: () => ThorId,\n  Transaction: () => Transaction,\n  Txt: () => Txt,\n  Units: () => Units,\n  VET: () => VET,\n  VIP180_ABI: () => VIP180_ABI,\n  VIP181_ABI: () => VIP181_ABI,\n  VIP210_ABI: () => VIP210_ABI,\n  VTHO: () => VTHO,\n  VTHO_ADDRESS: () => VTHO_ADDRESS,\n  ZERO_ADDRESS: () => ZERO_ADDRESS,\n  ZERO_BYTES: () => ZERO_BYTES,\n  abi: () => ethersAbi,\n  addressUtils: () => addressUtils,\n  assertCompactFixedHexBlobBuffer: () => assertCompactFixedHexBlobBuffer,\n  assertFixedHexBlobKindBuffer: () => assertFixedHexBlobKindBuffer,\n  assertFixedHexBlobKindData: () => assertFixedHexBlobKindData,\n  assertValidHexBlobKindData: () => assertValidHexBlobKindData,\n  assertValidNumericKindBuffer: () => assertValidNumericKindBuffer,\n  blake2b256: () => blake2b256,\n  dataUtils: () => dataUtils,\n  decodeBufferToHexWithLeadingZeros: () => decodeBufferToHexWithLeadingZeros,\n  decodeBufferToNumberOrHex: () => decodeBufferToNumberOrHex,\n  encodeBigIntToBuffer: () => encodeBigIntToBuffer,\n  encodeCompactFixedHexBlob: () => encodeCompactFixedHexBlob,\n  keccak256: () => keccak256,\n  keystore: () => keystore3,\n  mnemonic: () => mnemonic,\n  networkInfo: () => networkInfo,\n  revisionUtils: () => revisionUtils,\n  sha256: () => sha2562,\n  validateNumericKindData: () => validateNumericKindData,\n  vechain_sdk_core_ethers: () => ethers2\n});\nimport { ethers as ethers2 } from \"ethers\";\n\n// src/certificate/Certificate.ts\nimport fastJsonStableStringify from \"fast-json-stable-stringify\";\n\n// src/vcdm/abi/ABI.ts\nimport {\n  InvalidAbiDataToEncodeOrDecode,\n  InvalidOperation as InvalidOperation2\n} from \"@vechain/sdk-errors\";\nimport { ParamType } from \"ethers\";\nimport {\n  decodeAbiParameters,\n  encodeAbiParameters,\n  parseAbiParameters\n} from \"viem\";\n\n// src/vcdm/Hex.ts\nimport * as nc_utils from \"@noble/curves/abstract/utils\";\nimport * as nh_utils from \"@noble/hashes/utils\";\nimport { InvalidDataType, InvalidOperation } from \"@vechain/sdk-errors\";\nvar Hex = class _Hex {\n  /**\n   * Negative multiplier of the {@link digits} absolute value.\n   *\n   * @type {number}\n   */\n  static NEGATIVE = -1;\n  /**\n   * Positive multiplier of the {@link digits} absolute value.\n   *\n   * @type {number}\n   */\n  static POSITIVE = 1;\n  /**\n   * A constant string prefix used in hexadecimal notation.\n   */\n  static PREFIX = \"0x\";\n  /**\n   * The radix used for representing numbers base 16 in a positional numeral notation system.\n   *\n   * @typedef {number} RADIX\n   */\n  static RADIX = 16;\n  /**\n   * Regular expression for matching hexadecimal strings.\n   * An empty input is represented as a empty digits.\n   *\n   * @type {RegExp}\n   */\n  static REGEX_HEX = /^-?(0x)?[0-9a-f]*$/i;\n  /**\n   * Regular expression pattern to match a prefix indicating hexadecimal number.\n   *\n   * @type {RegExp}\n   */\n  static REGEX_HEX_PREFIX = /^-?0x/i;\n  /**\n       * Returns the hexadecimal digits expressing this absolute value, sign and `0x` prefix omitted.\n  \n       * @remarks An empty content results in an empty string returned.\n       */\n  digits;\n  /**\n   * Represents the sign multiplier of a given number:\n   * * {@link NEGATIVE} `-1` if negative,\n   * * {@link POSITIVE} `1` if positive.\n   */\n  sign;\n  /**\n   * Creates a new instance of this class to represent the value\n   * built multiplying `sign` for the absolute value expressed by the hexadecimal `digits`.\n   *\n   * @param {number} sign - The sign of the value.\n   * @param {string} digits - The digits of the absolute value in hexadecimal base.\n   * @param {function} [normalize] - The function used to normalize the digits. Defaults to converting digits to lowercase.\n   */\n  constructor(sign, digits, normalize = (digits2) => digits2.toLowerCase()) {\n    this.digits = normalize(digits);\n    this.sign = sign;\n  }\n  /**\n   * Returns the absolute value of this Hex object.\n   *\n   * @return {Hex} A new Hex object representing the absolute value of this Hex.\n   */\n  get abs() {\n    return new _Hex(_Hex.POSITIVE, this.digits);\n  }\n  /**\n   * Returns the value of `bi` as a `BigInt` type.\n   *\n   * @returns {bigint} The value of `bi` as a `BigInt`.\n   */\n  get bi() {\n    return BigInt(this.sign) * nc_utils.hexToNumber(this.digits);\n  }\n  /**\n   * Returns the Uint8Array representation of the aligned bytes.\n   *\n   * @return {Uint8Array} The Uint8Array representation of the aligned bytes.\n   */\n  get bytes() {\n    return nc_utils.hexToBytes(this.alignToBytes().digits);\n  }\n  /**\n   * Returns the value of n.\n   *\n   * @return {number} The value of n.\n   *\n   * @throws {InvalidOperation<Hex>} Throws an error if this instance doesn't represent\n   * an [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).\n   */\n  get n() {\n    if (this.isNumber()) {\n      return new DataView(this.bytes.buffer).getFloat64(0);\n    }\n    throw new InvalidOperation(\"Hex.n\", \"not an IEEE 754 float 64 number\", {\n      hex: this.toString()\n    });\n  }\n  /**\n   * Aligns the hexadecimal string to bytes by adding a leading '0' if the string length is odd.\n   *\n   * @returns {Hex} - The aligned hexadecimal string.\n   */\n  alignToBytes() {\n    return this.digits.length % 2 === 0 ? this : new _Hex(this.sign, \"0\" + this.digits);\n  }\n  /**\n   * Compares the current Hex object with another Hex object.\n   *\n   * @param {Hex} that - The Hex object to compare with.\n   *\n   * @return {number} - Returns a negative number if the current Hex object is less than the given Hex object,\n   *                    zero if they are equal, or a positive number if the current Hex object is greater than the given Hex object.\n   */\n  compareTo(that) {\n    if (this.sign === that.sign) {\n      const digits = Math.max(this.digits.length, that.digits.length);\n      const thisBytes = this.fit(digits).bytes;\n      const thatBytes = that.fit(digits).bytes;\n      let i = 0;\n      let compareByte = 0;\n      while (compareByte === 0 && i < thisBytes.length) {\n        compareByte = thisBytes[i] - thatBytes[i];\n        i++;\n      }\n      return compareByte;\n    }\n    return this.sign - that.sign;\n  }\n  /**\n   * Returns a new instance of the Hex class, its value fits to the specified number of digits.\n   *\n   * @param {number} digits - The number of digits to fit the Hex value into.\n   *\n   * @returns {Hex} - A new Hex instance that represents the fitted Hex value.\n   *\n   * @throws {InvalidDataType} - If the Hex value cannot be fit into the specified number of digits.\n   */\n  fit(digits) {\n    if (digits < this.digits.length) {\n      let cue = 0;\n      while (this.digits.length - cue > digits && this.digits.at(cue) === \"0\") {\n        cue++;\n      }\n      if (this.digits.length - cue === digits) {\n        return new _Hex(this.sign, this.digits.slice(cue));\n      }\n      throw new InvalidDataType(\n        \"Hex.fit\",\n        `can't fit in ${digits} digits`,\n        { digits, hex: this }\n      );\n    }\n    if (digits > this.digits.length) {\n      return new _Hex(\n        this.sign,\n        \"0\".repeat(digits - this.digits.length) + this.digits\n      );\n    }\n    return this;\n  }\n  /**\n   * Determines whether this Hex instance is equal to the given Hex instance.\n   *\n   * @param {Hex} that - The Hex instance to compare with.\n   * @return {boolean} - True if the Hex instances are equal, otherwise false.\n   */\n  isEqual(that) {\n    return this.compareTo(that) === 0;\n  }\n  /**\n   * Checks if this instance expresses a valid {@link Number} value\n   * according the\n   * [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).\n   *\n   * @returns {boolean} Returns true if this instance expresses 32 hex digits (16 bytes, 128 bits) needed to represent\n   * a {@link Number} value, else it returns false.\n   */\n  isNumber() {\n    return this.digits.length === 32;\n  }\n  /**\n   * Checks if the given string expression is a valid hexadecimal value.\n   *\n   * @param {string} exp - The string representation of a hexadecimal value.\n   *\n   * @return {boolean} - True if the expression is a valid hexadecimal value, case-insensitive,\n   * optionally prefixed with `0x`; false otherwise.\n   */\n  static isValid(exp) {\n    return _Hex.REGEX_HEX.test(exp);\n  }\n  /**\n   * Determines whether the given string is a valid hexadecimal number prefixed with '0x'.\n   *\n   * @param {string} exp - The string to be evaluated.\n   * @return {boolean} - True if the string is a valid hexadecimal number prefixed with '0x', otherwise false.\n   */\n  static isValid0x(exp) {\n    return _Hex.REGEX_HEX_PREFIX.test(exp) && _Hex.isValid(exp);\n  }\n  /**\n   * Create a Hex instance from a bigint, number, string, or Uint8Array.\n   *\n   * @param {bigint | number | string | Uint8Array} exp - The value to represent in a Hex instance:\n   * * bigint is always representable in hexadecimal base notation;\n   * * number, encoded as [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format);\n   * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;\n   * * Uint8Array is interpreted as the sequence of bytes.\n   *\n   * @returns {Hex} - A Hex instance representing the input value.\n   *\n   * @throws {InvalidDataType} if the given `exp` can't be represented as a hexadecimal expression.\n   */\n  static of(exp) {\n    try {\n      if (exp instanceof Uint8Array) {\n        return new _Hex(this.POSITIVE, nc_utils.bytesToHex(exp));\n      } else if (typeof exp === \"bigint\") {\n        if (exp < 0n) {\n          return new _Hex(\n            this.NEGATIVE,\n            nc_utils.numberToHexUnpadded(-1n * exp)\n          );\n        }\n        return new _Hex(\n          this.POSITIVE,\n          nc_utils.numberToHexUnpadded(exp)\n        );\n      } else if (typeof exp === \"number\") {\n        const dataView = new DataView(new ArrayBuffer(16));\n        dataView.setFloat64(0, exp);\n        return new _Hex(\n          exp < 0 ? this.NEGATIVE : this.POSITIVE,\n          nc_utils.bytesToHex(new Uint8Array(dataView.buffer))\n        );\n      }\n      if (this.isValid(exp)) {\n        if (exp.startsWith(\"-\")) {\n          return new _Hex(\n            this.NEGATIVE,\n            this.REGEX_HEX_PREFIX.test(exp) ? exp.slice(3) : exp.slice(1)\n          );\n        }\n        return new _Hex(\n          this.POSITIVE,\n          this.REGEX_HEX_PREFIX.test(exp) ? exp.slice(2) : exp\n        );\n      }\n      throw new InvalidDataType(\"Hex.of\", \"not an hexadecimal string\", {\n        exp\n      });\n    } catch (e) {\n      throw new InvalidDataType(\n        \"Hex.of\",\n        \"not an hexadecimal expression\",\n        { exp: `${exp}` },\n        // Needed to serialize bigint values.\n        e\n      );\n    }\n  }\n  /**\n   * Generates a random Hex value of the given number of bytes length.\n   *\n   * @param {number} bytes - The number of bytes to generate.\n   * @throws {InvalidDataType} - If the bytes argument is not greater than 0.\n   * @returns {Hex} - A randomly generated Hex value.\n   *\n   * @remarks Security auditable method, depends on\n   * * [`nh_utils.randomBytes`](https://github.com/paulmillr/noble-hashes?tab=readme-ov-file#utils).\n   */\n  static random(bytes) {\n    if (bytes > 0) {\n      return _Hex.of(nh_utils.randomBytes(bytes));\n    }\n    throw new InvalidDataType(\"Hex.random\", \"bytes argument not > 0\", {\n      bytes\n    });\n  }\n  /**\n   * Returns a string representation of the object.\n   *\n   * @return {string} The string representation of the object.\n   */\n  toString() {\n    return (this.sign < 0 ? \"-0x\" : \"0x\") + this.digits;\n  }\n};\n\n// src/vcdm/abi/ABI.ts\nvar ABI = class _ABI {\n  types;\n  values;\n  /**\n   * ABI constructor from types and values.\n   *\n   * @param {string | AbiParameter[]} types - A list of ABI types representing the types of the values.\n   * @param {unknown[]} values - An array of values according to the specified ABI types.\n   **/\n  constructor(types = [], values = []) {\n    this.types = typeof types === \"string\" ? parseAbiParameters(types) : types;\n    this.values = values;\n  }\n  /**\n   * Compares the current ABI instance with another ABI instance.\n   * @param that The ABI to compare with.\n   * @returns {number} A non-zero number if the current ABI is different to the other ABI or zero if they are equal.\n   * @override {@link VeChainDataModel#compareTo}\n   * @remark The comparison is done by comparing the types and values of the ABI instances.\n   **/\n  compareTo(that) {\n    this.types.forEach((type, index) => {\n      if (type !== that.types[index]) {\n        return -1;\n      }\n    });\n    this.values.forEach((value, index) => {\n      if (value !== that.values[index]) {\n        return 1;\n      }\n    });\n    return 0;\n  }\n  /**\n   * Checks if the current ABI object is equal to the given ABI object.\n   * @param that The ABI object to compare with.\n   * @returns {boolean} True if the objects are equal, false otherwise.\n   * @override {@link VeChainDataModel#isEqual}\n   * @remark The comparison is done by comparing the types and values of the ABI instances.\n   **/\n  isEqual(that) {\n    return this.compareTo(that) === 0;\n  }\n  /**\n   * Throws an exception because the ABI cannot be represented as a big integer.\n   * @returns {bigint} The BigInt representation of the ABI.\n   * @throws {InvalidOperation} The ABI cannot be represented as a bigint.\n   * @override {@link VeChainDataModel#bi}\n   * @remark The conversion to BigInt is not supported for an ABI.\n   */\n  get bi() {\n    throw new InvalidOperation2(\n      \"ABI.bi\",\n      \"There is no big integer representation for an ABI.\",\n      { data: \"\" }\n    );\n  }\n  /**\n   * Encodes the values according to the specified ABI types when creating the ABI instance.\n   *\n   * @returns The ABI-encoded bytes representing the given values.\n   * @throws {InvalidAbiDataToEncodeOrDecode, InvalidDataType}\n   */\n  get bytes() {\n    return this.toHex().bytes;\n  }\n  /**\n   * Throws an exception because the ABI cannot be represented as a number.\n   * @returns {bigint} The number representation of the ABI.\n   * @throws {InvalidOperation} The mnemonic cannot be represented as a number.\n   * @override {@link VeChainDataModel#n}\n   * @remark The conversion to number is not supported for an ABI.\n   */\n  get n() {\n    throw new InvalidOperation2(\n      \"ABI.n\",\n      \"There is no number representation for an ABI.\",\n      { data: \"\" }\n    );\n  }\n  /**\n   * Instantiates an ABI object from the given types and values.\n   * @param {string | AbiParameter[]} types ABI parameters representing the types of the values.\n   * @param {unknown[]} values ABI values.\n   * @returns {ABI} The ABI object with the given types and values.\n   */\n  static of(types, values) {\n    try {\n      return new _ABI(types, values);\n    } catch (error) {\n      throw new InvalidAbiDataToEncodeOrDecode(\n        \"ABI.of\",\n        \"Types and values must be valid ABI parameters.\",\n        {\n          types,\n          values\n        },\n        error\n      );\n    }\n  }\n  /**\n   * Decodes the ABI values from the given ABI types and encoded data.\n   * @param {string| AbiParameter[]} types The list of ABI types representing the types of the values to decode.\n   * @param {Hex} dataEncoded The encoded data to decode.\n   * @returns An ABI instance with the decoded values.\n   */\n  static ofEncoded(types, dataEncoded) {\n    try {\n      const hexDataEncoded = Hex.of(dataEncoded);\n      let values;\n      if (typeof types === \"string\") {\n        const parsedAbiParams = parseAbiParameters(types);\n        values = decodeAbiParameters(\n          parsedAbiParams,\n          hexDataEncoded.bytes\n        );\n      } else {\n        values = decodeAbiParameters([...types], hexDataEncoded.bytes);\n      }\n      return new _ABI(types, [...values]);\n    } catch (error) {\n      throw new InvalidAbiDataToEncodeOrDecode(\n        \"ABI.of\",\n        \"Decoding failed: Data must be a valid ABI type with corresponding valid data.\",\n        {\n          types,\n          data: dataEncoded\n        },\n        error\n      );\n    }\n  }\n  /**\n   * Recursively parses an object and collects the values of each attribute into an array,\n   * with nested arrays for nested objects.\n   * @param {object} obj - The object to parse.\n   * @returns {unknown[]} An array of values from the object, with nested arrays for nested objects.\n   */\n  parseObjectValues(obj) {\n    const values = [];\n    const recursiveParse = (currentObj) => {\n      const currentValues = [];\n      for (const key in currentObj) {\n        if (Object.prototype.hasOwnProperty.call(currentObj, key)) {\n          const value = currentObj[key];\n          if (typeof value === \"object\" && value !== null) {\n            currentValues.push(recursiveParse(value));\n          } else {\n            currentValues.push(value);\n          }\n        }\n      }\n      return currentValues;\n    };\n    values.push(...recursiveParse(obj));\n    return values;\n  }\n  /**\n   * It gets the first decoded value from the ABI.\n   * @returns {ReturnType} The first decoded value from the ABI.\n   */\n  getFirstDecodedValue() {\n    if (this.values[0] instanceof Object) {\n      return this.parseObjectValues(\n        this.values[0]\n      );\n    }\n    return this.values[0];\n  }\n  /**\n   * Parses an ABI to its Hex representation.\n   * @returns {Hex} The Hex representation of the ABI.\n   */\n  toHex() {\n    try {\n      const abiParametersEncoded = encodeAbiParameters(\n        this.types,\n        this.values\n      );\n      return Hex.of(abiParametersEncoded);\n    } catch (error) {\n      throw new InvalidAbiDataToEncodeOrDecode(\n        \"ABI.toHex\",\n        \"Encoding failed: Data must be a valid ABI type with corresponding valid data.\",\n        {\n          types: this.types,\n          values: this.values\n        },\n        error\n      );\n    }\n  }\n};\nvar ethersAbi = {\n  encode: (type, value) => ABI.of(\n    type instanceof ParamType ? (\n      // This condition is here to enable compatibility with ethers regarding tuple[] types.\n      type.format(\"full\").replace(\" list\", \"\")\n    ) : type,\n    [value]\n  ).toHex().toString(),\n  encodeParams: (types, values) => {\n    const stringTypes = types instanceof ParamType ? types.map(\n      (type) => type.format(\"full\").replace(\" list\", \"\")\n    ) : types;\n    const typesParam = parseAbiParameters(stringTypes.join(\", \"));\n    return ABI.of([...typesParam], values).toHex().toString();\n  },\n  decode: (types, data) => ABI.ofEncoded(\n    types instanceof ParamType ? (\n      // This condition is here to enable compatibility with ethers regarding tuple[] types.\n      types.format(\"full\").replace(\" list\", \"\")\n    ) : types,\n    data\n  ).getFirstDecodedValue()\n};\n\n// src/vcdm/abi/ABIContract.ts\nimport {\n  InvalidAbiDataToEncodeOrDecode as InvalidAbiDataToEncodeOrDecode4,\n  InvalidAbiItem as InvalidAbiItem3\n} from \"@vechain/sdk-errors\";\nimport {\n  getAbiItem,\n  parseAbi\n} from \"viem\";\n\n// src/vcdm/abi/ABIEvent.ts\nimport {\n  InvalidAbiDataToEncodeOrDecode as InvalidAbiDataToEncodeOrDecode2,\n  InvalidAbiItem\n} from \"@vechain/sdk-errors\";\nimport {\n  encodeEventTopics,\n  decodeEventLog as viemDecodeEventLog\n} from \"viem\";\n\n// src/vcdm/abi/ABIItem.ts\nimport {\n  parseAbiItem,\n  toFunctionHash,\n  toFunctionSignature\n} from \"viem\";\nvar ABIItem = class extends ABI {\n  signature;\n  stringSignature;\n  /**\n   * ABIItem constructor from item (Event, Function...) signature.\n   *\n   * @param {string | ViemABI} signature - The signature of the ABI item (Function, Event...).\n   **/\n  constructor(signature) {\n    super();\n    switch (typeof signature) {\n      case \"string\":\n        this.stringSignature = signature;\n        break;\n      case \"object\":\n        this.stringSignature = toFunctionSignature(signature);\n        break;\n      default:\n        this.stringSignature = \"\";\n    }\n    this.signature = typeof signature === \"string\" ? parseAbiItem([signature]) : signature;\n  }\n  /**\n   * Returns and instance of an ABIItem from a signature.\n   * @param ABIItemConstructor ABIItem constructor.\n   * @param {string | ABIItemType} signature Signature of the ABIIItem.\n   * @returns {T} An instance of the ABIItem.\n   */\n  static ofSignature(ABIItemConstructor, signature) {\n    return new ABIItemConstructor(signature);\n  }\n  /**\n   * Returns a string representation of a JSON object or a string.\n   * @param {'json' | 'string'} formatType Either JSON or String\n   * @returns The string representation of the ABI item.\n   */\n  format(formatType = \"string\") {\n    return formatType === \"json\" ? JSON.stringify(this.signature) : this.stringSignature;\n  }\n  /**\n   * The signature hash of the ABIItem.\n   * @returns {string} The signature hash of the ABIItem.\n   * @remarks Wrapper for {@link toFunctionHash}.\n   **/\n  get signatureHash() {\n    return toFunctionHash(this.stringSignature);\n  }\n  /**\n   * Compares the current ABIItem instance with another ABIItem instance.\n   * @param {ABIItem} that The item to compare with.\n   * @returns {number} A non-zero number if the current ABIItem is different to the other ABI or zero if they are equal.\n   * @override {@link VeChainDataModel#compareTo}\n   **/\n  compareTo(that) {\n    if (super.compareTo(that) !== 0) {\n      return -1;\n    }\n    return this.stringSignature.localeCompare(that.stringSignature);\n  }\n};\n\n// src/vcdm/abi/ABIEvent.ts\nvar ABIEvent = class _ABIEvent extends ABIItem {\n  abiEvent;\n  constructor(signature) {\n    try {\n      super(signature);\n      this.abiEvent = this.signature;\n    } catch (error) {\n      throw new InvalidAbiItem(\n        \"ABIEvent constructor\",\n        \"Initialization failed: Cannot create Event ABI. Event format is invalid.\",\n        {\n          type: \"event\",\n          value: signature\n        },\n        error\n      );\n    }\n  }\n  /**\n   * Decode event log data using the event's ABI.\n   *\n   * @param abi - Event to decode.\n   * @returns Decoding results.\n   * @throws {InvalidAbiDataToEncodeOrDecode}\n   */\n  static parseLog(abi, eventData) {\n    try {\n      return viemDecodeEventLog({\n        abi,\n        data: eventData.data.toString(),\n        topics: eventData.topics.map((topic) => {\n          if (topic === null) {\n            return topic;\n          } else if (Array.isArray(topic)) {\n            return topic.map((t) => t.toString());\n          }\n          return topic.toString();\n        })\n      });\n    } catch (error) {\n      throw new InvalidAbiDataToEncodeOrDecode2(\n        \"ABIEvent.parseLog\",\n        \"Decoding failed: Data must be a valid hex string encoding a compliant ABI type.\",\n        {\n          data: {\n            abi,\n            data: eventData.data,\n            topics: eventData.topics\n          }\n        },\n        error\n      );\n    }\n  }\n  /**\n   * Decode event log data using the event's ABI.\n   *\n   * @param event - Event to decode.\n   * @returns Decoding results.\n   * @throws {InvalidAbiDataToEncodeOrDecode}\n   */\n  decodeEventLog(event) {\n    try {\n      return _ABIEvent.parseLog([this.abiEvent], event);\n    } catch (error) {\n      throw new InvalidAbiDataToEncodeOrDecode2(\n        \"ABIEvent.decodeEventLog\",\n        \"Decoding failed: Data must be a valid hex string encoding a compliant ABI type.\",\n        { data: event },\n        error\n      );\n    }\n  }\n  /**\n   * Decode event log data as an array of values\n   * @param {ABIEvent} event The data to decode.\n   * @returns {unknown[]} The decoded data as array of values.\n   */\n  decodeEventLogAsArray(event) {\n    try {\n      const rawDecodedData = this.decodeEventLog(event);\n      if (rawDecodedData.args === void 0) {\n        return [];\n      } else if (rawDecodedData.args instanceof Object) {\n        return Object.values(rawDecodedData.args);\n      }\n      return rawDecodedData.args;\n    } catch (error) {\n      throw new InvalidAbiDataToEncodeOrDecode2(\n        \"ABIEvent.decodeEventLogAsArray\",\n        \"Decoding failed: Data must be a valid hex string encoding a compliant ABI type.\",\n        { data: event },\n        error\n      );\n    }\n  }\n  /**\n   * Encode event log data returning the encoded data and topics.\n   * @param dataToEncode - Data to encode.\n   * @returns {ABIEventData} Encoded data along with topics.\n   * @remarks There is no equivalent to encodeEventLog in viem {@link https://viem.sh/docs/ethers-migration}. Discussion started here {@link https://github.com/wevm/viem/discussions/2676}.\n   */\n  encodeEventLog(dataToEncode) {\n    try {\n      const topics = this.encodeFilterTopics(dataToEncode);\n      const dataTypes = [];\n      const dataValues = [];\n      this.abiEvent.inputs.forEach((param, index) => {\n        if (param.indexed ?? false) {\n          return;\n        }\n        const value = dataToEncode[index];\n        dataTypes.push(param);\n        dataValues.push(value);\n      });\n      return {\n        data: ABI.of(dataTypes, dataValues).toHex(),\n        topics: topics.map((topic) => {\n          if (topic === null) {\n            return topic;\n          } else if (Array.isArray(topic)) {\n            return topic.map((t) => Hex.of(t));\n          }\n          return Hex.of(topic);\n        })\n      };\n    } catch (error) {\n      throw new InvalidAbiDataToEncodeOrDecode2(\n        \"ABIEvent.encodeEventLog\",\n        \"Encoding failed: Data format is invalid. Event data must be correctly formatted for ABI-compliant encoding.\",\n        { dataToEncode },\n        error\n      );\n    }\n  }\n  /**\n   * Encode event log topics using the event's ABI.\n   *\n   * @param valuesToEncode - values to encode as topics. Non-indexed values are ignored.\n   *                         Only the values of the indexed parameters are needed.\n   * @returns Encoded topics array.\n   * @throws {InvalidAbiDataToEncodeOrDecode}\n   */\n  encodeFilterTopics(valuesToEncode) {\n    if (this.abiEvent.inputs.length < valuesToEncode.length) {\n      throw new InvalidAbiDataToEncodeOrDecode2(\n        \"ABIEvent.encodeEventLog\",\n        \"Encoding failed: Data format is invalid. Number of values to encode is greater than the inputs.\",\n        { valuesToEncode }\n      );\n    }\n    try {\n      return encodeEventTopics({\n        abi: [this.abiEvent],\n        args: valuesToEncode\n      });\n    } catch (error) {\n      throw new InvalidAbiDataToEncodeOrDecode2(\n        \"ABIEvent.encodeEventLog\",\n        \"Encoding failed: Data format is invalid. Event topics values must be correctly formatted for ABI-compliant encoding.\",\n        { valuesToEncode },\n        error\n      );\n    }\n  }\n  /**\n   * Encode event log topics using the event's ABI, replacing null values with undefined.\n   * @param valuesToEncode - values to encode as topics. Non-indexed values are ignored.\n   *                         Only the values of the indexed parameters are needed.\n   * @returns Encoded topics array.\n   * @throws {InvalidAbiDataToEncodeOrDecode}\n   */\n  encodeFilterTopicsNoNull(valuesToEncode) {\n    const encodedTopics = this.encodeFilterTopics(\n      valuesToEncode\n    );\n    return encodedTopics.map(\n      (topic) => topic === null ? void 0 : topic\n    );\n  }\n};\n\n// src/vcdm/abi/ABIFunction.ts\nimport {\n  InvalidAbiDataToEncodeOrDecode as InvalidAbiDataToEncodeOrDecode3,\n  InvalidAbiItem as InvalidAbiItem2\n} from \"@vechain/sdk-errors\";\nimport {\n  decodeFunctionData,\n  decodeFunctionResult,\n  encodeFunctionData\n} from \"viem\";\nvar ABIFunction = class extends ABIItem {\n  abiFunction;\n  constructor(signature) {\n    try {\n      super(signature);\n      this.abiFunction = this.signature;\n    } catch (error) {\n      throw new InvalidAbiItem2(\n        \"ABIFunction constructor\",\n        \"Initialization failed: Cannot create Function ABI. Function format is invalid.\",\n        {\n          type: \"function\",\n          value: signature\n        },\n        error\n      );\n    }\n  }\n  /**\n   * Get the function selector.\n   * @returns {string} The function selector.\n   * @override {@link ABIItem#signatureHash}\n   */\n  get signatureHash() {\n    return super.signatureHash.substring(0, 10);\n  }\n  /**\n   * Decode data using the function's ABI.\n   *\n   * @param {Hex} data - Data to decode.\n   * @returns Decoding results.\n   * @throws {InvalidAbiDataToEncodeOrDecode}\n   */\n  decodeData(data) {\n    try {\n      return decodeFunctionData({\n        abi: [this.abiFunction],\n        data: data.toString()\n      });\n    } catch (error) {\n      throw new InvalidAbiDataToEncodeOrDecode3(\n        \"ABIFunction.decodeData\",\n        \"Decoding failed: Data must be a valid hex string encoding a compliant ABI type.\",\n        { data },\n        error\n      );\n    }\n  }\n  /**\n   * Encode data using the function's ABI.\n   *\n   * @param dataToEncode - Data to encode.\n   * @returns {Hex} Encoded data.\n   * @throws {InvalidAbiDataToEncodeOrDecode}\n   */\n  encodeData(dataToEncode) {\n    try {\n      return Hex.of(\n        encodeFunctionData({\n          abi: [this.abiFunction],\n          args: dataToEncode\n        })\n      );\n    } catch (e) {\n      throw new InvalidAbiDataToEncodeOrDecode3(\n        \"ABIFunction.encodeData\",\n        \"Encoding failed: Data format is invalid. Function data does not match the expected format for ABI type encoding.\",\n        { dataToEncode },\n        e\n      );\n    }\n  }\n  /**\n   * Decodes the output data from a transaction based on ABI (Application Binary Interface) specifications.\n   * This method attempts to decode the given hex-like data into a readable format using the contract's interface.\n   *\n   * @param {Hex} data - The data to be decoded, typically representing the output of a contract function call.\n   * @returns {DecodeFunctionResultReturnType} An object containing the decoded data.\n   * @throws {InvalidAbiDataToEncodeOrDecode}\n   *\n   * @example\n   * ```typescript\n   *   const decoded = abiFunctionInstance.decodeResult(rawTransactionOutput);\n   *   console.log('Decoded Output:', decoded);\n   * ```\n   */\n  decodeResult(data) {\n    try {\n      return decodeFunctionResult({\n        abi: [this.abiFunction],\n        data: data.toString()\n      });\n    } catch (error) {\n      throw new InvalidAbiDataToEncodeOrDecode3(\n        \"ABIFunction.decodeResult\",\n        \"Decoding failed: Data must be a valid hex string encoding a compliant ABI type.\",\n        { data },\n        error\n      );\n    }\n  }\n  /**\n   * Decodes a function output returning an array of values.\n   * @param {Hex} data The data to be decoded\n   * @returns {unknown[]} The decoded data as array of values\n   */\n  decodeOutputAsArray(data) {\n    const resultDecoded = this.decodeResult(data);\n    if (this.abiFunction.outputs.length > 1) {\n      return this.parseObjectValues(resultDecoded);\n    } else if (this.abiFunction.outputs.length === 1 && this.abiFunction.outputs[0].type === \"tuple\") {\n      return [this.parseObjectValues(resultDecoded)];\n    }\n    return [resultDecoded];\n  }\n};\n\n// src/vcdm/abi/ABIContract.ts\nvar ABIContract = class _ABIContract extends ABI {\n  abi;\n  constructor(abi) {\n    super();\n    this.abi = abi;\n  }\n  /**\n   * Creates an ABIContract instance from a viem ABI.\n   * @param {ViemABI} abi representation of the contract.\n   * @returns New instance of ABIContract.\n   */\n  static ofAbi(abi) {\n    return new _ABIContract(abi);\n  }\n  /**\n   * Creates an ABIContract instance from an ABI string.\n   * @param {string} abi representation of the contract.\n   * @returns New instance of ABIContract.\n   */\n  static ofStringAbi(abi) {\n    return new _ABIContract(parseAbi([abi]));\n  }\n  /**\n   * Returns the function with the given name.\n   * @param {string} name The function's name.\n   * @returns {ABIFunction} The function with the given name.\n   * @throws {InvalidAbiItem}\n   */\n  getFunction(name) {\n    const functionAbiItem = getAbiItem({\n      abi: this.abi,\n      name\n    });\n    if (functionAbiItem === null || functionAbiItem === void 0) {\n      throw new InvalidAbiItem3(\n        \"ABIContract.getFunction()\",\n        `Function '${name}' not found in contract ABI.`,\n        {\n          type: \"function\",\n          value: name\n        }\n      );\n    }\n    return new ABIFunction(functionAbiItem);\n  }\n  /**\n   * Returns the event with the given name.\n   * @param {string} name The event's name.\n   * @returns {ABIEvent} The event with the given name.\n   * @throws {InvalidAbiItem}\n   */\n  getEvent(name) {\n    const eventAbiItem = getAbiItem({\n      abi: this.abi,\n      name\n    });\n    if (eventAbiItem === null || eventAbiItem === void 0) {\n      throw new InvalidAbiItem3(\n        \"ABIContract.getEvent()\",\n        `Function '${name}' not found in contract ABI.`,\n        {\n          type: \"event\",\n          value: name\n        }\n      );\n    }\n    return new ABIEvent(eventAbiItem);\n  }\n  /**\n   * Encode function data that can be used to send a transaction.\n   * @param {string} functionName The name of the function defined in the ABI.\n   * @param {unknown[]} functionData The data to pass to the function.\n   * @returns {Hex} The encoded data in hexadecimal that can be used to send a transaction.\n   * @throws {InvalidAbiDataToEncodeOrDecode}\n   */\n  encodeFunctionInput(functionName, functionData) {\n    try {\n      const functionAbiItem = getAbiItem({\n        abi: this.abi,\n        name: functionName\n      });\n      const functionAbi = new ABIFunction(functionAbiItem);\n      return functionAbi.encodeData(functionData);\n    } catch (error) {\n      throw new InvalidAbiDataToEncodeOrDecode4(\n        \"ABIContract.encodeFunctionInput()\",\n        `Encoding failed: Data format is invalid. Function data does not match the expected format for ABI type encoding.`,\n        { functionName, functionData },\n        error\n      );\n    }\n  }\n  /**\n   * Decode the function data of an encoded function\n   * @param {string} functionName The name of the function defined in the ABI.\n   * @param {Hex} encodedFunctionInput The encoded function data.\n   * @returns {DecodeFunctionDataReturnType} an array of the decoded function data\n   * @throws {InvalidAbiDataToEncodeOrDecode}\n   */\n  decodeFunctionInput(functionName, encodedFunctionInput) {\n    try {\n      const functionAbiItem = getAbiItem({\n        abi: this.abi,\n        name: functionName\n      });\n      const functionAbi = new ABIFunction(functionAbiItem);\n      return functionAbi.decodeData(encodedFunctionInput);\n    } catch (error) {\n      throw new InvalidAbiDataToEncodeOrDecode4(\n        \"ABIContract.decodeFunctionInput()\",\n        \"Decoding failed: Data must be a valid hex string encoding a compliant ABI type.\",\n        { functionName, encodedFunctionInput },\n        error\n      );\n    }\n  }\n  /**\n   * Decodes the output from a contract function using the specified ABI and function name.\n   * It takes the encoded function output and attempts to decode it according to the ABI definition.\n   *\n   * @param {string} functionName - The name of the function in the contract to decode the output for.\n   * @param {Hex} encodedFunctionOutput - The encoded output data from the contract function.\n   * @returns {DecodeFunctionResultReturnType} - The decoded output, which provides a user-friendly way\n   * to interact with the decoded data.\n   * @throws {InvalidAbiDataToEncodeOrDecode}\n   *\n   * @example\n   * // Example of decoding output for a function called \"getValue\":\n   * const decodedOutput = decodeFunctionOutput('getValue', encodedValue);\n   *\n   */\n  decodeFunctionOutput(functionName, encodedFunctionOutput) {\n    try {\n      const functionAbiItem = getAbiItem({\n        abi: this.abi,\n        name: functionName\n      });\n      const functionAbi = new ABIFunction(functionAbiItem);\n      return functionAbi.decodeResult(encodedFunctionOutput);\n    } catch (error) {\n      throw new InvalidAbiDataToEncodeOrDecode4(\n        \"ABIContract.decodeFunctionOutput()\",\n        \"Decoding failed: Data must be a valid hex string encoding a compliant ABI type.\",\n        { functionName, encodedFunctionOutput },\n        error\n      );\n    }\n  }\n  /**\n   * Encodes event log data based on the provided event name, and data to encode.\n   * @param {string} eventName - The name of the event to be encoded.\n   * @param {unknown[]} eventArgs - An array of data to be encoded in the event log.\n   * @returns {ABIEventData} An object containing the encoded data and topics.\n   * @throws {InvalidAbiDataToEncodeOrDecode}\n   */\n  encodeEventLog(eventName, eventArgs) {\n    try {\n      const eventAbiItem = getAbiItem({\n        abi: this.abi,\n        name: eventName\n      });\n      const eventAbi = new ABIEvent(eventAbiItem);\n      return eventAbi.encodeEventLog(eventArgs);\n    } catch (error) {\n      throw new InvalidAbiDataToEncodeOrDecode4(\n        \"ABIContract.encodeEventLog()\",\n        `Encoding failed: Data format is invalid. Event data does not match the expected format for ABI type encoding.`,\n        { eventName, dataToEncode: eventArgs },\n        error\n      );\n    }\n  }\n  /**\n   * Decodes event log data based on the provided event name, and data/topics to decode.\n   * @param {string} eventName - The name of the event to be decoded.\n   * @param {ABIEventData} eventToDecode - An object containing the data and topics to be decoded.\n   * @returns {DecodeEventLogReturnType} The decoded data of the event log.\n   * @throws {InvalidAbiDataToEncodeOrDecode}\n   */\n  decodeEventLog(eventName, eventToDecode) {\n    try {\n      const eventAbiItem = getAbiItem({\n        abi: this.abi,\n        name: eventName\n      });\n      const eventAbi = new ABIEvent(eventAbiItem);\n      return eventAbi.decodeEventLog(eventToDecode);\n    } catch (error) {\n      throw new InvalidAbiDataToEncodeOrDecode4(\n        \"ABIContract.encodeEventLog()\",\n        `Encoding failed: Data format is invalid. Event data does not match the expected format for ABI type encoding.`,\n        { eventName, dataToDecode: eventToDecode },\n        error\n      );\n    }\n  }\n  /**\n   * Decodes a VeChain log based on the ABI definition.\n   *\n   * This method takes raw `data` and `topics` from a VeChain log and attempts\n   * to decode them using the contract's ABI definition. If the decoding is successful,\n   * it returns a log object representing the decoded information. If the decoding fails,\n   * it throws a custom error with detailed information.\n   *\n   * @param {Hex} data - The hexadecimal string of the data field in the log.\n   * @param {Hex[]} topics - An array of hexadecimal strings representing the topics of the log.\n   * @returns {DecodeEventLogReturnType} - A log object representing the decoded log or null if decoding fails.\n   * @throws {InvalidAbiDataToEncodeOrDecode}\n   */\n  parseLog(data, topics) {\n    try {\n      return ABIEvent.parseLog(this.abi, { data, topics });\n    } catch (e) {\n      throw new InvalidAbiDataToEncodeOrDecode4(\n        \"ABIContract.parseLog()\",\n        `Decoding failed: Data must be a valid hex string encoding a compliant ABI type.`,\n        { data, topics },\n        e\n      );\n    }\n  }\n  /**\n   *\n   * Parses the log data and topics into an array of values.\n   *\n   * @param {Hex} data - The hexadecimal string of the data field in the log.\n   * @param {Hex[]} topics - An array of hexadecimal strings representing the topics of the log.\n   * @returns {unknown[]} - An array of values of the decoded log data.\n   */\n  parseLogAsArray(data, topics) {\n    const eventLogDecoded = this.parseLog(data, topics);\n    if (eventLogDecoded.args === void 0) {\n      return [];\n    } else if (eventLogDecoded.args instanceof Object) {\n      return Object.values(eventLogDecoded.args);\n    }\n    return eventLogDecoded.args;\n  }\n};\n\n// src/vcdm/account/Account.ts\nimport { InvalidOperation as InvalidOperation3 } from \"@vechain/sdk-errors\";\nvar Account = class {\n  address;\n  balance;\n  // Replace the string array with a Transaction class #1162\n  transactions;\n  type;\n  constructor(address, balance, type = \"EOA\", transactions) {\n    this.address = address;\n    this.balance = balance;\n    this.type = type;\n    this.transactions = transactions ?? [];\n  }\n  /**\n   * Throws an exception because the account cannot be represented as a big integer.\n   * @returns {bigint} The BigInt representation of the account.\n   * @throws {InvalidOperation} The account cannot be represented as a bigint.\n   * @override {@link VeChainDataModel#bi}\n   * @remarks The conversion to BigInt is not supported for an account.\n   */\n  get bi() {\n    throw new InvalidOperation3(\n      \"Account.bi\",\n      \"There is no big integer representation for an account.\",\n      { data: \"\" }\n    );\n  }\n  /**\n   * Throws an exception because the account cannot be represented as a byte array.\n   * @returns {Uint8Array} The byte array representation of the account.\n   * @throws {InvalidOperation} The account cannot be represented as a byte array.\n   * @override {@link VeChainDataModel#bytes}\n   * @remarks The conversion to byte array is not supported for an account.\n   */\n  get bytes() {\n    throw new InvalidOperation3(\n      \"Account.bytes\",\n      \"There is no bytes representation for an account.\",\n      { data: \"\" }\n    );\n  }\n  /**\n   * Throws an exception because the account cannot be represented as a number.\n   * @returns {bigint} The number representation of the account.\n   * @throws {InvalidOperation} The account cannot be represented as a number.\n   * @override {@link VeChainDataModel#n}\n   * @remarks The conversion to number is not supported for an account.\n   */\n  get n() {\n    throw new InvalidOperation3(\n      \"Account.n\",\n      \"There is no number representation for an account.\",\n      { data: \"\" }\n    );\n  }\n  /**\n   * Adds a transaction to the account.\n   * @param {string} transaction The transaction to add.\n   */\n  addTransaction(transaction) {\n    this.transactions.push(transaction);\n  }\n  /**\n   * Compare this instance with `that` in a meaningful way.\n   *\n   * @param {Account} that object to compare.\n   * @return a negative number if `this` < `that`, zero if `this` = `that`, a positive number if `this` > that`.\n   * @override {@link VeChainDataModel#compareTo}\n   */\n  compareTo(that) {\n    const typeDiff = this.type.localeCompare(that.type);\n    if (typeDiff === 0) {\n      const addressDiff = this.address.compareTo(that.address);\n      if (addressDiff === 0) {\n        const codeDiff = this.balance.code.compareTo(that.balance.code);\n        if (codeDiff === 0) {\n          return this.balance.value.compareTo(that.balance.value);\n        }\n        return codeDiff;\n      }\n      return addressDiff;\n    }\n    return typeDiff;\n  }\n  /**\n   * Checks if the given value is equal to the current instance.\n   *\n   * @param {Account} that - The value to compare.\n   * @returns {boolean} - True if the values are equal, false otherwise.\n   * @override {@link VeChainDataModel#isEqual}\n   */\n  isEqual(that) {\n    return this.compareTo(that) === 0;\n  }\n  /**\n   * Returns a string representation of the account.\n   *\n   * @returns {string} A string representation of the account.\n   */\n  toString() {\n    return `${this.type} Address: ${this.address.toString()} Balance: ${this.balance.value} ${this.balance.code}`;\n  }\n};\n\n// src/vcdm/hash/Keccak256.ts\nimport { keccak_256 as nh_keccak_256 } from \"@noble/hashes/sha3\";\nimport { InvalidOperation as InvalidOperation5 } from \"@vechain/sdk-errors\";\n\n// src/vcdm/HexInt.ts\nimport { InvalidDataType as InvalidDataType2 } from \"@vechain/sdk-errors\";\nvar HexInt = class _HexInt extends Hex {\n  /**\n   * Retrieves the value of n cast from this instance interpreted as the hexadecimal expression of a bigint value.\n   *\n   * @return {number} The value of n.\n   *\n   * @throws {InvalidDataType} If n is not within the safe number range, if the number representation of this\n   * instance results approximated.\n   *\n   * @remarks This class makes equal instances created from the same value as number or as bigint.\n   */\n  get n() {\n    const bi = this.bi;\n    if (Number.MIN_SAFE_INTEGER <= bi && bi <= Number.MAX_SAFE_INTEGER) {\n      return Number(bi);\n    }\n    throw new InvalidDataType2(\"HexInt.n\", \"not in the safe number range\", {\n      bi: `${bi}`,\n      hex: this.toString()\n    });\n  }\n  /**\n   * Create a HexInt instance from a bigint, number, string, Uint8Array, or {@link Hex}.\n   *\n   * @param {bigint | number | string | Uint8Array | Hex} exp - The expression to be interpreted as an integer:\n   * * bigint is always representable in hexadecimal base notation;\n   * * number is converted to a bigint then represented in hexadecimal base notation;\n   *   it throws {@link InvalidDataType} if not an integer value;\n   * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;\n   * * Uint8Array is interpreted as the sequence of bytes expressing a bigint value;\n   * * {@link Hex} is interpreted as expressing a bigint value.\n   *\n   * @returns {HexInt} - The new HexInt object representing the given `exp`.\n   *\n   * @throws {InvalidDataType} - If the given `exp` is not a valid hexadecimal integer expression,\n   * if `exp` is a not integer number.\n   *\n   * @remarks This class makes equal instances created from the same value as number or as bigint.\n   */\n  static of(exp) {\n    try {\n      if (exp instanceof Hex) {\n        return new _HexInt(exp.sign, exp.digits);\n      }\n      if (typeof exp === \"number\") {\n        if (Number.isInteger(exp)) {\n          const hex2 = Hex.of(BigInt(exp));\n          return new _HexInt(hex2.sign, hex2.digits);\n        }\n        throw new InvalidDataType2(\"HexInt.of\", \"not an integer\", {\n          exp\n        });\n      }\n      const hex = Hex.of(exp);\n      return new _HexInt(hex.sign, hex.digits);\n    } catch (e) {\n      throw new InvalidDataType2(\n        \"HexInt.of\",\n        \"not an hexadecimal integer expression\",\n        { exp: `${exp}`, e }\n        // Needed to serialize bigint values.\n      );\n    }\n  }\n};\n\n// src/vcdm/HexUInt.ts\nimport { InvalidDataType as InvalidDataType3 } from \"@vechain/sdk-errors\";\nvar HexUInt = class _HexUInt extends HexInt {\n  /**\n   * Regular expression for matching hexadecimal strings.\n   * An empty input is represented as a empty digits.\n   *\n   * @type {RegExp}\n   */\n  static REGEX_HEXUINT = /^(0x)?[0-9a-f]*$/i;\n  /**\n   * Regular expression pattern to match a prefix indicating hexadecimal number.\n   *\n   * @type {RegExp}\n   */\n  static REGEX_HEXUINT_PREFIX = /^0x/i;\n  /**\n   * Checks if the given string expression is a valid unsigned hexadecimal value.\n   *\n   * @param {string} exp - The string representation of a hexadecimal value.\n   *\n   * @return {boolean} - True if the expression is a valid unsigned hexadecimal value, case-insensitive,\n   * optionally prefixed with `0x`; false otherwise.\n   */\n  static isValid(exp) {\n    return _HexUInt.REGEX_HEXUINT.test(exp);\n  }\n  /**\n   * Determines whether the given string is a valid unsigned hexadecimal number prefixed with '0x'.\n   *\n   * @param {string} exp - The string to be evaluated.\n   * @return {boolean} - True if the string is a valid unsigned hexadecimal number prefixed with '0x', otherwise false.\n   */\n  static isValid0x(exp) {\n    return _HexUInt.REGEX_HEX_PREFIX.test(exp) && Hex.isValid(exp);\n  }\n  /**\n   * Create a HexUInt instance from a bigint, number, string, Uint8Array, or {@link HexInt}.\n   *\n   * @param {bigint | number | string | Uint8Array | HexInt} exp - The expression to be interpreted as an unsigned integer:\n   * * bigint is always representable in hexadecimal base notation,\n   *   it throws {@link InvalidDataType} if not positive;\n   * * number is converted to a bigint then represented in hexadecimal base notation,\n   *   it throws {@link InvalidDataType} if not a positive integer value;\n   * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;\n   *   it throws {@link InvalidDataType} if not positive;\n   * * Uint8Array is interpreted as the sequence of bytes expressing a positive bigint value;\n   * * {@link HexInt} is interpreted as expressing a bigint value,\n   *   it throws {@link InvalidDataType} if not positive.\n   *\n   * @returns {HexUInt} he new HexInt object representing the given `exp`.\n   *\n   * @throws {InvalidDataType} If the given expression is not a valid hexadecimal positive integer expression.\n   */\n  static of(exp) {\n    try {\n      const hint = HexInt.of(exp);\n      if (hint.sign >= Hex.POSITIVE) {\n        return new _HexUInt(hint.sign, hint.digits);\n      }\n      throw new InvalidDataType3(\n        \"HexUInt.of\",\n        \"not positive\",\n        { exp: `${exp}` }\n        // Needed to serialize bigint values.\n      );\n    } catch (e) {\n      throw new InvalidDataType3(\n        \"HexUInt.of\",\n        \"not a hexadecimal positive integer expression\",\n        { exp: `${exp}`, e },\n        // Needed to serialize bigint values.\n        e\n      );\n    }\n  }\n};\n\n// src/vcdm/Txt.ts\nimport { InvalidOperation as InvalidOperation4 } from \"@vechain/sdk-errors\";\nvar Txt = class _Txt extends String {\n  /**\n   * Decoder object used for decoding bytes as text data.\n   *\n   * @class\n   * @constructor\n   */\n  static DECODER = new TextDecoder();\n  /**\n   * *Normalization Form Canonical Composition*\n   * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence)\n   * flag.\n   *\n   * @type {string}\n   * @constant\n   */\n  static NFC = \"NFC\";\n  /**\n   * A TextEncoder instance used for encoding text to bytes.\n   *\n   * @type {TextEncoder}\n   */\n  static ENCODER = new TextEncoder();\n  /**\n   * Creates a new instance of this class representing the `exp` string\n   * normalized according the *Canonical Composition Form*\n   * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence).\n   *\n   * @param {string} exp - The expression to be passed to the constructor.\n   * @protected\n   * @constructor\n   */\n  constructor(exp) {\n    super(exp.normalize(_Txt.NFC));\n  }\n  /**\n   * Converts the current Txt string to a BigInt.\n   *\n   * @returns {bigint} The BigInt representation of the Txt string.\n   *\n   *  @throws {InvalidOperation} If the conversion to BigInt fails because this Txt string doesn't represent an integer.\n   */\n  get bi() {\n    try {\n      return BigInt(this.toString());\n    } catch (e) {\n      throw new InvalidOperation4(\n        \"Txt.bi()\",\n        \"Can't cast to big integer\",\n        { txt: this.toString() },\n        e\n      );\n    }\n  }\n  /**\n   * Converts the current Txt string to a buffer of bytes.\n   *\n   * @returns {Uint8Array} The bytes representation of the Txt string.\n   */\n  get bytes() {\n    return _Txt.ENCODER.encode(this.toString());\n  }\n  /**\n   * Returns the value of n as a number.\n   *\n   * @returns {number} The value of n as a number.\n   */\n  /**\n   * Converts the current Txt string to a number.\n   *\n   * @returns {number} The numeric value of the Txt string.\n   *\n   * @throws {InvalidOperation} If the conversion to number fails because this Txt string doesn't represent a decimal number.\n   */\n  get n() {\n    return Number(this.toString());\n  }\n  /**\n   * Compares the current instance to another instance of Txt.\n   *\n   * @param {Txt} that - The instance to compare with.\n   *\n   * @return {number} - A negative number if the current instance is less than the specified instance,\n   *                    zero if they are equal, or a positive number if the current instance is greater.\n   */\n  compareTo(that) {\n    return this.toString().localeCompare(that.toString());\n  }\n  /**\n   * Checks if the current Txt object is equal to the given Txt object.\n   *\n   * @param {Txt} that - The Txt object to compare with.\n   *\n   *  @return {boolean} - True if the objects are equal, false otherwise.\n   */\n  isEqual(that) {\n    return this.compareTo(that) === 0;\n  }\n  /**\n   * Returns a string representation of the object.\n   *\n   * @returns {string} A string representation of the object.\n   */\n  toString() {\n    return this.valueOf();\n  }\n  /**\n   * Creates a new Txt instance from the provided expression.\n   *\n   * @param {bigint | number | string | Uint8Array} exp - The expression to convert to Txt:\n   * * {@link bigint} is represented as a {@link NFC} encoded string expressing the value in base 10;\n   * * {@link number} is represented as a {@link NFC} encoded string expressing the value in base 10;\n   * * {@link string} is encoded as {@link NFC} string;\n   * * {@link Uint8Array} is {@link NFC} decoded to a string.\n   *\n   * @returns {Txt} - A new Txt instance.\n   */\n  static of(exp) {\n    if (exp instanceof Uint8Array) {\n      return new _Txt(_Txt.DECODER.decode(exp));\n    } else if (typeof exp === \"bigint\" || typeof exp === \"number\") {\n      return new _Txt(exp.toString());\n    }\n    return new _Txt(exp);\n  }\n};\n\n// src/vcdm/hash/Keccak256.ts\nvar Keccak256 = class _Keccak256 extends HexUInt {\n  /**\n   * Generates the [SHA-3](https://en.wikipedia.org/wiki/SHA-3) [KECCAK 256](https://keccak.team/keccak.html) hash of the given input.\n   *\n   * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.\n   *\n   * @returns {Sha256} - The [KECCAK 256](https://keccak.team/keccak.html) hash of the input value.\n   *\n   * @throws {InvalidOperation} - If a hash error occurs.\n   *\n   * @remarks Security auditable method, depends on\n   * * [`nh_keccak_256`](https://github.com/paulmillr/noble-hashes#sha3-fips-shake-keccak).\n   */\n  static of(exp) {\n    try {\n      const hash2 = nh_keccak_256(HexUInt.of(exp).bytes);\n      return new _Keccak256(Hex.POSITIVE, HexUInt.of(hash2).digits);\n    } catch (e) {\n      throw new InvalidOperation5(\"Keccak256.of\", \"hash error\", {\n        exp: `${exp}`,\n        // Needed to serialize bigint values.\n        e\n      });\n    }\n  }\n};\nfunction keccak256(data, returnType = \"buffer\") {\n  return returnType === \"buffer\" ? Keccak256.of(Txt.of(data).bytes).bytes : Keccak256.of(Txt.of(data).bytes).toString();\n}\n\n// src/hdkey/HDKey.ts\nimport * as s_bip32 from \"@scure/bip32\";\nimport * as s_bip39 from \"@scure/bip39\";\nimport * as nc_utils3 from \"@noble/curves/abstract/utils\";\nimport { base58 } from \"@scure/base\";\n\n// src/vcdm/FixedPointNumber.ts\nimport { InvalidDataType as InvalidDataType4, InvalidOperation as InvalidOperation6 } from \"@vechain/sdk-errors\";\nvar FixedPointNumber = class _FixedPointNumber {\n  /**\n   * The default number of decimal places to use for fixed-point math.\n   *\n   * @see\n   * [bignumber.js DECIMAL_PLACES](https://mikemcl.github.io/bignumber.js/#decimal-places)\n   *\n   * @constant {bigint}\n   */\n  static DEFAULT_FRACTIONAL_DECIMALS = 20n;\n  /**\n   * Not a Number.\n   *\n   * @remarks {@link fd} and {@link sv} not meaningful.\n   *\n   * @see [Number.NaN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN)\n   *\n   */\n  static NaN = new _FixedPointNumber(0n, 0n, NaN);\n  /**\n   * The negative Infinity value.\n   *\n   * @remarks {@link fd} and {@link sv} not meaningful.\n   *\n   * @see [Number.NEGATIVE_INFINITY](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY)\n   */\n  static NEGATIVE_INFINITY = new _FixedPointNumber(\n    0n,\n    0n,\n    Number.NEGATIVE_INFINITY\n  );\n  /**\n   * The positive Infinite value.\n   *\n   * @remarks {@link fd} and {@link sv} not meaningful.\n   *\n   * @see [Number.POSITIVE_INFINITY](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY)\n   */\n  static POSITIVE_INFINITY = new _FixedPointNumber(\n    0n,\n    0n,\n    Number.POSITIVE_INFINITY\n  );\n  /**\n   * Regular expression pattern for matching integers expressed as base 10 strings.\n   */\n  static REGEX_INTEGER = /^[-+]?\\d+$/;\n  /**\n   * Regular expression for matching numeric values expressed as base 10 strings.\n   */\n  static REGEX_NUMBER = /(^[-+]?\\d+(\\.\\d+)?)$|(^[-+]?\\.\\d+)$/;\n  /**\n   * Regular expression pattern for matching natural numbers expressed as base 10 strings.\n   */\n  static REGEX_NATURAL = /^\\d+$/;\n  /**\n   * Represents the zero constant.\n   */\n  static ZERO = new _FixedPointNumber(0n, 0n, 0);\n  /**\n   * Edge Flag denotes the {@link NaN} or {@link NEGATIVE_INFINITY} or {@link POSITIVE_INFINITY} value.\n   *\n   * @remarks If `ef` is not zero, {@link fd} and {@link sv} are not meaningful.\n   */\n  ef;\n  /**\n   * Fractional Digits or decimal places.\n   */\n  fd;\n  /**\n   * Scaled Value = value * 10 ^ {@link fd}.\n   */\n  sv;\n  /**\n   * Returns the integer part of this FixedPointNumber value.\n   *\n   * @return {bigint} the integer part of this FixedPointNumber value.\n   *\n   * @throws {InvalidOperation} If the value is not finite.\n   */\n  get bi() {\n    if (this.isFinite()) {\n      return this.sv / 10n ** this.fd;\n    }\n    throw new InvalidOperation6(\n      \"FixedPointNumber.bi\",\n      \"not finite value cannot cast to big integer\",\n      { this: this.toString() }\n    );\n  }\n  /**\n   * Returns the array of bytes representing the *Normalization Form Canonical Composition*\n   * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence)\n   * of this value expressed in decimal base.\n   */\n  get bytes() {\n    return Txt.of(this.toString()).bytes;\n  }\n  /**\n   * Return this value approximated as {@link number}.\n   */\n  get n() {\n    if (this.isNaN()) return Number.NaN;\n    if (this.isNegativeInfinite()) return Number.NEGATIVE_INFINITY;\n    if (this.isPositiveInfinite()) return Number.POSITIVE_INFINITY;\n    if (this.isZero()) return 0;\n    return Number(this.sv) * 10 ** -Number(this.fd);\n  }\n  /**\n   * Returns the new Fixed-Point Number (FixedPointNumber) instance having\n   *\n   * @param {bigint} fd - Number of Fractional Digits (or decimal places).\n   * @param {bigint} sv - Scaled Value.\n   * @param {number} [ef=0] - Edge Flag.\n   */\n  constructor(fd, sv, ef = 0) {\n    this.fd = fd;\n    this.ef = ef;\n    this.sv = sv;\n  }\n  /**\n   * Returns a FixedPointNumber whose value is the absolute value, i.e. the magnitude, of the value of this FixedPointNumber.\n   *\n   * @return {FixedPointNumber} the absolute value of this FixedPointNumber.\n   *\n   * @see [bignumber.js absoluteValue](https://mikemcl.github.io/bignumber.js/#abs)\n   */\n  abs() {\n    if (this.isNaN()) return _FixedPointNumber.NaN;\n    if (this.isNegativeInfinite())\n      return _FixedPointNumber.POSITIVE_INFINITY;\n    return new _FixedPointNumber(\n      this.fd,\n      this.sv < 0n ? -this.sv : this.sv,\n      this.ef\n    );\n  }\n  /**\n   * Compares this instance with `that` FixedPointNumber instance.\n   * * Returns 0 if this is equal to `that` FixedPointNumber, including infinite with equal sign;\n   * * Returns -1, if this is -Infinite or less than `that` FixedPointNumber;,\n   * * Returns 1 if this is +Infinite or greater than `that` FixedPointNumber.\n   *\n   * @param {FixedPointNumber} that - The instance to compare with this instance.\n   * @return {number} Returns -1, 0, or 1 if this instance is less than, equal to, or greater\n   * than the specified instance, respectively.\n   * @throw InvalidOperation If this or `that` FixedPointNumber is {@link NaN}.\n   *\n   * @see [bignumber.js comparedTo](https://mikemcl.github.io/bignumber.js/#cmp)\n   */\n  compareTo(that) {\n    if (this.isNaN() || that.isNaN())\n      throw new InvalidOperation6(\n        \"FixedPointNumber.compareTo\",\n        \"compare between NaN\",\n        {\n          this: `${this}`,\n          that: `${that}`\n        }\n      );\n    if (this.isNegativeInfinite())\n      return that.isNegativeInfinite() ? 0 : -1;\n    if (this.isPositiveInfinite()) return that.isPositiveInfinite() ? 0 : 1;\n    if (that.isNegativeInfinite()) return 1;\n    if (that.isPositiveInfinite()) return -1;\n    const fd = this.fd > that.fd ? this.fd : that.fd;\n    const delta = this.dp(fd).sv - that.dp(fd).sv;\n    return delta < 0n ? -1 : delta === 0n ? 0 : 1;\n  }\n  /**\n   * Compares this instance with `that` FixedPointNumber instance.\n   * * **Returns `null` if either instance is NaN;**\n   * * Returns 0 if this is equal to `that` FixedPointNumber, including infinite with equal sign;\n   * * Returns -1, if this is -Infinite or less than `that` FixedPointNumber;,\n   * * Returns 1 if this is +Infinite or greater than `that` FixedPointNumber.\n   *\n   * @param {FixedPointNumber} that - The instance to compare with this instance.\n   * @return {null | number} A null if either instance is NaN;\n   * -1, 0, or 1 if this instance is less than, equal to, or greater\n   * than the specified instance, respectively.\n   *\n   * @remarks This method uses internally {@link compareTo} wrapping the {@link InvalidOperation} exception\n   * when comparing between {@link NaN} values to behave according the\n   * [[bignumber.js comparedTo](https://mikemcl.github.io/bignumber.js/#cmp)] rules.\n   */\n  comparedTo(that) {\n    try {\n      return this.compareTo(that);\n    } catch (e) {\n      return null;\n    }\n  }\n  /**\n   * Returns a FixedPointNumber whose value is the value of this FixedPointNumber divided by `that` FixedPointNumber.\n   *\n   * Limit cases\n   * * 0 / 0 = NaN\n   * * NaN / ±n = NaN\n   * * ±Infinity / ±Infinity = NaN\n   * * +n / NaN = NaN\n   * * +n / ±Infinity = 0\n   * * -n / 0 = -Infinity\n   * * +n / 0 = +Infinity\n   *\n   * @param {FixedPointNumber} that - The fixed-point number to divide by.\n   * @return {FixedPointNumber} The result of the division.\n   *\n   * @remarks The precision is the greater of the precision of the two operands.\n   *\n   * @see [bignumber.js dividedBy](https://mikemcl.github.io/bignumber.js/#div)\n   */\n  div(that) {\n    if (this.isNaN() || that.isNaN()) return _FixedPointNumber.NaN;\n    if (this.isNegativeInfinite())\n      return that.isInfinite() ? _FixedPointNumber.NaN : that.isPositive() ? _FixedPointNumber.NEGATIVE_INFINITY : _FixedPointNumber.POSITIVE_INFINITY;\n    if (this.isPositiveInfinite())\n      return that.isInfinite() ? _FixedPointNumber.NaN : that.isPositive() ? _FixedPointNumber.POSITIVE_INFINITY : _FixedPointNumber.NEGATIVE_INFINITY;\n    if (that.isInfinite()) return _FixedPointNumber.ZERO;\n    if (that.isZero())\n      return this.isZero() ? _FixedPointNumber.NaN : this.isNegative() ? _FixedPointNumber.NEGATIVE_INFINITY : _FixedPointNumber.POSITIVE_INFINITY;\n    const fd = this.fd > that.fd ? this.fd : that.fd;\n    return new _FixedPointNumber(\n      fd,\n      _FixedPointNumber.div(fd, this.dp(fd).sv, that.dp(fd).sv)\n    );\n  }\n  /**\n   * Divides the given dividend by the given divisor, adjusted by a factor based on fd.\n   *\n   * @param {bigint} fd - The factor determining the power of 10 to apply to the dividend.\n   * @param {bigint} dividend - The number to be divided.\n   * @param {bigint} divisor - The number by which to divide the dividend.\n   *\n   * @return {bigint} - The result of the division, adjusted by the given factor fd.\n   */\n  static div(fd, dividend, divisor) {\n    return 10n ** fd * dividend / divisor;\n  }\n  /**\n   * Adjusts the precision of the floating-point number by the specified\n   * number of decimal places.\n   *\n   * @param {bigint | number} decimalPlaces - The number of decimal places to adjust to.\n   * @return {FixedPointNumber} A new FixedPointNumber instance with the adjusted precision.\n   */\n  dp(decimalPlaces) {\n    const fp = BigInt(decimalPlaces);\n    const dd = fp - this.fd;\n    if (dd < 0) {\n      return new _FixedPointNumber(fp, this.sv / 10n ** -dd);\n    } else {\n      return new _FixedPointNumber(fp, this.sv * 10n ** dd);\n    }\n  }\n  /**\n   * Returns `true `if the value of thisFPN is equal to the value of `that` FixedPointNumber, otherwise returns `false`.\n   *\n   * As with JavaScript, `NaN` does not equal `NaN`.\n   *\n   * @param {FixedPointNumber} that - The FixedPointNumber to compare against.\n   * @return {boolean} `true` if the FixedPointNumber numbers are equal, otherwise `false`.\n   *\n   * @remarks This method uses {@link comparedTo} internally.\n   *\n   * @see [bigbumber.js isEqualTo](https://mikemcl.github.io/bignumber.js/#eq)\n   */\n  eq(that) {\n    return this.comparedTo(that) === 0;\n  }\n  /**\n   * Returns `true` if the value of this FixedPointNumber is greater than `that` FixedPointNumber`, otherwise returns `false`.\n   *\n   * @param {FixedPointNumber} - that The FixedPointNumber to compare against.\n   * @return {boolean} `true` if this FixedPointNumber is greater than `that` FixedPointNumber, otherwise `false`.\n   *\n   * @remarks This method uses {@link comparedTo} internally.\n   *\n   * @see [bignummber.js isGreaterThan](https://mikemcl.github.io/bignumber.js/#gt)\n   */\n  gt(that) {\n    const cmp = this.comparedTo(that);\n    return cmp !== null && cmp > 0;\n  }\n  /**\n   * Returns `true` if the value of this FixedPointNumber is greater or equal than `that` FixedPointNumber`, otherwise returns `false`.\n   *\n   * @param {FixedPointNumber} that - The FixedPointNumber to compare against.\n   * @return {boolean} `true` if this FixedPointNumber is greater or equal than `that` FixedPointNumber, otherwise `false`.\n   *\n   * @remarks This method uses {@link comparedTo} internally.\n   *\n   * @see [bignumber.js isGreaterThanOrEqualTo](https://mikemcl.github.io/bignumber.js/#gte)\n   */\n  gte(that) {\n    const cmp = this.comparedTo(that);\n    return cmp !== null && cmp >= 0;\n  }\n  /**\n   * Returns a fixed-point number whose value is the integer part of dividing the value of this fixed-point number\n   * by `that` fixed point number.\n   *\n   * Limit cases\n   * * 0 / 0 = NaN\n   * * NaN / ±n = NaN\n   * * ±Infinity / ±Infinity = NaN\n   * * +n / NaN = NaN\n   * * +n / ±Infinite = 0\n   * * -n / 0 = -Infinite\n   * * +n / 0 = +Infinite\n   *\n   * @param {FixedPointNumber} that - The fixed-point number to divide by.\n   * @return {FixedPointNumber} The result of the division.\n   *\n   * @remarks The precision is the greater of the precision of the two operands.\n   *\n   * @see [bignumber.js dividedToIntegerBy](https://mikemcl.github.io/bignumber.js/#divInt)\n   */\n  idiv(that) {\n    if (this.isNaN() || that.isNaN()) return _FixedPointNumber.NaN;\n    if (this.isNegativeInfinite())\n      return that.isInfinite() ? _FixedPointNumber.NaN : that.isPositive() ? _FixedPointNumber.NEGATIVE_INFINITY : _FixedPointNumber.POSITIVE_INFINITY;\n    if (this.isPositiveInfinite())\n      return that.isInfinite() ? _FixedPointNumber.NaN : that.isPositive() ? _FixedPointNumber.POSITIVE_INFINITY : _FixedPointNumber.NEGATIVE_INFINITY;\n    if (that.isInfinite()) return _FixedPointNumber.ZERO;\n    if (that.isZero())\n      return this.isZero() ? _FixedPointNumber.NaN : this.isNegative() ? _FixedPointNumber.NEGATIVE_INFINITY : _FixedPointNumber.POSITIVE_INFINITY;\n    const fd = this.fd > that.fd ? this.fd : that.fd;\n    return new _FixedPointNumber(\n      fd,\n      _FixedPointNumber.idiv(fd, this.dp(fd).sv, that.dp(fd).sv)\n    );\n  }\n  /**\n   * Performs integer division on two big integers and scales the result by a factor of 10 raised to the power of fd.\n   *\n   * @param {bigint} fd - The power to which 10 is raised to scale the result.\n   * @param {bigint} dividend - The number to be divided.\n   * @param {bigint} divisor - The number by which dividend is divided.\n   * @return {bigint} - The scaled result of the integer division.\n   */\n  static idiv(fd, dividend, divisor) {\n    return dividend / divisor * 10n ** fd;\n  }\n  /**\n   * Returns `true `if the value of thisFPN is equal to the value of `that` FixedPointNumber, otherwise returns `false`.\n   *\n   * As with JavaScript, `NaN` does not equal `NaN`.\n   *\n   * @param {FixedPointNumber} that - The FixedPointNumber to compare against.\n   * @return {boolean} `true` if the FixedPointNumber numbers are equal, otherwise `false`.\n   *\n   * @remarks This method uses {@link eq} internally.\n   */\n  isEqual(that) {\n    return this.eq(that);\n  }\n  /**\n   * Returns `true` if the value of this FixedPointNumber is a finite number, otherwise returns `false`.\n   *\n   * The only possible non-finite values of a FixedPointNumber are {@link NaN}, {@link NEGATIVE_INFINITY} and {@link POSITIVE_INFINITY}.\n   *\n   * @return `true` if the value of this FixedPointNumber is a finite number, otherwise returns `false`.\n   *\n   * @see [bignumber.js isFinite](https://mikemcl.github.io/bignumber.js/#isF)\n   */\n  isFinite() {\n    return this.ef === 0;\n  }\n  /**\n   * Return `true` if the value of this FixedPointNumber is {@link NEGATIVE_INFINITY} and {@link POSITIVE_INFINITY},\n   * otherwise returns false.\n   *\n   * @return true` if the value of this FixedPointNumber is {@link NEGATIVE_INFINITY} and {@link POSITIVE_INFINITY},\n   */\n  isInfinite() {\n    return this.isNegativeInfinite() || this.isPositiveInfinite();\n  }\n  /**\n   * Returns `true` if the value of this FixedPointNumber is an integer,\n   * otherwise returns `false`.\n   *\n   * @return `true` if the value of this FixedPointNumber is an integer.\n   *\n   * @see [bignumber.js isInteger](https://mikemcl.github.io/bignumber.js/#isInt)\n   */\n  isInteger() {\n    if (this.isFinite()) {\n      return this.sv % 10n ** this.fd === 0n;\n    }\n    return false;\n  }\n  /**\n   * Checks if a given string expression is an integer in base 10 notation,\n   * considering `-` for negative and `+` optional for positive values.\n   *\n   * @param {string} exp - The string expression to be tested.\n   *\n   * @return {boolean} `true` if the expression is an integer,\n   * `false` otherwise.\n   */\n  static isIntegerExpression(exp) {\n    return this.REGEX_INTEGER.test(exp);\n  }\n  /**\n   *  Returns `true` if the value of this FixedPointNumber is `NaN`, otherwise returns `false`.\n   *\n   *  @return `true` if the value of this FixedPointNumber is `NaN`, otherwise returns `false`.\n   *\n   *  @see [bignumber.js isNaN](https://mikemcl.github.io/bignumber.js/#isNaN)\n   */\n  isNaN() {\n    return Number.isNaN(this.ef);\n  }\n  /**\n   * Checks if a given string expression is a natural (unsigned positive integer)\n   * number in base 10 notation.\n   *\n   * @param {string} exp - The string expression to be tested.\n   *\n   * @return {boolean} `true` if the expression is a natural number,\n   * `false` otherwise.\n   */\n  static isNaturalExpression(exp) {\n    return this.REGEX_NATURAL.test(exp);\n  }\n  /**\n   * Returns `true` if the sign of this FixedPointNumber is negative, otherwise returns `false`.\n   *\n   * @return `true` if the sign of this FixedPointNumber is negative, otherwise returns `false`.\n   *\n   * @see [bignumber.js isNegative](https://mikemcl.github.io/bignumber.js/#isNeg)\n   */\n  isNegative() {\n    return this.isFinite() && this.sv < 0n || this.isNegativeInfinite();\n  }\n  /**\n   * Returns `true` if this FixedPointNumber value is {@link NEGATIVE_INFINITY}, otherwise returns `false`.\n   */\n  isNegativeInfinite() {\n    return this.ef === Number.NEGATIVE_INFINITY;\n  }\n  /**\n   * Checks if a given string expression is a number in base 10 notation,\n   * considering `-` for negative and `+` optional for positive values.\n   *\n   * The method returns `true` for the following cases.\n   * - Whole numbers:\n   *   - Positive whole numbers, optionally signed: 1, +2, 3, ...\n   *   - Negative whole numbers: -1, -2, -3, ...\n   * - Decimal numbers:\n   *   - Positive decimal numbers, optionally signed: 1.0, +2.5, 3.14, ...\n   *   - Negative decimal numbers: -1.0, -2.5, -3.14, ...\n   *   - Decimal numbers without whole part:\n   *     - Positive decimal numbers, optionally signed: .1, +.5, .75, ...\n   *     - Negative decimal numbers: -.1, -.5, -.75, ...\n   *\n   * @param exp - The string expression to be checked.\n   *\n   * @return `true` is `exp` represents a number, otherwise `false`.\n   */\n  static isNumberExpression(exp) {\n    return _FixedPointNumber.REGEX_NUMBER.test(exp);\n  }\n  /**\n   * Returns `true` if the sign of this FixedPointNumber is positive, otherwise returns `false`.\n   *\n   * @return `true` if the sign of this FixedPointNumber is positive, otherwise returns `false`.\n   *\n   * @see [bignumber.js isPositive](https://mikemcl.github.io/bignumber.js/#isPos)\n   */\n  isPositive() {\n    return this.isFinite() && this.sv >= 0n || this.isPositiveInfinite();\n  }\n  /**\n   * Returns `true` if this FixedPointNumber value is {@link POSITIVE_INFINITY}, otherwise returns `false`.\n   *\n   * @return `true` if this FixedPointNumber value is {@link POSITIVE_INFINITY}, otherwise returns `false`.\n   */\n  isPositiveInfinite() {\n    return this.ef === Number.POSITIVE_INFINITY;\n  }\n  /**\n   * Returns `true` if the value of this FixedPointNumber is zero or minus zero, otherwise returns `false`.\n   *\n   * @return `true` if the value of this FixedPointNumber is zero or minus zero, otherwise returns `false`.\n   *\n   * [see bignumber.js isZero](https://mikemcl.github.io/bignumber.js/#isZ)\n   */\n  isZero() {\n    return this.isFinite() && this.sv === 0n;\n  }\n  /**\n   * Returns `true` if the value of this FixedPointNumber is less than the value of `that` FixedPointNumber, otherwise returns `false`.\n   *\n   * @param {FixedPointNumber} that - The FixedPointNumber to compare against.\n   *\n   * @return {boolean} `true` if the value of this FixedPointNumber is less than the value of `that` FixedPointNumber, otherwise returns `false`.\n   *\n   * @remarks This method uses {@link comparedTo} internally.\n   *\n   * @see [bignumber.js isLessThan](https://mikemcl.github.io/bignumber.js/#lt)\n   */\n  lt(that) {\n    const cmp = this.comparedTo(that);\n    return cmp !== null && cmp < 0;\n  }\n  /**\n   * Returns `true` if the value of this FixedPointNumber is less than or equal to the value of `that` FixedPointNumber,\n   * otherwise returns `false`.\n   *\n   * @param {FixedPointNumber} that - The FixedPointNumber to compare against.\n   * @return {boolean} `true` if the value of this FixedPointNumber is less than or equal to the value of `that` FixedPointNumber,\n   * otherwise returns `false`.\n   *\n   * @remarks This method uses {@link comparedTo} internally.\n   *\n   * @see [bignumber.js isLessThanOrEqualTo](https://mikemcl.github.io/bignumber.js/#lte)\n   */\n  lte(that) {\n    const cmp = this.comparedTo(that);\n    return cmp !== null && cmp <= 0;\n  }\n  /**\n   * Returns a FixedPointNumber whose value is the value of this FixedPointNumber minus `that` FixedPointNumber.\n   *\n   * Limit cases\n   * * NaN - ±n = NaN\n   * * ±n - NaN = NaN\n   * * -Infinity - -Infinity = NaN\n   * * -Infinity - +n = -Infinity\n   * * +Infinity - +Infinity = NaN\n   * * +Infinity - +n = +Infinity\n   *\n   * @param {FixedPointNumber} that - The fixed-point number to subtract.\n   * @return {FixedPointNumber} The result of the subtraction. The return value is always exact and unrounded.\n   *\n   * @remarks The precision is the greater of the precision of the two operands.\n   *\n   * @see [bignumber.js minus](https://mikemcl.github.io/bignumber.js/#minus)\n   */\n  minus(that) {\n    if (this.isNaN() || that.isNaN()) return _FixedPointNumber.NaN;\n    if (this.isNegativeInfinite())\n      return that.isNegativeInfinite() ? _FixedPointNumber.NaN : _FixedPointNumber.NEGATIVE_INFINITY;\n    if (this.isPositiveInfinite())\n      return that.isPositiveInfinite() ? _FixedPointNumber.NaN : _FixedPointNumber.POSITIVE_INFINITY;\n    const fd = this.fd > that.fd ? this.fd : that.fd;\n    return new _FixedPointNumber(fd, this.dp(fd).sv - that.dp(fd).sv);\n  }\n  /**\n   * Returns a FixedPointNumber whose value is the value of this FixedPointNumber modulo `that` FixedPointNumber,\n   * i.e. the integer remainder of dividing this FixedPointNumber by `that`.\n   *\n   * Limit cases\n   * * NaN % ±n = NaN\n   * * ±n % NaN = NaN\n   * * ±Infinity % n = NaN\n   * * n % ±Infinity = NaN\n   *\n   * @param that {FixedPointNumber} - The fixed-point number to divide by.\n   * @return {FixedPointNumber} the integer remainder of dividing this FixedPointNumber by `that`.\n   *\n   * @remarks The precision is the greater of the precision of the two operands.\n   *\n   * @see [bignumber.js modulo](https://mikemcl.github.io/bignumber.js/#mod)\n   */\n  modulo(that) {\n    if (this.isNaN() || that.isNaN()) return _FixedPointNumber.NaN;\n    if (this.isInfinite() || that.isInfinite()) return _FixedPointNumber.NaN;\n    if (that.isZero()) return _FixedPointNumber.NaN;\n    const fd = this.fd > that.fd ? this.fd : that.fd;\n    let modulo = this.abs().dp(fd).sv;\n    const divisor = that.abs().dp(fd).sv;\n    while (modulo >= divisor) {\n      modulo -= divisor;\n    }\n    return new _FixedPointNumber(fd, modulo);\n  }\n  /**\n   * Multiplies two big integer values and divides by a factor of ten raised to a specified power.\n   *\n   * @param {bigint} multiplicand - The first number to be multiplied.\n   * @param {bigint} multiplicator - The second number to be multiplied.\n   * @param {bigint} fd - The power of ten by which the product is to be divided.\n   *\n   * @return {bigint} The result of the multiplication divided by ten raised to the specified power.\n   */\n  static mul(multiplicand, multiplicator, fd) {\n    return multiplicand * multiplicator / 10n ** fd;\n  }\n  /**\n   * Returns a new instance of FixedPointNumber whose value is the value of this FixedPointNumber value\n   * negated, i.e. multiplied by -1.\n   *\n   * @see [bignumber.js negated](https://mikemcl.github.io/bignumber.js/#neg)\n   */\n  negated() {\n    if (this.isNegativeInfinite())\n      return _FixedPointNumber.POSITIVE_INFINITY;\n    if (this.isPositiveInfinite())\n      return _FixedPointNumber.NEGATIVE_INFINITY;\n    return new _FixedPointNumber(this.fd, -this.sv, this.ef);\n  }\n  /**\n   * Constructs a new instance of FixedPointNumber (Fixed Point Number) parsing the\n   * `exp` numeric expression in base 10 and representing the value with the\n   * precision of `decimalPlaces` fractional decimal digits.\n   *\n   * @param {bigint|number|string} exp - The value to represent.\n   * It can be a bigint, number, or string representation of the number.\n   * @param {bigint} [decimalPlaces=this.DEFAULT_FRACTIONAL_DECIMALS] - The\n   * number of fractional decimal digits to be used to represent the value.\n   *\n   * @return {FixedPointNumber} A new instance of FixedPointNumber with the given parameters.\n   *\n   * @throws {InvalidDataType} If `exp` is not a numeric expression.\n   */\n  static of(exp, decimalPlaces = this.DEFAULT_FRACTIONAL_DECIMALS) {\n    try {\n      if (Number.isNaN(exp))\n        return new _FixedPointNumber(decimalPlaces, 0n, Number.NaN);\n      if (exp === Number.NEGATIVE_INFINITY)\n        return new _FixedPointNumber(\n          decimalPlaces,\n          -1n,\n          Number.NEGATIVE_INFINITY\n        );\n      if (exp === Number.POSITIVE_INFINITY)\n        return new _FixedPointNumber(\n          decimalPlaces,\n          1n,\n          Number.POSITIVE_INFINITY\n        );\n      return new _FixedPointNumber(\n        decimalPlaces,\n        this.txtToSV(exp.toString(), decimalPlaces)\n      );\n    } catch (e) {\n      throw new InvalidDataType4(\n        \"FixedPointNumber.of\",\n        \"not a number\",\n        { exp },\n        e\n      );\n    }\n  }\n  /**\n   * Returns a FixedPointNumber whose value is the value of this FixedPointNumber plus `that` FixedPointNumber.\n   *\n   * Limit cases\n   * * NaN + ±n = NaN\n   * * ±n + NaN = NaN\n   * * -Infinity + -Infinity = -Infinity\n   * * -Infinity + +Infinity = NaN\n   * * +Infinity + -Infinity = NaN\n   * * +Infinity + +Infinity = +Infinity\n   *\n   * @param {FixedPointNumber} that - The fixed-point number to add to the current number.\n   * @return {FixedPointNumber} The result of the addition. The return value is always exact and unrounded.\n   *\n   * @remarks The precision is the greater of the precision of the two operands.\n   *\n   * @see [bignumber.js plus](https://mikemcl.github.io/bignumber.js/#plus)\n   */\n  plus(that) {\n    if (this.isNaN() || that.isNaN()) return _FixedPointNumber.NaN;\n    if (this.isNegativeInfinite())\n      return that.isPositiveInfinite() ? _FixedPointNumber.NaN : _FixedPointNumber.NEGATIVE_INFINITY;\n    if (this.isPositiveInfinite())\n      return that.isNegativeInfinite() ? _FixedPointNumber.NaN : _FixedPointNumber.POSITIVE_INFINITY;\n    const fd = this.fd > that.fd ? this.fd : that.fd;\n    return new _FixedPointNumber(fd, this.dp(fd).sv + that.dp(fd).sv);\n  }\n  /**\n   * Returns a FixedPointNumber whose value is the value of this FixedPointNumber raised to the power of `that` FixedPointNumber.\n   *\n   * Limit cases\n   * * NaN ^ e = NaN\n   * * b ^ NaN = NaN\n   * * b ^ -Infinite = 0\n   * * b ^ 0 = 1\n   * * b ^ +Infinite = +Infinite\n   * * ±Infinite ^ -e = 0\n   * * ±Infinite ^ +e = +Infinite\n   *\n   * @param {FixedPointNumber} that - The exponent as a fixed-point number.\n   * It can be negative, it can be not an integer value\n   * ([bignumber.js pow](https://mikemcl.github.io/bignumber.js/#pow)\n   * doesn't support not integer exponents).\n   * @return {FixedPointNumber} - The result of raising this fixed-point number to the power of the given exponent.\n   *\n   * @remarks The precision is the greater of the precision of the two operands.\n   * @remarks In fixed-precision math, the comparisons between powers of operands having different fractional\n   * precision can lead to differences.\n   *\n   * @see [bignumber.js exponentiatedBy](https://mikemcl.github.io/bignumber.js/#pow)\n   */\n  pow(that) {\n    if (this.isNaN() || that.isNaN()) return _FixedPointNumber.NaN;\n    if (this.isInfinite())\n      return that.isZero() ? _FixedPointNumber.of(1) : that.isNegative() ? _FixedPointNumber.ZERO : _FixedPointNumber.POSITIVE_INFINITY;\n    if (that.isNegativeInfinite()) return _FixedPointNumber.ZERO;\n    if (that.isPositiveInfinite())\n      return _FixedPointNumber.POSITIVE_INFINITY;\n    const fd = this.fd > that.fd ? this.fd : that.fd;\n    return new _FixedPointNumber(\n      fd,\n      _FixedPointNumber.pow(fd, this.dp(fd).sv, that.dp(fd).sv)\n    );\n  }\n  /**\n   * Computes the power of a given base raised to a specified exponent.\n   *\n   * @param {bigint} fd - The scale factor for decimal precision.\n   * @param {bigint} base - The base number to be raised to the power.\n   * @param {bigint} exponent - The exponent to which the base should be raised.\n   * @return {bigint} The result of base raised to the power of exponent, scaled by the scale factor.\n   */\n  static pow(fd, base, exponent) {\n    const sf = 10n ** fd;\n    if (exponent < 0n) {\n      return _FixedPointNumber.pow(\n        fd,\n        _FixedPointNumber.div(fd, sf, base),\n        -exponent\n      );\n    }\n    if (exponent === 0n) {\n      return 1n * sf;\n    }\n    if (exponent === sf) {\n      return base;\n    }\n    return _FixedPointNumber.pow(\n      fd,\n      this.mul(base, base, fd),\n      exponent - sf\n    );\n  }\n  /**\n   * Computes the square root of a given positive bigint value using a fixed-point iteration method.\n   *\n   * @param {bigint} value - The positive bigint value for which the square root is to be calculated.\n   * @param {bigint} fd - The iteration factor determinant.\n   * @return {bigint} The calculated square root of the input bigint value.\n   *\n   * @throws {RangeError} If the input value is negative.\n   */\n  static sqr(value, fd) {\n    if (value < 0n) {\n      throw new RangeError(`Value must be positive`);\n    }\n    const sf = fd * 10n;\n    let iteration = 0;\n    let actualResult = value;\n    let storedResult = 0n;\n    while (actualResult !== storedResult && iteration < sf) {\n      storedResult = actualResult;\n      actualResult = (actualResult + _FixedPointNumber.div(fd, value, actualResult)) / 2n;\n      iteration++;\n    }\n    return actualResult;\n  }\n  /**\n   * Returns a FixedPointNumber whose value is the square root of the value of this FixedPointNumber\n   *\n   * Limit cases\n   * * NaN = NaN\n   * * +Infinite = +Infinite\n   * * -n = NaN\n   *\n   * @return {FixedPointNumber} The square root of the number.\n   *\n   * @see [bignumber.js sqrt](https://mikemcl.github.io/bignumber.js/#sqrt)\n   */\n  sqrt() {\n    if (this.isNaN()) return _FixedPointNumber.NaN;\n    if (this.isNegativeInfinite()) return _FixedPointNumber.NaN;\n    if (this.isPositiveInfinite())\n      return _FixedPointNumber.POSITIVE_INFINITY;\n    try {\n      return new _FixedPointNumber(\n        this.fd,\n        _FixedPointNumber.sqr(this.sv, this.fd)\n      );\n    } catch (e) {\n      return _FixedPointNumber.NaN;\n    }\n  }\n  /**\n   * Returns a FixedPointNumber whose value is the value of this FixedPointNumber multiplied by `that` FixedPointNumber.\n   *\n   * Limits cases\n   * * NaN * n = NaN\n   * * n * NaN = NaN\n   * * -Infinite * -n = +Infinite\n   * * -Infinite * +n = -Infinite\n   * * +Infinite * -n = -Infinite\n   * * +Infinite * +n = +Infinite\n   *\n   * @param {FixedPointNumber} that - The fixed-point number to multiply with this number.\n   * @return {FixedPointNumber} a FixedPointNumber whose value is the value of this FixedPointNumber multiplied by `that` FixedPointNumber.\n   *\n   * @remarks The precision is the greater of the precision of the two operands.\n   *\n   * @see [bignumber.js multipliedBy](https://mikemcl.github.io/bignumber.js/#times)\n   */\n  times(that) {\n    if (this.isNaN() || that.isNaN()) return _FixedPointNumber.NaN;\n    if (this.isNegativeInfinite())\n      return that.isNegative() ? _FixedPointNumber.POSITIVE_INFINITY : _FixedPointNumber.NEGATIVE_INFINITY;\n    if (this.isPositiveInfinite())\n      return that.isNegative() ? _FixedPointNumber.NEGATIVE_INFINITY : _FixedPointNumber.POSITIVE_INFINITY;\n    const fd = this.fd > that.fd ? this.fd : that.fd;\n    return new _FixedPointNumber(\n      fd,\n      _FixedPointNumber.mul(this.dp(fd).sv, that.dp(fd).sv, fd)\n    );\n  }\n  /**\n   * Converts the fixed-point number to its string representation.\n   *\n   * @param {string} [decimalSeparator='.'] - The character to use as the decimal separator in the string representation. Default is '.'.\n   * @return {string} A string representation of the fixed-point number.\n   */\n  toString(decimalSeparator = \".\") {\n    if (this.ef === 0) {\n      const sign = this.sv < 0n ? \"-\" : \"\";\n      const digits = this.sv < 0n ? (-this.sv).toString() : this.sv.toString();\n      const padded = digits.padStart(Number(this.fd), \"0\");\n      const decimals = this.fd > 0 ? padded.slice(Number(-this.fd)) : \"\";\n      const integers = padded.slice(0, padded.length - decimals.length);\n      const integersShow = integers.length < 1 ? \"0\" : integers;\n      const decimalsShow = _FixedPointNumber.trimEnd(decimals);\n      return sign + integersShow + (decimalsShow.length > 0 ? decimalSeparator + decimalsShow : \"\");\n    }\n    return this.ef.toString();\n  }\n  /**\n   * Trims the specified trailing substring from the end of the input string recursively.\n   *\n   * @param {string} str - The input string to be trimmed.\n   * @param {string} [sub='0'] - The substring to be removed from the end of the input string. Defaults to '0' if not provided.\n   * @return {string} The trimmed string with the specified trailing substring removed.\n   */\n  static trimEnd(str, sub = \"0\") {\n    if (str.endsWith(sub)) {\n      return _FixedPointNumber.trimEnd(\n        str.substring(0, str.length - sub.length),\n        sub\n      );\n    }\n    return str;\n  }\n  /**\n   * Converts a string expression of a number into a scaled value.\n   *\n   * @param {string} exp - The string expression of the number to be converted.\n   * @param {bigint} fd - The scale factor to be used for conversion.\n   * @param {string} [decimalSeparator='.'] - The character used as the decimal separator in the string expression.\n   * @return {bigint} - The converted scaled value as a bigint.\n   */\n  static txtToSV(exp, fd, decimalSeparator = \".\") {\n    const fc = exp.charAt(0);\n    let sign = 1n;\n    if (fc === \"-\") {\n      sign = -1n;\n      exp = exp.substring(1);\n    } else if (fc === \"+\") {\n      exp = exp.substring(1);\n    }\n    const sf = 10n ** fd;\n    const di = exp.lastIndexOf(decimalSeparator);\n    if (di < 0) {\n      return sign * sf * BigInt(exp);\n    }\n    const ie = exp.substring(0, di);\n    const fe = exp.substring(di + 1);\n    return sign * sf * BigInt(ie) + // Integer part\n    sign * (sf * BigInt(fe)) / BigInt(10 ** fe.length);\n  }\n};\n\n// src/vcdm/hash/Sha256.ts\nimport * as nh_sha256 from \"@noble/hashes/sha256\";\nimport { InvalidOperation as InvalidOperation7 } from \"@vechain/sdk-errors\";\nvar Sha256 = class _Sha256 extends HexUInt {\n  /**\n   * Generates the [SHA 256](https://en.wikipedia.org/wiki/SHA-2) hash of the given input.\n   *\n   * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.\n   *\n   * @returns {Sha256} - The [SHA256](https://en.wikipedia.org/wiki/SHA-2) hash of the input value.\n   *\n   * @throws {InvalidOperation} - If a hash error occurs.\n   *\n   * @remarks Security auditable method, depends on\n   * * [`nh_sha256.sha256`](https://github.com/paulmillr/noble-hashes#sha2-sha256-sha384-sha512-and-others).\n   */\n  static of(exp) {\n    try {\n      const hash2 = nh_sha256.sha256(HexUInt.of(exp).bytes);\n      return new _Sha256(Hex.POSITIVE, HexUInt.of(hash2).digits);\n    } catch (e) {\n      throw new InvalidOperation7(\"Sha256.of\", \"hash error\", {\n        exp: `${exp}`,\n        // Needed to serialize bigint values.\n        e\n      });\n    }\n  }\n};\nfunction sha2562(data, returnType = \"buffer\") {\n  return returnType === \"buffer\" ? Sha256.of(Txt.of(data).bytes).bytes : Sha256.of(Txt.of(data).bytes).toString();\n}\n\n// src/secp256k1/Secp256k1.ts\nimport * as nc_utils2 from \"@noble/curves/abstract/utils\";\nimport { randomBytes as nh_randomBytes } from \"@noble/hashes/utils\";\nimport { secp256k1 as nc_secp256k1 } from \"@noble/curves/secp256k1\";\nimport {\n  InvalidSecp256k1MessageHash,\n  InvalidSecp256k1PrivateKey,\n  InvalidSecp256k1Signature\n} from \"@vechain/sdk-errors\";\nvar Secp256k1 = class _Secp256k1 {\n  /**\n   * This value is used to identify compressed public key.\n   */\n  static COMPRESSED_PREFIX = 2;\n  /**\n   * Represents the fixed length of the cryptographic signature.\n   * The value is set to 65, which is the size in bytes\n   * required for a 520-bit signature.\n   *\n   * @constant {number} SIGNATURE_LENGTH\n   */\n  static SIGNATURE_LENGTH = 65;\n  /**\n   * This value is used to identify uncompressed public key.\n   */\n  static UNCOMPRESS_PREFIX = 4;\n  /**\n   * Defines the required length for a valid hash.\n   */\n  static VALID_HASH_LENGTH = 32;\n  /**\n   * Compresses an uncompressed public key.\n   *\n   * @param {Uint8Array} publicKey - The uncompressed public key to be compressed.\n   * @return {Uint8Array} - The compressed public key.\n   *\n   * @see Secp256k1.inflatePublicKey\n   */\n  static compressPublicKey(publicKey) {\n    const prefix = publicKey.at(0);\n    if (prefix === _Secp256k1.UNCOMPRESS_PREFIX) {\n      const x = publicKey.slice(1, 33);\n      const y = publicKey.slice(33, 65);\n      const isYOdd = y[y.length - 1] & 1;\n      return nc_utils2.concatBytes(\n        Uint8Array.of(_Secp256k1.COMPRESSED_PREFIX + isYOdd),\n        x\n      );\n    } else {\n      return publicKey;\n    }\n  }\n  /**\n   * Derives the public key from a given private key.\n   *\n   * @param {Uint8Array} privateKey - The private key in Uint8Array format. Must be a valid 32-byte secp256k1 private key.\n   * @param {boolean} [isCompressed=true] - Indicates whether the derived public key should be in compressed format.\n   * @return {Uint8Array} The derived public key in Uint8Array format.\n   * @throws {InvalidSecp256k1PrivateKey} Throws an error if the provided private key is not valid.\n   *\n   * @remarks Security auditable method, depends on\n   * * [nc_secp256k1.getPublicKey](https://github.com/paulmillr/noble-secp256k1).\n   */\n  static derivePublicKey(privateKey, isCompressed = true) {\n    if (_Secp256k1.isValidPrivateKey(privateKey)) {\n      return nc_secp256k1.getPublicKey(privateKey, isCompressed);\n    }\n    throw new InvalidSecp256k1PrivateKey(\n      \"Secp256k1.derivePublicKey\",\n      \"Invalid private key given as input. Ensure it is a valid 32-byte secp256k1 private key.\",\n      void 0\n    );\n  }\n  /**\n   * Generates a new random private key.\n   * If an error occurs during generation using\n   * [nc_secp256k1](https://github.com/paulmillr/noble-secp256k1),\n   * an AES-GCM key is generated as a fallback in runtimes not supported\n   * by `nc_secp256k1`, if those support {@link {@link global.crypto}.\n   *\n   * @return {Promise<Uint8Array>} The generated private key as a Uint8Array.\n   *\n   * @remarks Security auditable method, depends on\n   * * {@link global.crypto.subtle.exportKey};\n   * * {@link global.crypto.subtle.generateKey};\n   * * [nc_secp256k1.utils.randomPrivateKey](https://github.com/paulmillr/noble-secp256k1).\n   */\n  static async generatePrivateKey() {\n    try {\n      return nc_secp256k1.utils.randomPrivateKey();\n    } catch (e) {\n      const cryptoKey = await global.crypto.subtle.generateKey(\n        {\n          name: \"AES-GCM\",\n          length: 256\n        },\n        true,\n        [\"encrypt\", \"decrypt\"]\n      );\n      const rawKey = await global.crypto.subtle.exportKey(\n        \"raw\",\n        cryptoKey\n      );\n      return new Uint8Array(rawKey);\n    }\n  }\n  /**\n   * Inflate a compressed public key to its uncompressed form.\n   *\n   * @param {Uint8Array} publicKey - The compressed public key to be inflated.\n   * @return {Uint8Array} - The uncompressed public key.\n   *\n   * @remarks Security auditable method, depends on\n   * * [nc_secp256k1.ProjectivePoint.fromAffine](https://github.com/paulmillr/noble-secp256k1);\n   * * [nc_secp256k1.ProjectivePoint.fromHex](https://github.com/paulmillr/noble-secp256k1);\n   * * [nc_secp256k1.ProjectivePoint.toAffine](https://github.com/paulmillr/noble-secp256k1).\n   *\n   * @see Secp256K1.compressPublicKey\n   */\n  static inflatePublicKey(publicKey) {\n    const prefix = publicKey.at(0);\n    if (prefix !== _Secp256k1.UNCOMPRESS_PREFIX) {\n      const x = publicKey.slice(0, 33);\n      const p = nc_secp256k1.ProjectivePoint.fromAffine(\n        nc_secp256k1.ProjectivePoint.fromHex(\n          HexUInt.of(x).digits\n        ).toAffine()\n      );\n      return p.toRawBytes(false);\n    } else {\n      return publicKey;\n    }\n  }\n  /**\n   * Checks whether the provided hash is a valid message hash.\n   *\n   * @param {Uint8Array} hash - The hash to be validated.\n   * @return {boolean} `true` if the hash is 32 bytes long, otherwise `false`.\n   */\n  static isValidMessageHash(hash2) {\n    return hash2.length === _Secp256k1.VALID_HASH_LENGTH;\n  }\n  /**\n   * Checks if the provided private key is valid.\n   *\n   * @param {Uint8Array} privateKey - The private key to validate.\n   * @return {boolean} `true` if the private key is valid, `false` otherwise.\n   *\n   * @remarks Security auditable method, depends on\n   * * [nc_secp256k1.utils.isValidPrivateKey](https://github.com/paulmillr/noble-secp256k1).\n   */\n  static isValidPrivateKey(privateKey) {\n    return nc_secp256k1.utils.isValidPrivateKey(privateKey);\n  }\n  /**\n   * Generates a random sequence of bytes.\n   * If an error occurs during generation using\n   * [nc_secp256k1](https://github.com/paulmillr/noble-secp256k1),\n   * {@link {@link global.crypto} is used as fall back togenerate\n   * the random sequence.\n   *\n   * @param {number} [bytesLength=32] - Optional. The number of random bytes to generate.\n   * @return {Uint8Array} - A Uint8Array containing the random bytes.\n   *\n   * @remarks Security auditable method, depends on\n   *  * {@link global.crypto.getRandomValues};\n   * * [nh_randomBytes](https://github.com/paulmillr/noble-hashes).\n   */\n  static randomBytes(bytesLength) {\n    try {\n      return nh_randomBytes(bytesLength);\n    } catch (e) {\n      return global.crypto.getRandomValues(\n        new Uint8Array(bytesLength ?? 32)\n      );\n    }\n  }\n  /**\n   * Recovers the public key associated with the message hash from the given signature.\n   *\n   * @param {Uint8Array} messageHash - The 32-byte message hash to be verified.\n   * @param {Uint8Array} sig - The 65-byte signature used for recovery, consisting of the compact signature and recovery byte.\n   * @return {Uint8Array} The recovered public key in its raw bytes form.\n   * @throws {InvalidSecp256k1MessageHash} If the provided message hash is invalid.\n   * @throws {InvalidSecp256k1Signature} If the provided signature is not 65 bytes or contains an invalid recovery value.\n   *\n   * @remarks Security auditable method, depends on\n   * * [nc_secp256k1.Signature](https://github.com/paulmillr/noble-secp256k1).\n   *\n   * @see Secp256k1.isValidMessageHash\n   */\n  static recover(messageHash, sig) {\n    if (!_Secp256k1.isValidMessageHash(messageHash)) {\n      throw new InvalidSecp256k1MessageHash(\n        \"Secp256k1.recover\",\n        \"Invalid message hash given as input. Ensure it is a valid 32-byte message hash.\",\n        { messageHash }\n      );\n    }\n    if (sig.length !== _Secp256k1.SIGNATURE_LENGTH)\n      throw new InvalidSecp256k1Signature(\n        \"Secp256k1.recover\",\n        \"Invalid signature given as input. Length must be exactly 65 bytes.\",\n        { signature: sig }\n      );\n    const recovery = sig[64];\n    if (recovery !== 0 && recovery !== 1)\n      throw new InvalidSecp256k1Signature(\n        \"Secp256k1.recover\",\n        \"Invalid signature recovery value. Signature bytes at position 64 must be 0 or 1.\",\n        { signature: sig, recovery }\n      );\n    return nc_secp256k1.Signature.fromCompact(sig.slice(0, 64)).addRecoveryBit(recovery).recoverPublicKey(messageHash).toRawBytes(false);\n  }\n  /**\n   * Signs a given message hash using the provided private key.\n   *\n   * @param messageHash - A 32-byte message hash that needs to be signed.\n   * @param privateKey - A 32-byte private key used for signing the message hash.\n   * @return The signature of the message hash consisting of the r, s, and recovery values.\n   * @throws InvalidSecp256k1MessageHash if the message hash is not a valid 32-byte hash.\n   * @throws InvalidSecp256k1PrivateKey if the private key is not a valid 32-byte private key.\n   *\n   * @remarks Security auditable method, depends on\n   * * [nc_secp256k1.sign](https://github.com/paulmillr/noble-secp256k1).\n   *\n   * @see Secp256k1.isValidMessageHash\n   * @see Secp256k1.isValidPrivateKey\n   */\n  static sign(messageHash, privateKey) {\n    if (!_Secp256k1.isValidMessageHash(messageHash)) {\n      throw new InvalidSecp256k1MessageHash(\n        \"Secp256k1.sign\",\n        \"Invalid message hash given as input. Ensure it is a valid 32-byte message hash.\",\n        { messageHash }\n      );\n    }\n    if (!_Secp256k1.isValidPrivateKey(privateKey)) {\n      throw new InvalidSecp256k1PrivateKey(\n        \"Secp256k1.sign\",\n        \"Invalid private key given as input. Ensure it is a valid 32-byte secp256k1 private key.\",\n        void 0\n      );\n    }\n    const sig = nc_secp256k1.sign(messageHash, privateKey);\n    return nc_utils2.concatBytes(\n      nc_utils2.numberToBytesBE(sig.r, 32),\n      nc_utils2.numberToBytesBE(sig.s, 32),\n      nc_utils2.numberToVarBytesBE(sig.recovery)\n    );\n  }\n};\n\n// src/hdkey/HDKey.ts\nimport {\n  InvalidHDKey,\n  InvalidHDKeyMnemonic,\n  InvalidSecp256k1PrivateKey as InvalidSecp256k1PrivateKey2\n} from \"@vechain/sdk-errors\";\nvar HDKey2 = class extends s_bip32.HDKey {\n  /**\n   * Prefix for extended private key\n   */\n  static EXTENDED_PRIVATE_KEY_PREFIX = HexUInt.of(\n    \"0488ade4000000000000000000\"\n  ).bytes;\n  /**\n   * Prefix for extended public key\n   */\n  static EXTENDED_PUBLIC_KEY_PREFIX = HexUInt.of(\n    \"0488b21e000000000000000000\"\n  ).bytes;\n  /**\n   * Default VET derivation path.\n   *\n   * See\n   * [SLIP-0044 : Registered coin types for BIP-0044](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)\n   * for more info.\n   */\n  static VET_DERIVATION_PATH = \"m/44'/818'/0'/0\";\n  /**\n   * Creates a\n   * [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)\n   * from\n   * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)\n   * and the given derivation path.\n   *\n   * @param {string[]} words - An array of words representing the mnemonic.\n   * @param {string} path - The derivation path to derive the child node.\n   * Default value is {@link VET_DERIVATION_PATH}.\n   *\n   * @return The derived child hierarchical deterministic key.\n   *\n   * @throws {InvalidHDKey} If `path` is not valid to derive a node wallet.\n   * @throws {InvalidHDKeyMnemonic} If `words` is an invalid array mnemonic.\n   *\n   * @remarks Security auditable method, depends on\n   * * [s_bip32.HDKey.derive](https://github.com/paulmillr/scure-bip32);\n   * * [s_bip32.HDKey.fromMasterSeed](https://github.com/paulmillr/scure-bip32);\n   * * [s_bip39.mnemonicToSeedSync](https://github.com/paulmillr/scure-bip39).\n   */\n  static fromMnemonic(words, path = this.VET_DERIVATION_PATH) {\n    let master;\n    try {\n      master = s_bip32.HDKey.fromMasterSeed(\n        s_bip39.mnemonicToSeedSync(words.join(\" \").toLowerCase())\n      );\n    } catch (error) {\n      throw new InvalidHDKeyMnemonic(\n        \"HDNode.fromMnemonic\",\n        \"Invalid mnemonic words given as input.\",\n        void 0,\n        error\n      );\n    }\n    try {\n      return master.derive(path);\n    } catch (error) {\n      throw new InvalidHDKey(\n        \"HDNode.fromMnemonic\",\n        \"Invalid derivation path given as input.\",\n        { derivationPath: path },\n        error\n      );\n    }\n  }\n  /**\n   * Creates a\n   * [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)\n   * from a private key and chain code.\n   *\n   * @param {Uint8Array} - privateKey The private key.\n   * @param {Uint8Array} - chainCode The chain code.\n   *\n   * @returns Returns the hierarchical deterministic key from `privateKey` and `chainCode`.\n   *\n   * @throws {InvalidSecp256k1PrivateKey} If the `privateKey` is invalid.\n   *\n   * @remarks **This method wipes `privateKey`** for security reasons.\n   * @remarks Security auditable method, depends on\n   * * [base58.encode](https://github.com/paulmillr/scure-base);\n   * * {@link Sha256};\n   * * [s_bip32.HDKey.fromExtendedKey](https://github.com/paulmillr/scure-bip32).\n   */\n  static fromPrivateKey(privateKey, chainCode) {\n    if (privateKey.length === 32) {\n      const header = nc_utils3.concatBytes(\n        this.EXTENDED_PRIVATE_KEY_PREFIX,\n        chainCode,\n        Uint8Array.of(0),\n        privateKey\n      );\n      privateKey.fill(0);\n      const checksum = Sha256.of(Sha256.of(header).bytes).bytes.subarray(\n        0,\n        4\n      );\n      const expandedPrivateKey = nc_utils3.concatBytes(header, checksum);\n      try {\n        return s_bip32.HDKey.fromExtendedKey(\n          base58.encode(expandedPrivateKey)\n        );\n      } catch (e) {\n        throw new InvalidSecp256k1PrivateKey2(\n          \"HDNode.fromPrivateKey\",\n          \"Invalid private key path given as input.\",\n          void 0\n        );\n      }\n    }\n    privateKey.fill(0);\n    throw new InvalidSecp256k1PrivateKey2(\n      \"HDNode.fromPrivateKey()\",\n      \"Invalid private key path given as input. Length must be exactly 32 bytes.\",\n      void 0\n    );\n  }\n  /**\n   * Creates a\n   * [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)\n   * key from a public key and chain code.\n   *\n   * @param {Uint8Array} publicKey - The public key bytes.\n   * @param {Uint8Array} chainCode - The chain code bytes.\n   *\n   * @returns {HDKey} Returns the hierarchical deterministic key from `public` and `chainCode`.\n   *\n   * @throws {InvalidHDKey} if the `publicKey` is invalid.\n   *\n   * @remarks Security auditable method, depends on\n   * * [base58.encode](https://github.com/paulmillr/scure-base);\n   * * {@link Secp256k1.compressPublicKey};\n   * * {@link Sha256};\n   * * [HDKey.fromExtendedKey](https://github.com/paulmillr/scure-bip32).\n   */\n  static fromPublicKey(publicKey, chainCode) {\n    if (chainCode.length === 32) {\n      const header = nc_utils3.concatBytes(\n        this.EXTENDED_PUBLIC_KEY_PREFIX,\n        chainCode,\n        Secp256k1.compressPublicKey(publicKey)\n      );\n      const checksum = Sha256.of(Sha256.of(header).bytes).bytes.subarray(\n        0,\n        4\n      );\n      const expandedPublicKey = nc_utils3.concatBytes(header, checksum);\n      try {\n        return s_bip32.HDKey.fromExtendedKey(\n          base58.encode(expandedPublicKey)\n        );\n      } catch (error) {\n        throw new InvalidHDKey(\n          \"HDNode.fromPublicKey()\",\n          \"Invalid public key path given as input.\",\n          { publicKey },\n          error\n        );\n      }\n    }\n    throw new InvalidHDKey(\n      \"HDNode.fromPublicKey()\",\n      \"Invalid chain code given as input. Length must be exactly 32 bytes.\",\n      { chainCode }\n    );\n  }\n  /**\n   * Checks if derivation path single component is valid\n   *\n   * @param component - Derivation path single component to check\n   * @param index - Derivation path single component index\n   *\n   * @returns `true`` if derivation path single component is valid, otherwise `false`.\n   *\n   */\n  static isDerivationPathComponentValid(component, index) {\n    return (\n      // m\n      (index === 0 ? component === \"m\" : false) || // \"number\"\n      FixedPointNumber.isNaturalExpression(component) || // \"number'\"\n      FixedPointNumber.isNaturalExpression(component.slice(0, -1)) && component.endsWith(\"'\")\n    );\n  }\n  /**\n   * Checks if derivation path is valid.\n   *\n   * @param derivationPath - Derivation path to check.\n   *\n   * @returns `true` if derivation path is valid, otherwise `false`.\n   */\n  static isDerivationPathValid(derivationPath) {\n    const pathComponents = derivationPath.split(\"/\");\n    for (let i = 0; i < pathComponents.length; i++) {\n      if (!this.isDerivationPathComponentValid(pathComponents[i], i))\n        return false;\n    }\n    return true;\n  }\n};\n\n// src/vcdm/Address.ts\nimport {\n  InvalidDataType as InvalidDataType5,\n  InvalidHDKey as InvalidHDKey2,\n  InvalidSecp256k1PrivateKey as InvalidSecp256k1PrivateKey3\n} from \"@vechain/sdk-errors\";\nvar Address = class _Address extends HexUInt {\n  /**\n   * It checksums a given hexadecimal address.\n   *\n   * @param {HexUInt} huint - The HexUInt object representing the hexadecimal value.\n   *\n   * @returns {string} The checksummed address.\n   */\n  static checksum(huint) {\n    const stringAddress = huint.digits;\n    const hash2 = Keccak256.of(Txt.of(stringAddress).bytes).digits;\n    let checksum = \"\";\n    for (let i = 0; i < stringAddress.length; i++) {\n      checksum += parseInt(hash2[i], 16) > 7 ? stringAddress[i].toUpperCase() : stringAddress[i];\n    }\n    return \"0x\" + checksum;\n  }\n  /**\n   * Validate the given expression to be a valid address.\n   *\n   *  @param {string} exp - Expression to validate\n   *\n   * @returns {boolean} true if the expression is a valid address, false otherwise\n   */\n  static isValid(exp) {\n    return Hex.isValid0x(exp) && exp.length === 42;\n  }\n  /**\n   * Create ab Address instance from the given expression interpreted as an unsigned integer.\n   *\n   * @param exp - The expression to convert. It can be of type bigint, number, string, Uint8Array, or HexUInt.\n   *\n   * @returns {Address} The converted hexadecimal unsigned integer.\n   *\n   * @throws {InvalidDataType} If the expression is not a valid hexadecimal positive integer expression.\n   */\n  static of(exp) {\n    try {\n      const huint = HexUInt.of(exp);\n      if (_Address.isValid(huint.toString())) {\n        const addressChecksummed = _Address.checksum(huint);\n        return new _Address(\n          Hex.POSITIVE,\n          \"0x0\",\n          // When we normalize we return the checksummed address as digits\n          () => addressChecksummed.substring(2)\n        );\n      } else {\n        throw new InvalidDataType5(\"Address.of\", \"not a valid address\", {\n          huint\n        });\n      }\n    } catch (error) {\n      throw new InvalidDataType5(\n        \"Address.of\",\n        \"not a valid hexadecimal positive integer expression\",\n        { exp: `${exp}` },\n        error\n      );\n    }\n  }\n  /**\n   * Create an Address instance from the given private key.\n   *\n   * @param {Uint8Array} privateKey - The private key to convert.\n   *\n   * @param {boolean} [isCompressed=true] - The flag to indicate if the derived public key should be compressed.\n   *\n   * @returns {Address} The converted address.\n   *\n   * @remarks Security auditable method, depends on\n   * * {@link Secp256k1.derivePublicKey}.\n   */\n  static ofPrivateKey(privateKey, isCompressed = true) {\n    try {\n      return _Address.ofPublicKey(\n        Secp256k1.derivePublicKey(privateKey, isCompressed)\n      );\n    } catch (error) {\n      if (error instanceof InvalidSecp256k1PrivateKey3) {\n        throw error;\n      }\n      throw new InvalidDataType5(\n        \"Address.ofPrivateKey\",\n        \"not a valid private key\",\n        { privateKey: `${privateKey}` },\n        error\n      );\n    }\n  }\n  /**\n   * Create an Address instance from the given public key.\n   *\n   * @param {Uint8Array} publicKey - The public key to convert.\n   *\n   * @returns {Address} The converted address.\n   *\n   * @remarks Security auditable method, depends on\n   * * {@link Secp256k1.inflatePublicKey}.\n   */\n  static ofPublicKey(publicKey) {\n    try {\n      const publicKeyInflated = Secp256k1.inflatePublicKey(publicKey);\n      const publicKeyHash = Keccak256.of(\n        publicKeyInflated.slice(1)\n      ).bytes;\n      return _Address.of(publicKeyHash.slice(12));\n    } catch (error) {\n      throw new InvalidDataType5(\n        \"Address.ofPublicKey\",\n        \"not a valid public key\",\n        { publicKey: `${publicKey}` },\n        error\n      );\n    }\n  }\n  /**\n   * Derives the address from a given list of words of\n   * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)\n   * and a [BIP44 Derivation Path](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)\n   * as in the examples.\n   *\n   * Secure audit function.\n   * - {@link bip32.HDKey}(https://github.com/paulmillr/scure-bip32)\n   * - {@link HDKey}\n   *\n   * @example `m/0` (default)\n   * @example `m/0/2`\n   * @example `m/0/2/4/6`\n   *\n   * @param {string[]} mnemonic - Mnemonic used to generate the HD node.\n   * @param {string} [path='m/0'] - The derivation path from the current node.\n   * @return {Address} - The derived address.\n   * @throws {InvalidHDKey}\n   *\n   */\n  static ofMnemonic(mnemonic2, path = \"m/0\") {\n    const root = HDKey2.fromMnemonic(mnemonic2);\n    try {\n      return _Address.ofPublicKey(\n        root.derive(path).publicKey\n      );\n    } catch (error) {\n      throw new InvalidHDKey2(\n        \"mnemonic.deriveAddress()\",\n        \"Invalid derivation path given as input.\",\n        { derivationPath: path },\n        error\n      );\n    }\n  }\n};\nvar addressUtils = {\n  fromPrivateKey: (privateKey) => Address.ofPrivateKey(privateKey).toString(),\n  fromPublicKey: (publicKey) => Address.ofPublicKey(publicKey).toString(),\n  isAddress: (addressToVerify) => Address.isValid(addressToVerify),\n  toERC55Checksum: (address) => Address.checksum(HexUInt.of(address)).toString()\n};\n\n// src/vcdm/BloomFilter.ts\nimport * as nc_utils4 from \"@noble/curves/abstract/utils\";\n\n// src/vcdm/hash/Blake2b256.ts\nimport { blake2b as nh_blake2b } from \"@noble/hashes/blake2b\";\nimport { InvalidOperation as InvalidOperation8 } from \"@vechain/sdk-errors\";\nvar Blake2b256 = class _Blake2b256 extends HexUInt {\n  /**\n   * Generates the [BLAKE](https://en.wikipedia.org/wiki/BLAKE_(hash_function)) [BLAKE2B 256](https://www.blake2.net/) hash of the given input.\n   *\n   * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.\n   *\n   * @returns {Sha256} - The [BLAKE2B 256](https://www.blake2.net/) hash of the input value.\n   *\n   * @throws {InvalidOperation} - If a hash error occurs.\n   *\n   * @remarks Security auditable method, depends on\n   * * [`nh_blake2b.create(...).update(...).digest(...)`](https://github.com/paulmillr/noble-hashes#sha3-fips-shake-keccak).\n   */\n  static of(exp) {\n    try {\n      const hash2 = nh_blake2b.create({ dkLen: 32 }).update(HexUInt.of(exp).bytes).digest();\n      return new _Blake2b256(Hex.POSITIVE, HexUInt.of(hash2).digits);\n    } catch (e) {\n      throw new InvalidOperation8(\"Blake2b256.of\", \"hash error\", {\n        exp: `${exp}`,\n        // Needed to serialize bigint values.\n        e\n      });\n    }\n  }\n};\nfunction blake2b256(data, returnType = \"buffer\") {\n  return returnType === \"buffer\" ? Blake2b256.of(Txt.of(data).bytes).bytes : Blake2b256.of(Txt.of(data).bytes).toString();\n}\n\n// src/vcdm/BloomFilter.ts\nimport { InvalidDataType as InvalidDataType6, InvalidOperation as InvalidOperation9 } from \"@vechain/sdk-errors\";\nvar BloomFilter = class _BloomFilter {\n  /**\n   * Return the Bloom filter structure: an array of `m` bits per key encoding if a key is not part of the structure.\n   *\n   * @typedef {Uint8Array} bytes\n   */\n  bytes;\n  /**\n   * Return the number of hash functions used to compute this Bloom filter.\n   *\n   * @type {number}\n   */\n  k;\n  /**\n   * Creates a new instance of this class.\n   *\n   * @param {Uint8Array} bytes - The Bloom filter structure of `m` bits per key encoding if the key\n   *                             likely belongs to the structure or surely doesn't.\n   * @param {number} k - The number of hash functions used to compute this Bloom filter.\n   *\n   */\n  constructor(bytes, k) {\n    this.bytes = bytes;\n    this.k = k;\n  }\n  /**\n   * Return the Bloom filter data structure represented as a {@link bigint} value.\n   *\n   * @returns {bigint} - The Bloom filter data structure represented as a {@link bigint} value.\n   */\n  get bi() {\n    return nc_utils4.bytesToNumberBE(this.bytes);\n  }\n  /**\n   * Return the Bloom filter data structure represented as a {@link number} value.\n   *\n   * @returns {bigint} - The Bloom filter data structure represented as a {@link number} value.\n   *\n   * @throws InvalidDataType if the data structure of the bloom filter can't be represented as a number\n   * because underflow or overflow number safe integer range according\n   * [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).\n   *\n   * @remarks Preferably use {@link bi} because the Bloom filter data structure can always be represented as a {@link bigint} value.\n   */\n  get n() {\n    const bi = this.bi;\n    if (Number.MIN_SAFE_INTEGER <= bi && bi <= Number.MAX_SAFE_INTEGER) {\n      return Number(bi);\n    }\n    throw new InvalidDataType6(\n      \"BloomFilter.n\",\n      \"not in the safe number range\",\n      {\n        bytes: this.bytes,\n        k: this.k\n      }\n    );\n  }\n  /**\n   * Compare the current BloomFilter instance with another BloomFilter instance according their\n   * * {@link bytes} data structure first,\n   * * {@link k} if the data structures are equal.\n   *\n   * @param {BloomFilter} that - The BloomFilter instance to compare with.\n   *\n   * @return {number} - Returns a negative number if the current instance is less than the provided instance,\n   *                   returns zero if they are equal, and returns a positive number if the current instance is greater than the provided instance.\n   */\n  compareTo(that) {\n    return this.bi < that.bi ? -1 : this.bi === that.bi ? this.k - that.k : 1;\n  }\n  /**\n   * Checks if the current BloomFilter instance is equal to another BloomFilter instance.\n   *\n   * @param {BloomFilter} that - The other BloomFilter instance to compare with.\n   *\n   * @return {boolean} - Returns true if the current BloomFilter instance is equal to the other BloomFilter instance, otherwise returns false.\n   */\n  isEqual(that) {\n    return this.bi === that.bi && this.k === that.k;\n  }\n  /**\n   * Checks if the specified key may be contained within this Bloom filter or surely isn't.\n   *\n   * @param {Hex|Uint8Array} key - The key to check. It can be either a Hex object or a Uint8Array.\n   *\n   * @return {boolean} Returns true if this Bloom filter may contain the key, otherwise returns false.\n   *\n   * @remarks False positive matches are possible, but false negatives are not.\n   * @remarks Security auditable method, depends on\n   * * {@link hash}.\n   */\n  contains(key) {\n    return distribute(\n      hash(key instanceof Hex ? key.bytes : key),\n      this.k,\n      this.bytes.byteLength * 8,\n      (index, bit) => {\n        return (this.bytes[index] & bit) === bit;\n      }\n    );\n  }\n  /**\n   * Calculates the optimal number of bits per key (`m` in math literature) based\n   * on the number of hash functions (`k` in math literature) used to generate the Bloom Filter.\n   *\n   * Mathematically, `m` is approximated as `(k / ln(2))` which is simplified\n   * to the higher integer close to `(m / 0.69)` for computational efficiency.\n   * It also ensures that `k` is within a practical range [1, 30], hence the function\n   * - returns `2` for `k = 1`,\n   * - returns `44` for `k >= 30`.\n   *\n   * @param {number} k - The number of keys.\n   *\n   * @return {number} - The number of bits per key.\n   */\n  static computeBestBitsPerKey(k) {\n    if (k <= 1) return 2;\n    return k >= 30 ? 44 : Math.ceil(k / 0.69);\n  }\n  /**\n   * Calculates the optimal number of hash functions (`k` in math literature)\n   * based on bits per key (`m` in math literature).\n   *\n   * Mathematically, `k` is approximated as `(m * ln(2))` which is simplified\n   * to the lower integer close to `(m * 0.69)` for computational efficiency.\n   * It also ensures that `k` stays within a practical range [1, 30].\n   *\n   * @param m - The number of bits per key.\n   *\n   * @returns The calculated optimal `k` value.\n   */\n  static computeBestHashFunctionsQuantity(m) {\n    const k = Math.floor(m * 0.69);\n    if (k < 1) return 1;\n    return k > 30 ? 30 : k;\n  }\n  /**\n   * Checks if the current BloomFilter instance is possible to join with another BloomFilter instance.\n   *\n   * @param {BloomFilter} other - The BloomFilter instance to check if it is possible to join with the current instance.\n   *\n   * @return {boolean} - Returns true if the BloomFilter instances have the same 'k' value and 'bytes' length, false otherwise.\n   */\n  isJoinable(other) {\n    return this.k === other.k && this.bytes.length === other.bytes.length;\n  }\n  /**\n   * Joins the current BloomFilter with another BloomFilter by performing a bitwise OR operation on the\n   * data structures of the filters.\n   * Both filters must have been generated with the same number of hash functions, and they must have the same length.\n   *\n   * @param other - The BloomFilter to join with.\n   *\n   * @returns A new BloomFilter that represents the result of the join operation.\n   *          They keys made this and `other` filter may belong to the returned filter.\n   *          Any key not part of the joined filter surely doesn't belong to the returned filter.\n   *\n   * @throws {InvalidOperation} If the k values of the BloomFilters are different.\n   * @throws {InvalidOperation} If the length of the byte arrays are different.\n   */\n  join(other) {\n    if (this.k === other.k) {\n      if (this.bytes.length === other.bytes.length) {\n        return new _BloomFilter(\n          new Uint8Array(\n            this.bytes.map(\n              (byte, index) => byte | other.bytes[index]\n            )\n          ),\n          this.k\n        );\n      }\n      throw new InvalidOperation9(\n        \"BloomFilter.join\",\n        \"different length values\",\n        { this: this, other }\n      );\n    }\n    throw new InvalidOperation9(\"BloomFilter.join\", \"different k values\", {\n      this: this,\n      other\n    });\n  }\n  /**\n   * Creates a new instance of BloomFilterBuilder and adds the specified keys to it.\n   * * Call {@link BloomFilterBuilder.add} to add more keys.\n   * * Call {@link BloomFilterBuilder.build} to create a new Bloom filter once\n   *\n   * @param {...(Hex[] | Uint8Array[])} keys - The keys to be added to the BloomFilterBuilder.\n   *\n   * @returns {BloomFilterBuilder} - A new instance of BloomFilterBuilder with the specified keys added.\n   *\n   * @remarks Security auditable method, depends on\n   * * {@link BloomFilterBuilder.add}.\n   */\n  static of(...keys) {\n    const builder = new BloomFilterBuilder();\n    builder.add(...keys);\n    return builder;\n  }\n};\nvar BloomFilterBuilder = class _BloomFilterBuilder {\n  /**\n   * The default value number of hash functions used to create {@link BloomFilter} instances.\n   */\n  static DEFAULT_K = 5;\n  /**\n   * Map each element of the keys as likely part of the data structure of the Bloom filter to build.\n   * Each key is mapped in `m` bits using `k` hash functions.\n   *\n   * @see {hash}\n   */\n  hashMap = /* @__PURE__ */ new Map();\n  /**\n   * Adds one or more keys to the Bloom filter to create.\n   *\n   * @param {Hex[] | Uint8Array[]} keys - The keys to be added to Bloom filter to create.\n   *\n   * @return {this} - Returns this {@link BloomFilterBuilder} instance, the {@link this.hashMap} is updated to\n   * map the keys presence in the filter data structure.\n   *\n   * @remarks Security auditable method, depends on\n   * * {@link hash}.\n   */\n  add(...keys) {\n    for (const key of keys) {\n      this.hashMap.set(hash(key instanceof Hex ? key.bytes : key), true);\n    }\n    return this;\n  }\n  /**\n   * Builds a Bloom filter with the specified parameters and returns it.\n   *\n   * @param k - The number of hash functions to use in the Bloom filter.  to BloomFilterBuilder.DEFAULT_K.\n   * @param m - The number of bits per key in the Bloom filter. Defaults to the value computed by BloomFilter.computeBestBitsPerKey(k).\n   *\n   * @return The built Bloom filter.\n   */\n  build(k = _BloomFilterBuilder.DEFAULT_K, m = BloomFilter.computeBestBitsPerKey(k)) {\n    let nBytes = Math.floor((this.hashMap.size * m + 7) / 8);\n    nBytes = nBytes < 8 ? 8 : nBytes;\n    const bits = new Uint8Array(nBytes);\n    const nBits = nBytes * 8;\n    for (const hash2 of this.hashMap.keys()) {\n      distribute(hash2, k, nBits, (index, bit) => {\n        bits[index] |= bit;\n        return true;\n      });\n    }\n    return new BloomFilter(bits, k);\n  }\n};\nvar UINT32_LIMIT = 2 ** 32;\nfunction addAndWrapAsUInt32(a, b) {\n  return (a + b) % UINT32_LIMIT;\n}\nfunction distribute(hash2, k, m, collision) {\n  const delta = (hash2 >>> 17 | hash2 << 15) >>> 0;\n  for (let i = 0; i < k; i++) {\n    const bitPos = hash2 % m;\n    if (!collision(Math.floor(bitPos / 8), 1 << bitPos % 8)) {\n      return false;\n    }\n    hash2 = addAndWrapAsUInt32(hash2, delta);\n  }\n  return true;\n}\nfunction hash(key) {\n  return Number(\n    nc_utils4.bytesToNumberBE(Blake2b256.of(key).bytes.slice(0, 4))\n  );\n}\n\n// src/vcdm/currency/Coin.ts\nimport { InvalidDataType as InvalidDataType7 } from \"@vechain/sdk-errors\";\nvar Coin = class {\n  /**\n   * Represent coin {@link code} denomination.\n   */\n  _code;\n  /**\n   * Represent the coin {@link value}.\n   *\n   * @type {FixedPointNumber}\n   */\n  _value;\n  /**\n   * Creates an instance of the class with the specified code and value.\n   *\n   * @param {Txt} code - The code associated with this instance.\n   * @param {FixedPointNumber} value - The value associated with this instance.\n   */\n  constructor(code, value) {\n    this._code = code;\n    this._value = value;\n  }\n  /**\n   * Return the code as a Txt object.\n   *\n   * @return {Txt} The code object\n   *\n   * @remarks Since currency codes likely use Unicode composite symbols,\n   * {@link Txt} type enforce the representation of the code is normalized.\n   */\n  get code() {\n    return this._code;\n  }\n  /**\n   * Return the current value as an FixedPointNumber (Fixed-Point Number).\n   *\n   * @return {FixedPointNumber} The current value in Fixed-Point Number format.\n   */\n  get value() {\n    return this._value;\n  }\n  /**\n   * Returns the integer part of the FixedPointNumber {@link value}.\n   *\n   * @return {bigint} the integer part of this FixedPointNumber {@link value}.\n   *\n   * @throws {InvalidOperation} If the {@link value} is not finite.\n   *\n   * @remarks Do not use for financial math: apply {@link FixedPointNumber} methods instead.\n   */\n  get bi() {\n    return this._value.bi;\n  }\n  /**\n   * Returns the array of bytes representing the *Normalization Form Canonical Composition*\n   * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence)\n   * of the textual expression '{@link value} {@link code}'.\n   */\n  get bytes() {\n    return Txt.of(this.toString()).bytes;\n  }\n  /**\n   * Return this {@linl value} approximated as {@link number}.\n   *\n   * @remarks Do not use for financial math: apply {@link FixedPointNumber} methods instead.\n   */\n  get n() {\n    return this._value.n;\n  }\n  /**\n   * Compares this Currency object with another Currency object for order.\n   *\n   * @param {Currency} that - The Currency object to be compared.\n   * @return {number} A negative integer, zero, or a positive integer as this Currency\n   *     is less than, equal to, or greater than the specified Currency.\n   * @throws {InvalidDataType} If the currency codes do not match.\n   */\n  compareTo(that) {\n    if (this.code.isEqual(that.code)) {\n      return this.value.compareTo(that.value);\n    }\n    throw new InvalidDataType7(\"Coin.compareTo\", \"not VET currency\", {\n      // eslint-disable-next-line @typescript-eslint/no-base-to-string\n      that: `${that}`\n      // Needed to serialize bigint value.\n    });\n  }\n  /**\n   * Determines if this Currency object is equal to another Currency object.\n   *\n   * @param {Currency} that - The Currency object to compare with the current instance.\n   * @return {boolean} - `true` if the objects are considered equal, otherwise `false`.\n   */\n  isEqual(that) {\n    try {\n      return this.compareTo(that) === 0;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n   * Returns the textual representation of this currency as\n   * '{@link value} {@link code}'.\n   *\n   * @return A string that contains the value and code properties of the object.\n   */\n  toString() {\n    return `${this.value.toString()} ${this._code}`;\n  }\n};\n\n// src/vcdm/currency/Units.ts\nvar Units = /* @__PURE__ */ ((Units2) => {\n  Units2[Units2[\"wei\"] = 0] = \"wei\";\n  Units2[Units2[\"kwei\"] = 3] = \"kwei\";\n  Units2[Units2[\"mwei\"] = 6] = \"mwei\";\n  Units2[Units2[\"gwei\"] = 9] = \"gwei\";\n  Units2[Units2[\"szabo\"] = 12] = \"szabo\";\n  Units2[Units2[\"finney\"] = 15] = \"finney\";\n  Units2[Units2[\"ether\"] = 18] = \"ether\";\n  return Units2;\n})(Units || {});\n((Units2) => {\n  function formatEther(wei) {\n    return formatUnits(wei, 18 /* ether */);\n  }\n  Units2.formatEther = formatEther;\n  function formatUnits(wei, unit = 18 /* ether */) {\n    const fpn = wei.div(FixedPointNumber.of(10n ** BigInt(unit)));\n    return fpn.isInteger() ? `${fpn}.0` : `${fpn}`;\n  }\n  Units2.formatUnits = formatUnits;\n  function parseEther(ether) {\n    return parseUnits(ether, 18 /* ether */);\n  }\n  Units2.parseEther = parseEther;\n  function parseUnits(exp, unit = 18 /* ether */) {\n    return FixedPointNumber.of(exp).times(\n      FixedPointNumber.of(10n ** BigInt(unit))\n    );\n  }\n  Units2.parseUnits = parseUnits;\n})(Units || (Units = {}));\n\n// src/vcdm/currency/VET.ts\nvar VET = class _VET extends Coin {\n  /**\n   * The code for VET is the sequence of Unicode\n   * - U+1D64D - mathematical double strike capital letter 'V',\n   * - U+039F - Greek capital letter 'Xi',\n   * - U+0054 - Latin capital letter 'T'.\n   */\n  static CODE = Txt.of(\"\\u{1D54D}\\u039ET\");\n  /**\n   * Wei fractional digits to express this value.\n   */\n  static WEI_FD = 18n;\n  /**\n   * Represents this monetary amount in terms of {@link Units.wei}.\n   *\n   * @type {bigint}\n   */\n  wei = this.value.dp(_VET.WEI_FD).sv;\n  /**\n   * Create a new instance with the given `value`.\n   *\n   * @param {FixedPointNumber} value The value to be used for initializing the instance.\n   */\n  constructor(value) {\n    super(_VET.CODE, value);\n  }\n  /**\n   * Return a new VET instance with the specified value and unit.\n   *\n   * @param {bigint | number | string | FixedPointNumber} value - The numerical value for the VET instance.\n   * @param {Units} unit - The unit for the value.\n   *                     Defaults to {@link Units.ether} if not provided.\n   * @return {VET} A new VET instance with the provided value and unit.\n   *\n   * @throws {InvalidDataType} If `value` is not a numeric expression.\n   */\n  static of(value, unit = 18 /* ether */) {\n    const fpn = value instanceof FixedPointNumber ? value : FixedPointNumber.of(value);\n    return new _VET(\n      fpn.div(FixedPointNumber.of(10n ** (_VET.WEI_FD - BigInt(unit))))\n    );\n  }\n};\n\n// src/vcdm/currency/VTHO.ts\nvar VTHO = class _VTHO extends Coin {\n  /**\n   * The code for VET is the sequence of Unicode\n   * - U+1D64D - mathematical double strike capital letter 'V',\n   * - U+0054 - Latin capital letter 'T',\n   * - U+0048 - Latin capital letter 'H',\n   * - U+004F - Latin capital letter 'O'.\n   */\n  static CODE = Txt.of(\"\\u{1D54D}THO\");\n  /**\n   * Wei fractional digits to express this value.\n   */\n  static WEI_FD = 18n;\n  /**\n   * Represents this monetary amount in terms of {@link Units.wei}.\n   *\n   * @type {bigint}\n   */\n  wei = this.value.dp(_VTHO.WEI_FD).sv;\n  /**\n   * Create a new instance with the given `value`.\n   *\n   * @param {FixedPointNumber} value The value to be used for initializing the instance.\n   */\n  constructor(value) {\n    super(_VTHO.CODE, value);\n  }\n  /**\n   * Return a new VTHO instance with the specified value and unit.\n   *\n   * @param {bigint | number | string | FixedPointNumber} value - The numerical value for the VTHO instance.\n   * @param {Units} unit - The unit for the value.\n   *                       Defaults to {@link Units.ether} if not provided.\n   * @return {VTHO} A new VTHO instance with the provided value and unit.\n   *\n   * @throws {InvalidDataType} If `value` is not a numeric expression.\n   */\n  static of(value, unit = 18 /* ether */) {\n    const fpn = value instanceof FixedPointNumber ? value : FixedPointNumber.of(value);\n    return new _VTHO(\n      fpn.div(FixedPointNumber.of(10n ** (_VTHO.WEI_FD - BigInt(unit))))\n    );\n  }\n};\n\n// src/vcdm/encoding/rlp/RLP.ts\nimport { RLP as EthereumjsRLP } from \"@ethereumjs/rlp\";\nimport { bytesToNumberBE as bytesToNumberBE2 } from \"@noble/ciphers/utils\";\nimport { InvalidDataType as InvalidDataType8, InvalidRLP } from \"@vechain/sdk-errors\";\n\n// src/vcdm/encoding/rlp/kind/ScalarKind.ts\nvar ScalarKind = class {\n};\n\n// src/vcdm/encoding/rlp/RLP.ts\nvar RLP = class _RLP {\n  encoded;\n  decoded;\n  constructor(data) {\n    this.decoded = data instanceof Uint8Array ? EthereumjsRLP.decode(data) : data;\n    this.encoded = data instanceof Uint8Array ? data : EthereumjsRLP.encode(data);\n  }\n  /**\n   * Returns the bigint representation of the encoded data in the RLP instance.\n   * @returns {bigint} The bigint representation of the encoded data.\n   */\n  get bi() {\n    return bytesToNumberBE2(this.bytes);\n  }\n  /**\n   * Returns the encoded data as a Uint8Array.\n   * @returns {Uint8Array} The encoded data.\n   */\n  get bytes() {\n    return this.encoded;\n  }\n  /**\n   * Returns the number representation of the encoded data in the RLP instance.\n   * @returns {number} The number representation of the encoded data.\n   */\n  get n() {\n    const bi = this.bi;\n    if (bi <= Number.MAX_SAFE_INTEGER) {\n      return Number(bi);\n    }\n    throw new InvalidDataType8(\"RLP.n\", \"not in the safe number range\", {\n      bytes: this.bytes\n    });\n  }\n  /**\n   * Compares the current RLP instance with another RLP instance.\n   * @param {RLP} that The RLP instance to compare.\n   * @returns 0 if the RLP instances are equal, -1/1 if they are not.\n   */\n  compareTo(that) {\n    if (this.encoded.length !== that.encoded.length) {\n      return -1;\n    }\n    for (let i = 0; i < this.encoded.length; i++) {\n      if (this.encoded[i] !== that.encoded[i]) {\n        return 1;\n      }\n    }\n    return 0;\n  }\n  /**\n   * Relies on compareTo to check if the RLP instances are equal.\n   * @param {RLP} that The RLP instance to compare.\n   * @returns true if the RLP instances are equal, false otherwise.\n   */\n  isEqual(that) {\n    return this.compareTo(that) === 0;\n  }\n  /**\n   * Creates {@link Hex} instance from the RLP encoded value.\n   * @returns {Hex} The Hex instance.\n   */\n  toHex() {\n    return Hex.of(this.bytes);\n  }\n  /**\n   * Returns an RLP instance from a plain value.\n   * @param data - The plain data\n   * @returns {RLP} The RLP instance.\n   */\n  static of(data) {\n    try {\n      return new _RLP(data);\n    } catch (error) {\n      throw new InvalidRLP(\n        \"RLP.of()\",\n        `Error when creating an RLP instance for data ${data}`,\n        {\n          context: \"This method creates an RLP instance from a plain value.\",\n          data: {\n            data\n          }\n        },\n        error\n      );\n    }\n  }\n  /**\n   * Returns an RLP instancen from an encoded value.\n   * @param {Uint8Array} encodedData - The RLP-encoded data.\n   * @returns The decoded data or null if decoding fails.\n   */\n  static ofEncoded(encodedData) {\n    try {\n      return new _RLP(encodedData);\n    } catch (error) {\n      throw new InvalidRLP(\n        \"RLP.ofEncoded()\",\n        `Error when creating an RLP instance for encoded data.`,\n        {\n          context: \"This method creates an RLP instance from an encoded value.\",\n          data: {\n            encodedData\n          }\n        },\n        error\n      );\n    }\n  }\n  /**\n   * Handles the RLP packing of data.\n   * Recursively processes through object properties or array elements to prepare data for RLP encoding.\n   *\n   * @param obj - The object data to be packed.\n   * @param profile - Profile for encoding structures.\n   * @param context - Encoding context for error tracing.\n   * @returns Packed data as RLPInput.\n   * @throws {InvalidRLP}\n   *\n   */\n  static packData(obj, profile, context) {\n    context = context !== \"\" ? context + \".\" + profile.name : profile.name;\n    const kind = profile.kind;\n    if (kind instanceof ScalarKind) {\n      return kind.data(obj, context).encode();\n    }\n    if (Array.isArray(kind)) {\n      return kind.map(\n        (k) => this.packData(obj[k.name], k, context)\n      );\n    }\n    if (!Array.isArray(obj)) {\n      throw new InvalidRLP(\n        \"RLP.packData()\",\n        `Validation error: Expected an array in ${context}.`,\n        {\n          context,\n          data: {\n            obj,\n            profile\n          }\n        }\n      );\n    }\n    if (\"item\" in kind && Array.isArray(obj)) {\n      const item = kind.item;\n      return obj.map(\n        (part, i) => this.packData(\n          part,\n          { name: \"#\" + i, kind: item },\n          context\n        )\n      );\n    }\n  }\n  /**\n   * Handles the RLP unpacking of data.\n   * Recursively processes through packed properties or elements to prepare data post RLP decoding.\n   *\n   * @param packed - The packed data to be unpacked.\n   * @param profile - Profile for decoding structures.\n   * @param context - Decoding context for error tracing.\n   * @returns Unpacked data as RLPValueType.\n   * @throws {InvalidRLP}\n   *\n   */\n  static unpackData(packed, profile, context) {\n    context = context !== \"\" ? context + \".\" + profile.name : profile.name;\n    const kind = profile.kind;\n    if (kind instanceof ScalarKind) {\n      if (!(packed instanceof Uint8Array)) {\n        throw new InvalidRLP(\n          \"RLP.unpackData()\",\n          `Unpacking error: Expected data type is Uint8Array.`,\n          {\n            context,\n            data: {\n              packed,\n              profile\n            }\n          }\n        );\n      }\n      return kind.buffer(packed, context).decode();\n    }\n    if (Array.isArray(kind) && Array.isArray(packed)) {\n      const parts = packed;\n      if (kind.length !== parts.length) {\n        throw new InvalidRLP(\n          \"RLP.unpackData()\",\n          `Unpacking error: Expected ${kind.length} items, but got ${parts.length}.`,\n          {\n            context,\n            data: {\n              packed,\n              profile\n            }\n          }\n        );\n      }\n      return kind.reduce(\n        (obj, profile2, index) => {\n          obj[profile2.name] = this.unpackData(\n            parts[index],\n            profile2,\n            context\n          );\n          return obj;\n        },\n        {}\n      );\n    }\n    if (!Array.isArray(packed)) {\n      throw new InvalidRLP(\n        \"RLP.unpackData()\",\n        `Validation error: Expected an array in ${context}.`,\n        {\n          context,\n          data: {\n            packed,\n            profile\n          }\n        }\n      );\n    }\n    if (\"item\" in kind && Array.isArray(packed)) {\n      const item = kind.item;\n      return packed.map(\n        (part, index) => this.unpackData(\n          part,\n          { name: \"#\" + index, kind: item },\n          context\n        )\n      );\n    }\n  }\n};\n\n// src/vcdm/encoding/rlp/RLPProfiler.ts\nvar RLPProfiler = class _RLPProfiler extends RLP {\n  /**\n   * Creates a new Profiler instance.\n   * @param profile - Profile for encoding/decoding structures.\n   */\n  constructor(data, profile) {\n    super(data);\n    this.profile = profile;\n  }\n  /**\n   * Creates an RLPProfiler instance from a valid object.\n   * @param {RLPValidObject} validObject Object to be encoded.\n   * @returns {RLPProfiler} RLPProfiler instance.\n   */\n  static ofObject(validObject, profile) {\n    const packedData = this.packData(validObject, profile, \"\");\n    return new _RLPProfiler(packedData, profile);\n  }\n  /**\n   * Decodes an object following the provided profile.\n   * @param encodedData Data to be decoded.\n   * @param profile Profile for encoding/decoding structures.\n   * @returns - Decoded data as RLPValueType.\n   */\n  static ofObjectEncoded(encodedData, profile) {\n    const packedData = RLP.ofEncoded(encodedData).decoded;\n    return new _RLPProfiler(packedData, profile);\n  }\n  /**\n   * Returns the decoded unpacked object.\n   * @returns {RLPValueType} Decoded unpacked object.\n   */\n  get object() {\n    return _RLPProfiler.unpackData(this.decoded, this.profile, \"\");\n  }\n};\n\n// src/vcdm/encoding/rlp/helpers/numerickind.ts\nimport { InvalidRLP as InvalidRLP2 } from \"@vechain/sdk-errors\";\nvar validateNumericKindData = (data, context) => {\n  if (typeof data !== \"number\" && typeof data !== \"string\") {\n    throw new InvalidRLP2(\n      \"validateNumericKindData()\",\n      `Validation error: Input in ${context} must be a string or number.`,\n      {\n        context,\n        data: {\n          data\n        }\n      }\n    );\n  }\n  if (typeof data === \"number\") {\n    _validateNumericKindNumber(data, context);\n  } else if (typeof data === \"string\") {\n    _validateNumericKindString(data, context);\n  }\n  return BigInt(data);\n};\nvar _validateNumericKindNumber = (num, context) => {\n  if (!Number.isSafeInteger(num) || num < 0) {\n    throw new InvalidRLP2(\n      \"_validateNumericKindNumber()\",\n      `Validation error: Number in ${context} must be a safe and non-negative integer.`,\n      {\n        context,\n        data: {\n          num\n        }\n      }\n    );\n  }\n};\nvar _validateNumericKindString = (str, context) => {\n  const isHexUInt = HexUInt.isValid0x(str);\n  const isDecimal = FixedPointNumber.isNaturalExpression(str);\n  if (!isHexUInt && !isDecimal) {\n    throw new InvalidRLP2(\n      \"_validateNumericKindString()\",\n      `Validation error: String in ${context} must represent a non-negative integer in hex or decimal format.`,\n      {\n        context,\n        data: {\n          str\n        }\n      }\n    );\n  }\n  if (isHexUInt && str.length <= 2) {\n    throw new InvalidRLP2(\n      \"_validateNumericKindString()\",\n      `Validation error: Hex string number in ${context} must be of valid length.`,\n      {\n        context,\n        data: {\n          str\n        }\n      }\n    );\n  }\n};\nvar assertValidNumericKindBuffer = (buf, context, maxBytes) => {\n  if (maxBytes !== void 0 && buf.length > maxBytes) {\n    throw new InvalidRLP2(\n      \"assertValidNumericKindBuffer()\",\n      `Validation error: Buffer in ${context} must be less than ${maxBytes} bytes.`,\n      {\n        context,\n        data: {\n          buf,\n          maxBytes\n        }\n      }\n    );\n  }\n  if (buf[0] === 0) {\n    throw new InvalidRLP2(\n      \"assertValidNumericKindBuffer()\",\n      `Validation error: Buffer in ${context} must represent a canonical integer (no leading zeros).`,\n      {\n        context,\n        data: {\n          buf,\n          maxBytes\n        }\n      }\n    );\n  }\n};\nvar encodeBigIntToBuffer = (bi, maxBytes, context) => {\n  if (bi === 0n) return Uint8Array.from([]);\n  const hex = Hex.of(bi).digits;\n  if (maxBytes !== void 0 && hex.length > maxBytes * 2) {\n    throw new InvalidRLP2(\n      \"encodeBigIntToBuffer()\",\n      `Validation error: Encoded number in ${context} must fit within ${maxBytes} bytes.`,\n      {\n        context,\n        data: {\n          hex,\n          maxBytes\n        }\n      }\n    );\n  }\n  return Hex.of(hex).bytes;\n};\nvar decodeBufferToNumberOrHex = (buffer) => {\n  if (buffer.length === 0) return 0;\n  const bi = Hex.of(buffer).bi;\n  const num = Number(bi);\n  return Number.isSafeInteger(num) ? num : \"0x\" + bi.toString(16);\n};\n\n// src/vcdm/encoding/rlp/helpers/hexblobkind.ts\nimport { InvalidRLP as InvalidRLP3 } from \"@vechain/sdk-errors\";\nvar assertValidHexBlobKindData = (data, context) => {\n  if (typeof data !== \"string\") {\n    throw new InvalidRLP3(\n      \"assertValidHexBlobKindData()\",\n      `Validation error: Input must be a string.`,\n      {\n        context,\n        data: {\n          data\n        }\n      }\n    );\n  }\n  if (!Hex.isValid(data)) {\n    throw new InvalidRLP3(\n      \"assertValidHexBlobKindData()\",\n      `Validation error: Input must be a valid hex string with a '0x' prefix.`,\n      {\n        context,\n        data: {\n          data\n        }\n      }\n    );\n  }\n  if (data.length % 2 !== 0) {\n    throw new InvalidRLP3(\n      \"assertValidHexBlobKindData()\",\n      `Validation error: Hex string must have an even length.`,\n      {\n        context,\n        data: {\n          data\n        }\n      }\n    );\n  }\n};\n\n// src/vcdm/encoding/rlp/helpers/fixedhexblobkind.ts\nimport { InvalidRLP as InvalidRLP4 } from \"@vechain/sdk-errors\";\nvar assertFixedHexBlobKindData = (data, context, bytes) => {\n  if (data.length !== bytes * 2 + 2) {\n    throw new InvalidRLP4(\n      \"assertFixedHexBlobKindData()\",\n      `Validation error: Hex string in ${context} must be exactly ${bytes} bytes in length.`,\n      {\n        context,\n        data: {\n          data,\n          bytes\n        }\n      }\n    );\n  }\n};\nvar assertFixedHexBlobKindBuffer = (buffer, context, bytes) => {\n  if (buffer.length !== bytes) {\n    throw new InvalidRLP4(\n      \"assertFixedHexBlobKindData()\",\n      `Validation error: Hex string in ${context} must be exactly ${bytes} bytes in length.`,\n      {\n        context,\n        data: {\n          buffer,\n          bytes\n        }\n      }\n    );\n  }\n};\n\n// src/vcdm/encoding/rlp/helpers/compactfixedhexblobkind.ts\nimport { InvalidRLP as InvalidRLP5 } from \"@vechain/sdk-errors\";\nvar assertCompactFixedHexBlobBuffer = (buffer, context, bytes) => {\n  if (buffer.length > bytes) {\n    throw new InvalidRLP5(\n      \"assertCompactFixedHexBlobBuffer()\",\n      `Validation error: Buffer in ${context} must be at most ${bytes} bytes.`,\n      {\n        context,\n        data: {\n          buffer,\n          bytes\n        }\n      }\n    );\n  }\n  if (buffer.length !== 0 && buffer[0] === 0) {\n    throw new InvalidRLP5(\n      \"assertCompactFixedHexBlobBuffer()\",\n      `Validation error: Buffer in ${context} should not have leading zero bytes.`,\n      {\n        context,\n        data: {\n          buffer,\n          bytes\n        }\n      }\n    );\n  }\n};\nvar encodeCompactFixedHexBlob = (buffer) => {\n  const zeroIndex = buffer.findIndex((byte) => byte !== 0);\n  return zeroIndex !== -1 ? buffer.subarray(zeroIndex) : Uint8Array.from([]);\n};\nvar decodeBufferToHexWithLeadingZeros = (buffer, bytes) => {\n  return Hex.of(buffer).fit(bytes * 2).toString();\n};\n\n// src/vcdm/encoding/rlp/kind/BufferKind.ts\nimport { InvalidRLP as InvalidRLP6 } from \"@vechain/sdk-errors\";\nvar BufferKind = class extends ScalarKind {\n  /**\n   * Encodes the input data into buffer format.\n   *\n   * @param {RLPInput} data The data to encode, expected to be of Uint8Array type.\n   * @param {string} context Descriptive context for error messages\n   * @returns {DataOutput} Object with an encode function.\n   * @throws {InvalidRLP}\n   */\n  data(data, context) {\n    if (!(data instanceof Uint8Array))\n      throw new InvalidRLP6(\n        \"BufferKind.data()\",\n        `Validation error: Expected a Uint8Array type in ${context}.`,\n        {\n          context,\n          data: {\n            data\n          }\n        }\n      );\n    return {\n      encode: () => data\n      // Data is already a Buffer, so return as-is.\n    };\n  }\n  /**\n   * Decodes the input buffer.\n   *\n   * @param {Uint8Array} buffer - The buffer to decode, expected to be of buffer type.\n   * @returns BufferOutput object with a decode function.\n   * @throws {InvalidRLP}\n   */\n  buffer(buffer) {\n    return {\n      decode: () => buffer\n      // Buffer is already in the correct format, so return as-is.\n    };\n  }\n};\n\n// src/vcdm/encoding/rlp/kind/NumericKind.ts\nvar NumericKind = class extends ScalarKind {\n  /**\n   * Constructs a new instance of NumericKind.\n   *\n   * @param maxBytes - Optional parameter that specifies the maximum number of bytes that numeric data can occupy when encoded.\n   */\n  constructor(maxBytes) {\n    super();\n    this.maxBytes = maxBytes;\n  }\n  /**\n   * Encodes the input data into numeric format and ensures it doesn't exceed the maximum bytes, if specified.\n   *\n   * @param data - The data to encode, expected to be numeric.\n   * @param context - Descriptive context for error messages\n   * @returns DataOutput object with an encode function.\n   * @throws Will throw an error if data validation fails or encoding issues occur.\n   */\n  data(data, context) {\n    const dataBI = validateNumericKindData(data, context);\n    return {\n      encode: () => encodeBigIntToBuffer(dataBI, this.maxBytes, context)\n      // Encodes BigInt to Buffer, respecting maxBytes.\n    };\n  }\n  /**\n   * Decodes the input buffer into a number or hexadecimal string, ensuring it meets numeric data constraints.\n   *\n   * @param {Uint8Array} buffer - The buffer to decode, containing numeric data.\n   * @param context - Descriptive context for error messages.\n   * @returns BufferOutput object with a decode function.\n   * @throws Will throw an error if buffer validation fails.\n   */\n  buffer(buffer, context) {\n    assertValidNumericKindBuffer(buffer, context, this.maxBytes);\n    return {\n      decode: () => decodeBufferToNumberOrHex(buffer)\n      // Decodes buffer to either a number or a hexadecimal string.\n    };\n  }\n};\n\n// src/vcdm/encoding/rlp/kind/hexblob/HexBlobKind.ts\nvar HexBlobKind = class extends ScalarKind {\n  /**\n   * Encodes the input data into a Uint8Array.\n   *\n   * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.\n   * @param context - Context string for error handling.\n   * @returns An object containing an encode function which returns the encoded Uint8Array.\n   */\n  data(data, context) {\n    assertValidHexBlobKindData(data, context);\n    return {\n      encode: () => HexUInt.of(data.slice(2)).bytes\n    };\n  }\n  /**\n   * Decodes the input buffer into a hex string.\n   *\n   * @param buffer - The buffer to decode.\n   * @param context - Context string for error handling.\n   * @returns An object containing a decode function which returns the decoded hex string.\n   */\n  buffer(buffer, _context) {\n    return {\n      decode: () => Hex.of(buffer).toString()\n    };\n  }\n};\n\n// src/vcdm/encoding/rlp/kind/hexblob/FixedHexBlobKind.ts\nvar FixedHexBlobKind = class extends HexBlobKind {\n  /**\n   * Creates a new instance of the {@link FixedHexBlobKind} class.\n   * @param bytes - The number of bytes the blob must have.\n   */\n  constructor(bytes) {\n    super();\n    this.bytes = bytes;\n  }\n  /**\n   * Encodes the input data into a Uint8Array with validation against fixed size.\n   *\n   * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.\n   * @param context - Context string for error handling.\n   * @returns An object containing an encode function which returns the encoded Uint8Array.\n   */\n  data(data, context) {\n    const encoder = super.data(data, context);\n    assertFixedHexBlobKindData(data, context, this.bytes);\n    return encoder;\n  }\n  /**\n   * Decodes the input buffer into a hex string with validation against fixed size.\n   *\n   * @param buffer - The buffer to decode.\n   * @param context - Context string for error handling.\n   * @returns An object containing a decode function which returns the decoded hex string.\n   */\n  buffer(buffer, context) {\n    const decoder = super.buffer(buffer, context);\n    assertFixedHexBlobKindBuffer(buffer, context, this.bytes);\n    return decoder;\n  }\n};\n\n// src/vcdm/encoding/rlp/kind/hexblob/OptionalFixedHexBlobKind.ts\nvar OptionalFixedHexBlobKind = class extends FixedHexBlobKind {\n  /**\n   * Encodes the input data (which can be null or undefined) into a Uint8Array.\n   *\n   * @param data - The data to encode, can be null or undefined.\n   * @param context - Context string for error handling.\n   * @returns An object containing an encode function which returns the encoded Uint8Array.\n   */\n  data(data, context) {\n    return data == null ? {\n      encode: () => Uint8Array.from([])\n    } : super.data(data, context);\n  }\n  /**\n   * Decodes the input buffer into a hex string or null if the buffer is empty.\n   *\n   * @param buffer - The buffer to decode, can be empty.\n   * @param context - Context string for error handling.\n   * @returns An object containing a decode function which returns the decoded hex string or null.\n   */\n  buffer(buffer, context) {\n    return buffer.length === 0 ? {\n      decode: () => null\n    } : super.buffer(buffer, context);\n  }\n};\n\n// src/vcdm/encoding/rlp/kind/hexblob/CompactFixedHexBlobKind.ts\nvar CompactFixedHexBlobKind = class extends FixedHexBlobKind {\n  /**\n   * Encodes the input data into a Uint8Array, trimming leading zeros.\n   *\n   * @param data - The data to encode, expected to be a '0x' prefixed hex string.\n   * @param context - Context string for error handling.\n   * @returns An object containing an encode function which returns the encoded Uint8Array.\n   */\n  data(data, context) {\n    const buffer = super.data(data, context).encode();\n    return {\n      encode: () => encodeCompactFixedHexBlob(buffer)\n      // Encode the buffer, trimming leading zeros.\n    };\n  }\n  /**\n   * Decodes the input buffer into a number or hexadecimal string, ensuring it meets the fixed size by padding with zeros.\n   *\n   * @param buffer - The buffer to decode, containing numeric data.\n   * @param context - Descriptive context for error messages, usually representing the caller's identity.\n   * @returns BufferOutput object with a decode function.\n   * @throws Will throw an error if buffer validation fails.\n   */\n  buffer(buffer, context) {\n    assertCompactFixedHexBlobBuffer(buffer, context, this.bytes);\n    return {\n      decode: () => (\n        // Decode the buffer, returning a hex string with leading zeros.\n        Hex.of(buffer).fit(this.bytes * 2).toString()\n      )\n    };\n  }\n};\n\n// src/vcdm/Mnemonic.ts\nimport {\n  entropyToMnemonic,\n  generateMnemonic,\n  validateMnemonic\n} from \"@scure/bip39\";\nimport { wordlist } from \"@scure/bip39/wordlists/english\";\nimport {\n  InvalidDataType as InvalidDataType9,\n  InvalidHDKey as InvalidHDKey3,\n  InvalidHDKeyMnemonic as InvalidHDKeyMnemonic2,\n  InvalidOperation as InvalidOperation10\n} from \"@vechain/sdk-errors\";\nvar Mnemonic = class _Mnemonic {\n  /**\n   * A TextEncoder instance used for encoding text to bytes.\n   *\n   * @type {TextEncoder}\n   */\n  static ENCODER = new TextEncoder();\n  /**\n   * Throws an exception because the mnemonic cannot be represented as a big integer.\n   * @returns {bigint} The BigInt representation of the mnemonic.\n   * @throws {InvalidOperation} The mnemonic cannot be represented as a bigint.\n   * @override {@link VeChainDataModel#bi}\n   * @remark The conversion to BigInt is not supported for a mnemonic.\n   */\n  get bi() {\n    throw new InvalidOperation10(\n      \"Mnemonic.bi\",\n      \"There is no big integer representation for a mnemonic.\",\n      { data: \"\" }\n    );\n  }\n  /**\n   * Generates a mnemonic as encoded bytes.\n   *\n   * @returns {Uint8Array} The bytes representation of the words with spaces.\n   */\n  get bytes() {\n    return _Mnemonic.ENCODER.encode(_Mnemonic.of().join(\" \"));\n  }\n  /**\n   * Throws an exception because the mnemonic cannot be represented as a number.\n   * @returns {bigint} The number representation of the mnemonic.\n   * @throws {InvalidOperation} The mnemonic cannot be represented as a number.\n   * @override {@link VeChainDataModel#n}\n   * @remark The conversion to number is not supported for a mnemonic.\n   */\n  get n() {\n    throw new InvalidOperation10(\n      \"Mnemonic.n\",\n      \"There is no number representation for a mnemonic.\",\n      { data: \"\" }\n    );\n  }\n  /**\n   *\n   * @param that - The mnemonic to compare with.\n   */\n  compareTo(_that) {\n    throw new InvalidOperation10(\n      \"Mnemonic.compareTo\",\n      \"There is no comparison for a mnemonic since it is not stored in memory.\",\n      { data: \"\" }\n    );\n  }\n  isEqual(_that) {\n    throw new InvalidOperation10(\n      \"Mnemonic.isEqual\",\n      \"There is no comparison for a mnemonic since it is not stored in memory.\",\n      { data: \"\" }\n    );\n  }\n  /**\n   * Convert the number of words to the corresponding strength.\n   *\n   * @param numberOfWords - The number of words.\n   *\n   * @returns {number} The corresponding strength.\n   *\n   * @throws {InvalidDataType} If the number of words is not valid.\n   */\n  static wordsNoToStrength(numberOfWords) {\n    switch (numberOfWords) {\n      case 12:\n        return 128;\n      case 15:\n        return 160;\n      case 18:\n        return 192;\n      case 21:\n        return 224;\n      case 24:\n        return 256;\n      default:\n        throw new InvalidDataType9(\n          \"Mnemonic.wordsNoToStrength\",\n          \"not a valid number of words\",\n          { numberOfWords }\n        );\n    }\n  }\n  // Legacy method, probably should be part of a Private Key class (ofMnemonic) #1122\n  /**\n   * Derives a private key from a given list of\n   * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)\n   * and a derivation path as in the examples.\n   *\n   * @example `m/0` (default)\n   * @example `m/0/2`\n   * @example `m/0/2/4/6`\n   *\n   * @param {string[]} words - The set of words used for mnemonic generation.\n   * @param {string} [path='m/0'] - The derivation path from the current node.\n   *\n   * @returns {Uint8Array} - The derived private key as a Uint8Array.\n   *\n   * @throws {InvalidHDKey}\n   *\n   * @remarks Security auditable method, depends on\n   * * {@link HDKey}.\n   */\n  static toPrivateKey(words, path = \"m/0\") {\n    const root = HDKey2.fromMnemonic(words);\n    try {\n      return root.derive(path).privateKey;\n    } catch (error) {\n      throw new InvalidHDKey3(\n        \"mnemonic.derivePrivateKey()\",\n        \"Invalid derivation path given as input.\",\n        { derivationPath: path },\n        error\n      );\n    }\n  }\n  /**\n   * Generates a\n   * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)\n   * phrase using the specified wordlist size and random generator.\n   *\n   * @param {WordlistSizeType} wordlistSize - The number of words to generate the mnemonic.\n   * @param {function} [randomGenerator] - The random generator function used to generate the entropy.\n   *\n   * @returns {Mnemonic} The generated mnemonic.\n   *\n   * @throws {InvalidDataType} If the number of words is not valid.\n   *\n   * @remarks Security auditable method, depends on\n   * * [entropyToMnemonic](https://github.com/paulmillr/scure-bip39);\n   * * [generateMnemonic](https://github.com/paulmillr/scure-bip39);\n   * * `randomGenerator` - **Must provide a cryptographic secure source of entropy\n   *    else any secure audit certification related with this software is invalid.**\n   */\n  static of(wordlistSize = 12, randomGenerator) {\n    try {\n      const strength = _Mnemonic.wordsNoToStrength(wordlistSize);\n      if (randomGenerator != null) {\n        const numberOfBytes = strength / 8;\n        return entropyToMnemonic(\n          randomGenerator(numberOfBytes),\n          wordlist\n        ).split(\" \");\n      }\n      return generateMnemonic(wordlist, strength).split(\" \");\n    } catch (error) {\n      throw new InvalidHDKeyMnemonic2(\n        \"Mnemonic.of\",\n        \"error while generating mnemonic\",\n        { wordlistSize },\n        error\n      );\n    }\n  }\n  /**\n   * Check if the given mnemonic words are valid.\n   *\n   * @param {string | string[]} words - The mnemonic words to check.\n   *\n   * @returns {boolean} true if the words are valid, false otherwise.\n   *\n   * @remarks Security auditable method, depends on\n   * * [validateMnemonic](https://github.com/paulmillr/scure-bip39).\n   */\n  static isValid(words) {\n    const wordsToValidate = Array.isArray(words) ? words.join(\" \") : words;\n    return validateMnemonic(wordsToValidate, wordlist);\n  }\n};\nvar mnemonic = {\n  deriveAddress: (words, path = \"m/0\") => Address.ofMnemonic(words, path).toString(),\n  derivePrivateKey: (words, path = \"m/0\") => Mnemonic.toPrivateKey(words, path),\n  generate: (wordlistSize, randomGenerator) => Mnemonic.of(wordlistSize, randomGenerator),\n  isValid: (words) => Mnemonic.isValid(words)\n};\n\n// src/vcdm/Quantity.ts\nimport { InvalidDataType as InvalidDataType10 } from \"@vechain/sdk-errors\";\nvar Quantity = class _Quantity extends HexUInt {\n  /**\n   * Creates a Quantity instance from a bigint or number given expression\n   *\n   * @param {bigint | number} exp - The value to be expressed as Quantity object:\n   * * bigint must be positive;\n   * * number must be positive, it is converted to bigint to create the Quantity.\n   *\n   * @returns {Quantity} - The new Quantity object.\n   *\n   * @throws {InvalidDataType} - If the provided expression is not a positive integer value.\n   */\n  static of(exp) {\n    try {\n      const huint = HexUInt.of(exp);\n      let cue = 0;\n      while (cue < huint.digits.length && huint.digits.at(cue) === \"0\") {\n        cue++;\n      }\n      return new _Quantity(\n        huint.sign,\n        cue === huint.digits.length ? \"0\" : huint.digits.slice(cue)\n      );\n    } catch (e) {\n      throw new InvalidDataType10(\n        \"Quantity.of\",\n        \"not a Quantity expression\",\n        { exp: `${exp}` },\n        // Needed to serialize bigint values.\n        e\n      );\n    }\n  }\n};\n\n// src/vcdm/Revision.ts\nimport { InvalidDataType as InvalidDataType11 } from \"@vechain/sdk-errors\";\nvar Revision = class _Revision extends Txt {\n  /**\n   * Regular expression pattern for revision strings.\n   * Revision strings can be one of the following:\n   * - \"best\": indicating the best revision\n   * - \"finalized\": indicating a finalized revision\n   * - A positive numeric string indicating a specific revision\n   *\n   * @type {RegExp}\n   */\n  static REGEX_DECIMAL_REVISION = /^(best|finalized|\\d+)$/;\n  /**\n   * Determines if the given value is valid.\n   * This is true if the given value is\n   * - \"best\" string or {@link Txt}: indicating the best revision;\n   * - \"finalized\" string or {@link Txt}: indicating a finalized revision;\n   * - a positive number;\n   * - a positive numeric decimal or `0x` prefixed hexadecimal string indicating a specific revision,\n   *\n   * @param {bigint | number | string | Hex | Txt} value - The value to be validated.\n   * @returns {boolean} - Returns `true` if the value is valid, `false` otherwise.\n   */\n  static isValid(value) {\n    if (typeof value === \"number\") {\n      return Number.isInteger(value) && value >= 0;\n    }\n    return HexUInt.isValid0x(value) || _Revision.REGEX_DECIMAL_REVISION.test(value);\n  }\n  /**\n   * Creates a new Revision object from the given value.\n   *\n   * @param {bigint | number | string | Uint8Array | Hex } value - The value to create the Revision from:\n   * * {@link Hex} must be positive;\n   * * {@link Uint8Array} is decoded as a string: see {@link Txt.of}.\n   *\n   * @returns {Revision} - The created Revision object.\n   *\n   *  @throws {InvalidDataType} if the given value is not a valid revision: see {@link isValid}.\n   *\n   * @remarks The string representation of the revision is always expressed as a number in base 10.\n   * @remarks The {@link Uint8Array} value is decoded as a string content: see {@link Txt.of}.\n   */\n  static of(value) {\n    try {\n      let txt;\n      if (value instanceof Hex) {\n        txt = value.bi.toString();\n      } else if (value instanceof Uint8Array) {\n        txt = Txt.of(value).toString();\n      } else {\n        txt = `${value}`;\n      }\n      if (_Revision.isValid(txt)) {\n        return new _Revision(txt);\n      }\n      throw new InvalidDataType11(\"Revision.of\", \"not a revision\", {\n        value: `${value}`\n      });\n    } catch (e) {\n      throw new InvalidDataType11(\"Revision.of\", \"not a revision\", {\n        value: `${value}`,\n        e\n      });\n    }\n  }\n};\nvar revisionUtils = {\n  isRevisionAccount: (revision) => Revision.isValid(revision),\n  isRevisionBlock: (revision) => Revision.isValid(revision)\n};\n\n// src/vcdm/ThorId.ts\nimport { InvalidDataType as InvalidDataType12 } from \"@vechain/sdk-errors\";\nvar ThorId = class _ThorId extends HexUInt {\n  /**\n   * Number of digits to represent a Thor ID value.\n   *\n   * @remarks The `0x` prefix is excluded.\n   *\n   * @type {number}\n   */\n  static DIGITS = 64;\n  /**\n   * Constructs a ThorId object with the provided hexadecimal value.\n   *\n   * @param {HexUInt} huint - The hexadecimal value representing the ThorId.\n   */\n  constructor(huint) {\n    super(Hex.POSITIVE, huint.fit(_ThorId.DIGITS).digits);\n  }\n  /**\n   * Check if the given expression is a valid ThorId.\n   *\n   * @param {string} exp - The expression to be validated.\n   *\n   * @return {boolean} Returns true if the expression is a valid ThorId, false otherwise.\n   */\n  static isValid(exp) {\n    return Hex.isValid(exp) && HexUInt.REGEX_HEXUINT_PREFIX.test(exp) ? exp.length === _ThorId.DIGITS + 2 : exp.length === _ThorId.DIGITS;\n  }\n  /**\n   * Determines whether the given string is a valid hex number prefixed with '0x'.\n   *\n   * @param {string} exp - The hex number to be checked.\n   *\n   *  @returns {boolean} - True if the hex number is valid, false otherwise.\n   */\n  static isValid0x(exp) {\n    return HexUInt.REGEX_HEXUINT_PREFIX.test(exp) && _ThorId.isValid(exp);\n  }\n  /**\n   * Creates a new ThorId object from the given expression.\n   *\n   * @param {bigint | number | string | Hex | Uint8Array} exp - The expression to create the ThorId from.\n   *     It can be one of the following types:\n   *     - bigint: A BigInteger value that represents the ThorId.\n   *     - number: A number value that represents the ThorId.\n   *     - string: A string value that represents the ThorId.\n   *     - HexUInt: A HexUInt object that represents the ThorId.\n   *     - Uint8Array: A Uint8Array object that represents the ThorId.\n   *\n   * @returns {ThorId} - A new ThorId object created from the given expression.\n   *\n   * @throws {InvalidDataType} If the given expression is not a valid hexadecimal positive integer expression.\n   */\n  static of(exp) {\n    try {\n      if (exp instanceof HexUInt) {\n        return new _ThorId(exp);\n      }\n      return new _ThorId(HexUInt.of(exp));\n    } catch (e) {\n      throw new InvalidDataType12(\n        \"ThorId.of\",\n        \"not a ThorId expression\",\n        { exp: `${exp}` },\n        // Needed to serialize bigint values.\n        e\n      );\n    }\n  }\n};\n\n// src/certificate/Certificate.ts\nimport {\n  CertificateSignatureMismatch,\n  InvalidDataType as InvalidDataType13\n} from \"@vechain/sdk-errors\";\nvar Certificate = class _Certificate {\n  /**\n   * Return the intended use or context of the certificate.\n   */\n  purpose;\n  /**\n   * Returns the content of the certificate.\n   */\n  payload;\n  /**\n   * Return the description of the context of validity of this certificate.\n   */\n  domain;\n  /**\n   * The value expressed as of milliseconds elapsed since the\n   * [epoch](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#the_epoch_timestamps_and_invalid_date),\n   * when the certificate was issued.\n   *\n   * @remarks\n   * The value is a natural number in the safe integer range of JS `number` type.\n   */\n  timestamp;\n  /**\n   * Return the address of the entity signed the certificate, as\n   * a lowercase hexadecimal expression prefixed by `0x`.\n   *\n   * @remarks\n   * Normalized lowercase prefixed expression is needed because\n   * the content of this property is part of the {@signature} computation:\n   * certificates made from checksum case address of the signer should\n   * result valid as the certificate made from the same signer address\n   * not checksum case.\n   */\n  signer;\n  /**\n   * Return the signature computed evaluating the properties of this object\n   * and the private key of the signer.\n   *\n   * @remarks\n   * The signature is a lowercase hexadecimal expression prefixed with `0x`.\n   */\n  signature;\n  /**\n   * Returns a new instance of this class assuring the formal validity of the\n   * arguments used to build the object.\n   *\n   * @param {string} purpose - The purpose of the certificate.\n   * @param {Object} payload - The payload containing type and content.\n   * @param {string} payload.type - The type of the payload.\n   * @param {string} payload.content - The content of the payload.\n   * @param {string} domain - The domain associated with the certificate.\n   * @param {number} timestamp - The time at which the certificate is created;\n   * must be a positive safe integer.\n   * @param {string} signer - The signer of the certificate;\n   * must be a valid address.\n   * @param {string|undefined} [signature] - The signature of the certificate;\n   * optional parameter.\n   *\n   * @throws {InvalidDataType} If timestamp is not a positive safe integer.\n   * @throws {InvalidDataType} If signer is not a valid address.\n   * @throws {InvalidDataType} If signature is invalid.\n   *\n   * @remarks\n   * The `signer` address is represented lowercase and `0x` prefixed.\n   */\n  constructor(purpose, payload, domain, timestamp, signer, signature) {\n    if (Number.isSafeInteger(timestamp) && timestamp >= 0) {\n      if (Address.isValid(signer)) {\n        this.purpose = purpose;\n        this.payload = payload;\n        this.domain = domain;\n        this.timestamp = timestamp;\n        this.signer = signer.toString().toLowerCase();\n        try {\n          this.signature = typeof signature === \"string\" ? HexUInt.of(signature).alignToBytes().toString() : signature;\n        } catch (e) {\n          throw new InvalidDataType13(\n            \"Certificate.constructor\",\n            \"invalid signature\",\n            { signature },\n            e\n          );\n        }\n      } else\n        throw new InvalidDataType13(\n          \"Certificate.constructor\",\n          \"signer is not an address\",\n          { signer }\n        );\n    } else\n      throw new InvalidDataType13(\n        \"Certificate.constructor\",\n        \"not positive safe integer timestamp\",\n        { timestamp }\n      );\n  }\n  /**\n   * Encodes a given object into a Uint8Array representation\n   * applying the following operation to normalize the content:\n   * - the properties are sorted in ascending alphabetic order;\n   * - the key/value properties are delimited with `\"` when serialized as JSON\n   *   before to be encoded as bytes;\n   * - any not meaningful blank characters are ignored;\n   * - the JSON representation of this object is byte encoded using the UTF-8\n   *   [normalization form for canonical composition](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms).\n   *\n   * @param {unknown} object - The input object to be encoded.\n   * @return {Uint8Array} The encoded Uint8Array representation of the input object.\n   */\n  static encode(object) {\n    return Txt.of(fastJsonStableStringify(object)).bytes;\n  }\n  /**\n   * Return `true` if the current instance has a signature.\n   *\n   * @return {boolean} `true` if the signature is a valid hexadecimal string,\n   * otherwise `false`.\n   */\n  isSigned() {\n    return typeof this.signature === \"string\" && HexUInt.isValid(this.signature);\n  }\n  /**\n   * Creates a new Certificate instance from the provided CertificateData.\n   *\n   * @param {CertificateData} data - The data required to create the Certificate.\n   * @return {Certificate} A new Certificate instance.\n   * @throws {InvalidDataType} If the provided data is invalid:\n   * - if timestamp is not a positive safe integer;\n   * - if signer is not a valid address;\n   * - if signature is an invalid hexadecimal expression.\n   *\n   * @remarks\n   * This method supports {@link signer}\n   * [mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55).\n   *\n   * @see constructor\n   */\n  static of(data) {\n    try {\n      return new _Certificate(\n        data.purpose,\n        data.payload,\n        data.domain,\n        data.timestamp,\n        data.signer,\n        data.signature\n      );\n    } catch (e) {\n      throw new InvalidDataType13(\n        \"Certificate.of\",\n        \"invalid certificate data\",\n        { certifiable: data },\n        e\n      );\n    }\n  }\n  /**\n   * Signs the current object using a given private key.\n   *\n   * The {@link signature} is computed encoding this object according\n   * the following normalization rules:\n   * - the {@link signature} property is ignored, because its value\n   *   is the result of this method.\n   * - the properties are sorted in ascending alphabetic order;\n   * - the key/value properties are delimited with `\"` when serialized as JSON\n   *   before to be encoded as bytes;\n   * - any not meaningful blank characters are ignored;\n   * - the JSON representation of this object is byte encoded using the UTF-8\n   *   [normalization form for canonical composition](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms).\n   *\n   * @param {Uint8Array} privateKey - The private key used for signing.\n   * @return {this} The current instance after signing.\n   *\n   * @throws {InvalidOperation} - If a hash error occurs.\n   * @throws {InvalidSecp256k1PrivateKey} - If the private key is not a valid 32-byte private key.\n   *\n   * @remarks Security auditable method, depends on\n   * * {@link Blake2b256.of};\n   * * {@link Secp256k1.sign}.\n   *\n   * @see encode\n   * @see verify\n   */\n  sign(privateKey) {\n    this.signature = void 0;\n    this.signature = HexUInt.of(\n      Secp256k1.sign(\n        Blake2b256.of(_Certificate.encode(this)).bytes,\n        privateKey\n      )\n    ).toString();\n    return this;\n  }\n  /**\n   * Verifies the certificate by checking its signature.\n   *\n   * @throws {CertificateSignatureMismatch} if the certificate\n   * - is not signed, or\n   * - the signature does not match the signer's public key.\n   *\n   * @remarks\n   * This method supports {@link signer}\n   * [mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55).\n   *\n   * @remarks Security auditable method, depends on\n   * * {@link Blake2b256.of};\n   * * {@link Secp256k1.recover}.\n   */\n  verify() {\n    if (!this.isSigned())\n      throw new CertificateSignatureMismatch(\n        \"Certificate.verify\",\n        \"signature missing\",\n        { certificate: this }\n      );\n    const signer = Address.ofPublicKey(\n      Secp256k1.recover(\n        Blake2b256.of(\n          _Certificate.encode({ ...this, signature: void 0 })\n        ).bytes,\n        HexUInt.of(this.signature).bytes\n      )\n    );\n    if (signer.toString().toLowerCase() !== this.signer)\n      throw new CertificateSignatureMismatch(\n        \"Certificate.verify\",\n        \"signature doesn't match with signer's public key\",\n        { certificate: this }\n      );\n  }\n};\n\n// src/keystore/keystore.ts\nimport { VeChainSDKLogger } from \"@vechain/sdk-logging\";\n\n// src/keystore/cryptography/ethers/keystore.ts\nimport {\n  InvalidKeystore,\n  InvalidKeystoreParams,\n  stringifyData\n} from \"@vechain/sdk-errors\";\nimport { ethers } from \"ethers\";\n\n// src/keystore/cryptography/ethers/const/keystore.ts\nvar SCRYPT_PARAMS = {\n  N: 131072,\n  r: 8,\n  p: 1\n};\n\n// src/keystore/cryptography/ethers/keystore.ts\nasync function encrypt(privateKey, password) {\n  const derivePublicKey = Secp256k1.derivePublicKey(privateKey);\n  const deriveAddress = Address.ofPublicKey(derivePublicKey).toString();\n  const keystoreAccount = {\n    address: deriveAddress,\n    privateKey: HexUInt.of(privateKey).toString()\n  };\n  const encryptOptions = {\n    scrypt: {\n      N: SCRYPT_PARAMS.N,\n      r: SCRYPT_PARAMS.r,\n      p: SCRYPT_PARAMS.p\n    }\n  };\n  const keystoreJsonString = await ethers.encryptKeystoreJson(\n    keystoreAccount,\n    password,\n    encryptOptions\n  );\n  return JSON.parse(keystoreJsonString);\n}\nasync function decrypt(keystore4, password) {\n  if (!isValid(keystore4)) {\n    throw new InvalidKeystore(\n      \"keystore.decrypt()\",\n      \"Invalid keystore. Ensure the keystore is properly formatted and contains the necessary data.\",\n      { keystore: keystore4 }\n    );\n  }\n  try {\n    return await ethers.decryptKeystoreJson(\n      stringifyData(keystore4),\n      password\n    );\n  } catch (e) {\n    throw new InvalidKeystoreParams(\n      \"keystore.decrypt()\",\n      \"Decryption failed: Invalid Password for the given keystore.\",\n      // @NOTE: We are not exposing the password in the error data for security reasons.\n      {\n        keystore: keystore4\n      }\n    );\n  }\n}\nfunction isValid(keystore4) {\n  return ethers.isKeystoreJson(stringifyData(keystore4));\n}\nvar keystore = { encrypt, decrypt, isValid };\n\n// src/keystore/cryptography/experimental/keystore.ts\nimport * as n_utils from \"@noble/curves/abstract/utils\";\nimport { InvalidKeystoreParams as InvalidKeystoreParams2, stringifyData as stringifyData2 } from \"@vechain/sdk-errors\";\nimport { ctr } from \"@noble/ciphers/aes\";\nimport { scrypt } from \"@noble/hashes/scrypt\";\nvar KEYSTORE_CRYPTO_CIPHER = \"aes-128-ctr\";\nvar KEYSTORE_CRYPTO_PARAMS_DKLEN = 32;\nvar KEYSTORE_CRYPTO_KDF = \"scrypt\";\nvar KEYSTORE_VERSION = 3;\nvar SCRYPT_PARAMS2 = {\n  N: 131072,\n  r: 8,\n  p: 1\n};\nfunction decodeScryptParams(keystore4) {\n  const salt = n_utils.hexToBytes(keystore4.crypto.kdfparams.salt);\n  const N = keystore4.crypto.kdfparams.n;\n  const r = keystore4.crypto.kdfparams.r;\n  const p = keystore4.crypto.kdfparams.p;\n  if (N <= 0 || (N & N - 1) !== 0)\n    throw new InvalidKeystoreParams2(\n      \"(EXPERIMENTAL) keystore.decodeScryptParams()\",\n      \"Decryption failed: invalid  keystore.crypto.kdfparams.n parameter.\",\n      {\n        keystore: keystore4,\n        N\n      }\n    );\n  if (r <= 0 || p <= 0)\n    throw new InvalidKeystoreParams2(\n      \"(EXPERIMENTAL) keystore.decodeScryptParams()\",\n      \"Decryption failed: both keystore.crypto.kdfparams.r or keystore.crypto.kdfparams.p parameter must be > 0.\",\n      {\n        keystore: keystore4,\n        r,\n        p\n      }\n    );\n  const dkLen = keystore4.crypto.kdfparams.dklen;\n  if (dkLen !== KEYSTORE_CRYPTO_PARAMS_DKLEN)\n    throw new InvalidKeystoreParams2(\n      \"(EXPERIMENTAL) keystore.decodeScryptParams()\",\n      `Decryption failed: keystore.crypto.kdfparams.dklen parameter must be ${KEYSTORE_CRYPTO_PARAMS_DKLEN}`,\n      {\n        keystore: keystore4,\n        dkLen\n      }\n    );\n  return {\n    N,\n    dkLen: KEYSTORE_CRYPTO_PARAMS_DKLEN,\n    name: KEYSTORE_CRYPTO_KDF,\n    p,\n    r,\n    salt\n  };\n}\nfunction encodeScryptParams(options) {\n  const salt = options.salt ?? Secp256k1.randomBytes(KEYSTORE_CRYPTO_PARAMS_DKLEN);\n  let N = SCRYPT_PARAMS2.N;\n  let r = SCRYPT_PARAMS2.r;\n  let p = SCRYPT_PARAMS2.p;\n  if (options.scrypt != null) {\n    if (options.scrypt.N != null) {\n      N = options.scrypt.N;\n    }\n    if (options.scrypt.r != null) {\n      r = options.scrypt.r;\n    }\n    if (options.scrypt.p != null) {\n      p = options.scrypt.p;\n    }\n  }\n  if (N <= 0 || (BigInt(N) & BigInt(N - 1)) !== BigInt(0))\n    throw new InvalidKeystoreParams2(\n      \"(EXPERIMENTAL) keystore.encodeScryptParams()\",\n      \"Encryption failed: invalid options.scrypt.N parameter.\",\n      {\n        options,\n        N\n      }\n    );\n  if (r <= 0 || !Number.isSafeInteger(r))\n    throw new InvalidKeystoreParams2(\n      \"(EXPERIMENTAL) keystore.encodeScryptParams()\",\n      \"Encryption failed: invalid options.scrypt.r parameter.\",\n      {\n        options,\n        r\n      }\n    );\n  if (p <= 0 || !Number.isSafeInteger(p))\n    throw new InvalidKeystoreParams2(\n      \"(EXPERIMENTAL) keystore.encodeScryptParams()\",\n      \"Encryption failed: invalid options.scrypt.p parameter.\",\n      {\n        options,\n        p\n      }\n    );\n  return {\n    name: KEYSTORE_CRYPTO_KDF,\n    dkLen: KEYSTORE_CRYPTO_PARAMS_DKLEN,\n    N,\n    p,\n    r,\n    salt\n  };\n}\nfunction encrypt2(privateKey, password) {\n  return encryptKeystore(privateKey, password, {\n    scrypt: {\n      N: SCRYPT_PARAMS2.N,\n      r: SCRYPT_PARAMS2.r,\n      p: SCRYPT_PARAMS2.p\n    }\n  });\n}\nfunction encryptKeystore(privateKey, password, options) {\n  try {\n    const kdf = encodeScryptParams(options);\n    const key = scrypt(password, kdf.salt, {\n      N: kdf.N,\n      r: kdf.r,\n      p: kdf.p,\n      dkLen: kdf.dkLen\n    });\n    const iv = options.iv ?? Secp256k1.randomBytes(16);\n    if (iv.length !== 16)\n      throw new InvalidKeystoreParams2(\n        \"(EXPERIMENTAL) keystore.encryptKeystore()\",\n        \"Encryption failed: invalid options.iv length.\",\n        { iv }\n      );\n    const uuidRandom = options.uuid ?? Secp256k1.randomBytes(16);\n    if (uuidRandom.length !== 16)\n      throw new InvalidKeystoreParams2(\n        \"(EXPERIMENTAL) keystore.encryptKeystore()\",\n        \"Encryption failed: invalid options.uuid length.\",\n        { uuidRandom }\n      );\n    const macPrefix = key.slice(16, 32);\n    const ciphertext = ctr(key.slice(0, 16), iv).encrypt(privateKey);\n    return {\n      address: Address.ofPrivateKey(privateKey).toString(),\n      crypto: {\n        cipher: KEYSTORE_CRYPTO_CIPHER,\n        cipherparams: {\n          iv: Hex.of(iv).digits\n        },\n        ciphertext: Hex.of(ciphertext).digits,\n        kdf: \"scrypt\",\n        kdfparams: {\n          dklen: KEYSTORE_CRYPTO_PARAMS_DKLEN,\n          n: kdf.N,\n          p: kdf.p,\n          r: kdf.r,\n          salt: Hex.of(kdf.salt).digits\n        },\n        // Compute the message authentication code, used to check the password.\n        mac: Keccak256.of(n_utils.concatBytes(macPrefix, ciphertext)).digits\n      },\n      id: uuidV4(uuidRandom),\n      version: KEYSTORE_VERSION\n    };\n  } finally {\n    privateKey.fill(0);\n    password.fill(0);\n  }\n}\nfunction decrypt2(keystore4, password) {\n  return decryptKeystore(keystore4, password);\n}\nfunction decryptKeystore(keystore4, password) {\n  try {\n    if (keystore4.crypto.cipher.toLowerCase() !== KEYSTORE_CRYPTO_CIPHER)\n      throw new InvalidKeystoreParams2(\n        \"(EXPERIMENTAL) keystore.decryptKeystore()\",\n        \"Decryption failed: unsupported crypto cipher algorithm.\",\n        { cipher: keystore4.crypto.cipher.toLowerCase() }\n      );\n    if (keystore4.crypto.kdf.toLowerCase() !== KEYSTORE_CRYPTO_KDF)\n      throw new InvalidKeystoreParams2(\n        \"(EXPERIMENTAL) keystore.decryptKeystore()\",\n        \"Decryption failed: unsupported crypto key derivation function.\",\n        { keyDerivationFunction: keystore4.crypto.kdf.toLowerCase() }\n      );\n    if (keystore4.version !== KEYSTORE_VERSION)\n      throw new InvalidKeystoreParams2(\n        \"(EXPERIMENTAL) keystore.decryptKeystore()\",\n        \"Decryption failed: unsupported keystore version.\",\n        { version: keystore4.version }\n      );\n    const kdf = decodeScryptParams(keystore4);\n    const key = scrypt(password, kdf.salt, {\n      N: kdf.N,\n      r: kdf.r,\n      p: kdf.p,\n      dkLen: kdf.dkLen\n    });\n    const ciphertext = n_utils.hexToBytes(keystore4.crypto.ciphertext);\n    if (keystore4.crypto.mac !== Keccak256.of(n_utils.concatBytes(key.slice(16, 32), ciphertext)).digits) {\n      throw new InvalidKeystoreParams2(\n        \"(EXPERIMENTAL) keystore.decryptKeystore()\",\n        \"Decryption failed: Invalid Password for the given keystore.\",\n        // @NOTE: We are not exposing the password in the error data for security reasons.\n        {\n          keystore: keystore4\n        }\n      );\n    }\n    const privateKey = ctr(\n      key.slice(0, 16),\n      n_utils.hexToBytes(keystore4.crypto.cipherparams.iv)\n    ).decrypt(ciphertext);\n    const address = Address.ofPrivateKey(privateKey).toString();\n    if (keystore4.address !== \"\" && address !== Address.checksum(Hex.of(keystore4.address))) {\n      throw new InvalidKeystoreParams2(\n        \"(EXPERIMENTAL) keystore.decryptKeystore()\",\n        \"Decryption failed: address/password mismatch.\",\n        { keystoreAddress: keystore4.address }\n      );\n    }\n    return {\n      address,\n      // @note: Convert the private key to a string to be compatible with ethers\n      privateKey: Hex.of(privateKey).toString()\n    };\n  } finally {\n    password.fill(0);\n  }\n}\nfunction isValid2(keystore4) {\n  try {\n    const copy = JSON.parse(stringifyData2(keystore4));\n    if (copy.crypto.cipher.toLowerCase() === KEYSTORE_CRYPTO_CIPHER && copy.crypto.kdf.toLowerCase() === KEYSTORE_CRYPTO_KDF && copy.version === KEYSTORE_VERSION) {\n      return true;\n    }\n  } catch (e) {\n  }\n  return false;\n}\nfunction uuidV4(bytes) {\n  bytes[6] = bytes[6] & 15 | 64;\n  bytes[8] = bytes[8] & 63 | 128;\n  const value = Hex.of(bytes).digits;\n  return [\n    value.substring(0, 8),\n    value.substring(8, 12),\n    value.substring(12, 16),\n    value.substring(16, 20),\n    value.substring(20, 32)\n  ].join(\"-\");\n}\nvar keystore2 = { decrypt: decrypt2, encrypt: encrypt2, isValid: isValid2 };\n\n// src/keystore/keystore.ts\nvar EXPERIMENTAL_CRYPTOGRAPHY = false;\nfunction useExperimentalCryptography(experimentalCryptography) {\n  EXPERIMENTAL_CRYPTOGRAPHY = experimentalCryptography;\n}\nasync function encrypt3(privateKey, password) {\n  if (EXPERIMENTAL_CRYPTOGRAPHY)\n    VeChainSDKLogger(\"warning\").log({\n      title: `Experimental cryptography`,\n      messages: [\n        `Remember, you are using an experimental cryptography library.`,\n        \"functions: keystore.encrypt\"\n      ]\n    });\n  return EXPERIMENTAL_CRYPTOGRAPHY ? keystore2.encrypt(privateKey, Txt.of(password).bytes) : await keystore.encrypt(privateKey, password);\n}\nasync function decrypt3(keystore4, password) {\n  if (EXPERIMENTAL_CRYPTOGRAPHY)\n    VeChainSDKLogger(\"warning\").log({\n      title: `Experimental cryptography`,\n      messages: [\n        `Remember, you are using an experimental cryptography library.`,\n        \"functions: keystore.decrypt\"\n      ]\n    });\n  return EXPERIMENTAL_CRYPTOGRAPHY ? keystore2.decrypt(keystore4, Txt.of(password).bytes) : await keystore.decrypt(keystore4, password);\n}\nfunction isValid3(keystore4) {\n  if (EXPERIMENTAL_CRYPTOGRAPHY)\n    VeChainSDKLogger(\"warning\").log({\n      title: `Experimental cryptography`,\n      messages: [\n        `Remember, you are using an experimental cryptography library.`,\n        \"functions: keystore.isValid\"\n      ]\n    });\n  return EXPERIMENTAL_CRYPTOGRAPHY ? keystore2.isValid(keystore4) : keystore.isValid(keystore4);\n}\nvar keystore3 = { encrypt: encrypt3, decrypt: decrypt3, isValid: isValid3, useExperimentalCryptography };\n\n// src/utils/const/abi.ts\nvar ERC20_ABI = [\n  { inputs: [], stateMutability: \"nonpayable\", type: \"constructor\" },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"allowance\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"needed\", type: \"uint256\" }\n    ],\n    name: \"ERC20InsufficientAllowance\",\n    type: \"error\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"sender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"balance\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"needed\", type: \"uint256\" }\n    ],\n    name: \"ERC20InsufficientBalance\",\n    type: \"error\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"approver\", type: \"address\" }\n    ],\n    name: \"ERC20InvalidApprover\",\n    type: \"error\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"receiver\", type: \"address\" }\n    ],\n    name: \"ERC20InvalidReceiver\",\n    type: \"error\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"sender\", type: \"address\" }],\n    name: \"ERC20InvalidSender\",\n    type: \"error\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"spender\", type: \"address\" }],\n    name: \"ERC20InvalidSpender\",\n    type: \"error\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Approval\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Transfer\",\n    type: \"event\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" }\n    ],\n    name: \"allowance\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" }\n    ],\n    name: \"approve\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [{ internalType: \"uint8\", name: \"\", type: \"uint8\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"name\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"symbol\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" }\n    ],\n    name: \"transfer\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" }\n    ],\n    name: \"transferFrom\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  }\n];\nvar ERC721_ABI = [\n  {\n    inputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"tokenId\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\"\n      }\n    ],\n    name: \"ERC721IncorrectOwner\",\n    type: \"error\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"operator\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"tokenId\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"ERC721InsufficientApproval\",\n    type: \"error\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"approver\",\n        type: \"address\"\n      }\n    ],\n    name: \"ERC721InvalidApprover\",\n    type: \"error\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"operator\",\n        type: \"address\"\n      }\n    ],\n    name: \"ERC721InvalidOperator\",\n    type: \"error\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\"\n      }\n    ],\n    name: \"ERC721InvalidOwner\",\n    type: \"error\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\"\n      }\n    ],\n    name: \"ERC721InvalidReceiver\",\n    type: \"error\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\"\n      }\n    ],\n    name: \"ERC721InvalidSender\",\n    type: \"error\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"tokenId\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"ERC721NonexistentToken\",\n    type: \"error\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"approved\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"tokenId\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Approval\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"operator\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"bool\",\n        name: \"approved\",\n        type: \"bool\"\n      }\n    ],\n    name: \"ApprovalForAll\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"tokenId\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Transfer\",\n    type: \"event\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"tokenId\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"approve\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\"\n      }\n    ],\n    name: \"balanceOf\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"tokenId\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"getApproved\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"operator\",\n        type: \"address\"\n      }\n    ],\n    name: \"isApprovedForAll\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\"\n      }\n    ],\n    name: \"mintItem\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"name\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"tokenId\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"ownerOf\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"tokenId\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"safeTransferFrom\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"tokenId\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\"\n      }\n    ],\n    name: \"safeTransferFrom\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"operator\",\n        type: \"address\"\n      },\n      {\n        internalType: \"bool\",\n        name: \"approved\",\n        type: \"bool\"\n      }\n    ],\n    name: \"setApprovalForAll\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"interfaceId\",\n        type: \"bytes4\"\n      }\n    ],\n    name: \"supportsInterface\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"symbol\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"tokenId\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"tokenURI\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"tokenId\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"transferFrom\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  }\n];\nvar ERC1155_ABI = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"operator\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"bool\",\n        name: \"approved\",\n        type: \"bool\"\n      }\n    ],\n    name: \"ApprovalForAll\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"operator\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256[]\",\n        name: \"ids\",\n        type: \"uint256[]\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256[]\",\n        name: \"values\",\n        type: \"uint256[]\"\n      }\n    ],\n    name: \"TransferBatch\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"operator\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"id\",\n        type: \"uint256\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"TransferSingle\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"string\",\n        name: \"value\",\n        type: \"string\"\n      },\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"id\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"URI\",\n    type: \"event\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"id\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"balanceOf\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address[]\",\n        name: \"accounts\",\n        type: \"address[]\"\n      },\n      {\n        internalType: \"uint256[]\",\n        name: \"ids\",\n        type: \"uint256[]\"\n      }\n    ],\n    name: \"balanceOfBatch\",\n    outputs: [\n      {\n        internalType: \"uint256[]\",\n        name: \"\",\n        type: \"uint256[]\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"account\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"operator\",\n        type: \"address\"\n      }\n    ],\n    name: \"isApprovedForAll\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256[]\",\n        name: \"ids\",\n        type: \"uint256[]\"\n      },\n      {\n        internalType: \"uint256[]\",\n        name: \"amounts\",\n        type: \"uint256[]\"\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\"\n      }\n    ],\n    name: \"safeBatchTransferFrom\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"id\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"bytes\",\n        name: \"data\",\n        type: \"bytes\"\n      }\n    ],\n    name: \"safeTransferFrom\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"operator\",\n        type: \"address\"\n      },\n      {\n        internalType: \"bool\",\n        name: \"approved\",\n        type: \"bool\"\n      }\n    ],\n    name: \"setApprovalForAll\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes4\",\n        name: \"interfaceId\",\n        type: \"bytes4\"\n      }\n    ],\n    name: \"supportsInterface\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"id\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"uri\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n];\nvar VIP180_ABI = ERC20_ABI;\nvar VIP181_ABI = ERC721_ABI;\nvar VIP210_ABI = ERC1155_ABI;\n\n// src/utils/const/data.ts\nvar ZERO_BYTES = (size) => new Uint8Array(size);\nvar NUMERIC_REGEX = /(^-?\\d+(\\.\\d+)?)$|(^-?\\.\\d+)$/;\n\n// src/utils/data/data.ts\nimport * as nc_utils5 from \"@noble/curves/abstract/utils\";\nimport { InvalidDataType as InvalidDataType14 } from \"@vechain/sdk-errors\";\nvar decodeBytes32String = (hex) => {\n  if (!Hex.isValid(hex) || Hex.of(hex).digits.length !== 64)\n    throw new InvalidDataType14(\n      \"dataUtils.decodeBytes32String()\",\n      `Failed to decode value ${hex} to string. Value is not a valid hex string or it is not 64 characters long`,\n      { value: hex }\n    );\n  const valueInBytes = Hex.of(hex).bytes;\n  const firstZeroIndex = valueInBytes.findIndex((byte) => byte === 0);\n  if (firstZeroIndex === 0) {\n    const firstNotZeroIndex = valueInBytes.findIndex((byte) => byte !== 0);\n    return Txt.of(valueInBytes.subarray(firstNotZeroIndex)).toString();\n  } else if (firstZeroIndex !== -1) {\n    return Txt.of(valueInBytes.subarray(0, firstZeroIndex)).toString();\n  } else {\n    return Txt.of(valueInBytes).toString();\n  }\n};\nvar encodeBytes32String = (value, zeroPadding = \"right\") => {\n  try {\n    const valueInBytes = Txt.of(value).bytes;\n    if (valueInBytes.length > 32) {\n      throw new InvalidDataType14(\n        \"dataUtils.encodeBytes32String()\",\n        `Failed to encode value ${value} to bytes32 string. Value exceeds 32 bytes.`,\n        { value }\n      );\n    }\n    const pad = ZERO_BYTES(32 - valueInBytes.length);\n    return zeroPadding === \"left\" ? Hex.of(nc_utils5.concatBytes(pad, valueInBytes)).toString() : Hex.of(nc_utils5.concatBytes(valueInBytes, pad)).toString();\n  } catch (e) {\n    throw new InvalidDataType14(\n      \"dataUtils.encodeBytes32String()\",\n      `Failed to encode value ${value} to bytes32 string.`,\n      { value },\n      e\n    );\n  }\n};\nvar dataUtils = {\n  decodeBytes32String,\n  encodeBytes32String\n};\n\n// src/transaction/Clause.ts\nimport { InvalidDataType as InvalidDataType15 } from \"@vechain/sdk-errors\";\nvar Clause = class _Clause {\n  /**\n   * Used internally in {@link Clause.callFunction}.\n   */\n  static FORMAT_TYPE = \"json\";\n  /**\n   * Used internally to tag a transaction not tranferring token amount.\n   */\n  static NO_VALUE = Hex.PREFIX + \"0\";\n  /**\n   * Used internally to tag a transaction without data.\n   */\n  static NO_DATA = Hex.PREFIX;\n  /**\n   * Used internally in {@link Clause.transferNFT} method.\n   */\n  static TRANSFER_NFT_FUNCTION = \"transferFrom\";\n  /**\n   * Used internally in {@link Clause.transferToken} method.\n   */\n  static TRANSFER_TOKEN_FUNCTION = \"transfer\";\n  /**\n   * Represents the address where:\n   * - transfer token to, or\n   * - invoke contract method on.\n   */\n  to;\n  /**\n   * Return the hexadecimal expression of the amount of VET or VTHO\n   * token in {@link Units.wei} to transfer to the destination.\n   *\n   * @see {Clause.callFunction}\n   * @see {Clause.transferToken}\n   * @see {Clause.transferVET}\n   */\n  value;\n  /**\n   * Return the hexadecimal expression of the encoding of the arguments\n   * of the called function of a smart contract.\n   */\n  data;\n  /**\n   * An optional comment to describe the purpose of the clause.\n   */\n  comment;\n  /**\n   * An optional  Application Binary Interface (ABI) of the called\n   * function of a smart contract.\n   */\n  abi;\n  /**\n   * Creates an instance of the class.\n   *\n   * @param {string|null} to - The address to transfer token\n   * or the smart contract to call, can be null.\n   * @param {string} value - The token amount being transferred in wei units\n   * as hexadecimal expression.\n   * @param {string} data - Arguments of the smart contract function called\n   * as encoded as a hexadecimal expression\n   * @param {string} [comment] - An optional comment.\n   * @param {string} [abi] - An optional ABI string.\n   */\n  constructor(to, value, data, comment, abi) {\n    this.to = to;\n    this.value = value;\n    this.data = data;\n    this.comment = comment;\n    this.abi = abi;\n  }\n  /**\n   * Return the amount of {@link VET} or {@link VTHO} token\n   * in {@link Units.wei} to transfer to the destination.\n   *\n   * @return {FixedPointNumber} The amount as a fixed-point number.\n   */\n  amount() {\n    return FixedPointNumber.of(HexInt.of(this.value).bi);\n  }\n  /**\n   * Return a new clause to call a function of a smart contract.\n   *\n   * @param {Address} contractAddress - The address of the smart contract.\n   * @param {ABIFunction} functionAbi - The ABI definition of the function to be called.\n   * @param {unknown[]} args - The arguments for the function.\n   * @param {VET} [amount=VET.of(FixedPointNumber.ZERO)] - The amount of VET to be sent with the transaction calling the function.\n   * @param {ClauseOptions} [clauseOptions] - Optional clause settings.\n   * @return {Clause} A clause object to call the function in a transaction.\n   * @throws {InvalidDataType} Throws an error if the amount is not a finite positive value.\n   */\n  static callFunction(contractAddress, functionAbi, args, amount = VET.of(FixedPointNumber.ZERO), clauseOptions) {\n    if (amount.value.isFinite() && amount.value.isPositive()) {\n      return new _Clause(\n        contractAddress.toString().toLowerCase(),\n        Hex.PREFIX + amount.wei.toString(Hex.RADIX),\n        functionAbi.encodeData(args).toString(),\n        clauseOptions?.comment,\n        clauseOptions?.includeABI === true ? functionAbi.format(_Clause.FORMAT_TYPE) : void 0\n      );\n    }\n    throw new InvalidDataType15(\n      \"Clause.callFunction\",\n      \"not finite positive amount\",\n      { amount: `${amount.value}` }\n    );\n  }\n  /**\n   * Returns a new clause to deploy a smart contract.\n   *\n   * @param {HexUInt} contractBytecode - The bytecode of the contract to be deployed.\n   * @param {DeployParams} [deployParams] - Optional parameters to pass to the smart contract constructor.\n   * @param {ClauseOptions} [clauseOptions] - Optional clause settings.\n   * @return {Clause} The clause to deploy the smart contract as part of a transaction.\n   */\n  static deployContract(contractBytecode, deployParams, clauseOptions) {\n    const data = deployParams !== null && deployParams !== void 0 ? contractBytecode.digits + ethersAbi.encodeParams(deployParams.types, deployParams.values).replace(Hex.PREFIX, \"\") : contractBytecode.digits;\n    return new _Clause(\n      null,\n      _Clause.NO_VALUE,\n      Hex.PREFIX + data,\n      clauseOptions?.comment\n    );\n  }\n  /**\n   * Transfers an NFT from the sender to the recipient.\n   *\n   * @param {Address} contractAddress - The address of the NFT contract.\n   * @param {Address} senderAddress - The address of the current owner (sender) of the NFT.\n   * @param {Address} recipientAddress - The address of the new owner (recipient) of the NFT.\n   * @param {HexUInt} tokenId - The unique identifier of the NFT to be transferred.\n   * @param {ClauseOptions} [clauseOptions] - Optional clause settings.\n   * @return {Clause} The clause object representing the transfer operation as part of a transaction.\n   */\n  static transferNFT(contractAddress, senderAddress, recipientAddress, tokenId, clauseOptions) {\n    return _Clause.callFunction(\n      contractAddress,\n      ABIContract.ofAbi(ERC721_ABI).getFunction(\n        _Clause.TRANSFER_NFT_FUNCTION\n      ),\n      [\n        senderAddress.toString(),\n        recipientAddress.toString(),\n        tokenId.bi.toString()\n      ],\n      void 0,\n      clauseOptions\n    );\n  }\n  /**\n   * Return a new clause to transfers the specified amount of\n   * [VIP180](https://docs.vechain.org/introduction-to-vechain/dual-token-economic-model/vethor-vtho#vip180-vechains-fungible-token-standard)\n   * token.\n   *\n   * @param {Address} tokenAddress - The address of the VIP180 token.\n   * @param {Address} recipientAddress - The address of the recipient.\n   * @param {VTHO} amount - The amount of token to be transferred.\n   * @param {ClauseOptions} [clauseOptions] - Optional clause settings.\n   * @return {Clause} The clause to transfer VIP180 tokens as part of a transaction.\n   * @throws {InvalidDataType} Throws an error if the amount is not a positive integer.\n   *\n   * @see VTHO.transferTokenTo\n   */\n  static transferToken(tokenAddress, recipientAddress, amount, clauseOptions) {\n    if (amount.value.isFinite() && amount.value.isPositive()) {\n      return this.callFunction(\n        tokenAddress,\n        ABIContract.ofAbi(VIP180_ABI).getFunction(\n          _Clause.TRANSFER_TOKEN_FUNCTION\n        ),\n        [recipientAddress.toString(), amount.wei],\n        void 0,\n        clauseOptions\n      );\n    }\n    throw new InvalidDataType15(\n      \"Clause.transferToken\",\n      \"not positive integer amount\",\n      { amount: `${amount.value}` }\n    );\n  }\n  /**\n   * Return a new clause to transfers VET to a specified recipient address.\n   *\n   * @param {Address} recipientAddress - The address of the recipient.\n   * @param {VET} amount - The amount of VET to transfer.\n   * @param {ClauseOptions} [clauseOptions] - Optional clause settings.\n   * @return {Clause} - The clause object to transfer VET as part of a transaction.\n   * @throws {InvalidDataType} - If the amount is not a finite positive value.\n   *\n   * @see VET.transferTo\n   */\n  static transferVET(recipientAddress, amount, clauseOptions) {\n    if (amount.value.isFinite() && amount.value.isPositive()) {\n      return new _Clause(\n        recipientAddress.toString().toLowerCase(),\n        Hex.PREFIX + amount.wei.toString(Hex.RADIX),\n        _Clause.NO_DATA,\n        clauseOptions?.comment\n      );\n    }\n    throw new InvalidDataType15(\n      \"Clause.transferVET\",\n      \"not finite positive amount\",\n      { amount: `${amount.value}` }\n    );\n  }\n};\n\n// src/transaction/Transaction.ts\nimport * as nc_utils6 from \"@noble/curves/abstract/utils\";\nimport {\n  InvalidDataType as InvalidDataType16,\n  InvalidSecp256k1PrivateKey as InvalidSecp256k1PrivateKey4,\n  InvalidSecp256k1Signature as InvalidSecp256k1Signature2,\n  InvalidTransactionField,\n  NotDelegatedTransaction,\n  UnavailableTransactionField\n} from \"@vechain/sdk-errors\";\nvar Transaction = class _Transaction {\n  /**\n   * Represent the block reference length in bytes.\n   */\n  static BLOCK_REF_LENGTH = 8;\n  /**\n   * A collection of constants used for gas calculations in transactions.\n   *\n   * Properties\n   * - `TX_GAS` - The base gas cost for a transaction.\n   * - `CLAUSE_GAS` - The gas cost for executing a clause in a transaction.\n   * - `CLAUSE_GAS_CONTRACT_CREATION` - The gas cost for creating a contract via a clause.\n   * - `ZERO_GAS_DATA` - The gas cost for transmitting zero bytes of data.\n   * - `NON_ZERO_GAS_DATA` - The gas cost for transmitting non-zero bytes of data.\n   */\n  static GAS_CONSTANTS = {\n    TX_GAS: 5000n,\n    CLAUSE_GAS: 16000n,\n    CLAUSE_GAS_CONTRACT_CREATION: 48000n,\n    ZERO_GAS_DATA: 4n,\n    NON_ZERO_GAS_DATA: 68n\n  };\n  /**\n   * RLP_FIELDS is an array of objects that defines the structure and encoding scheme\n   * for various components in a transaction using Recursive Length Prefix (RLP) encoding.\n   * Each object in the array represents a field in the transaction, specifying its name and kind.\n   * The `kind` attribute is an instance of an RLP coder that determines how the field is encoded.\n   *\n   * Properties\n   * - `chainTag` - Represent the id of the chain the transaction is sent to.\n   * - `blockRef` - Represent the last block of the chain the transaction is sent to.\n   * - `expiration` -  Represent the expiration date of the transaction.\n   * - `clauses` - List of clause objects, each containing:\n   *   - `to` - Represent the destination of the transaction.\n   *   - `value` - Represent the 'wei' quantity (VET or VTHO) value the transaction is worth.\n   *   - `data` - Represent the content of the transaction.\n   * - `gasPriceCoef` - Represent the gas price coefficient of the transaction.\n   * - `gas` - Represent the gas limit of the transaction.\n   * - `dependsOn` - Represent the hash of the transaction the current transaction depends on.\n   * - `nonce` - Represent the nonce of the transaction.\n   * - `reserved` -  Reserved field.\n   */\n  static RLP_FIELDS = [\n    { name: \"chainTag\", kind: new NumericKind(1) },\n    { name: \"blockRef\", kind: new CompactFixedHexBlobKind(8) },\n    { name: \"expiration\", kind: new NumericKind(4) },\n    {\n      name: \"clauses\",\n      kind: {\n        item: [\n          {\n            name: \"to\",\n            kind: new OptionalFixedHexBlobKind(20)\n          },\n          { name: \"value\", kind: new NumericKind(32) },\n          { name: \"data\", kind: new HexBlobKind() }\n        ]\n      }\n    },\n    { name: \"gasPriceCoef\", kind: new NumericKind(1) },\n    { name: \"gas\", kind: new NumericKind(8) },\n    { name: \"dependsOn\", kind: new OptionalFixedHexBlobKind(32) },\n    { name: \"nonce\", kind: new NumericKind(8) },\n    { name: \"reserved\", kind: { item: new BufferKind() } }\n  ];\n  /**\n   * Represent the Recursive Length Prefix (RLP) of the transaction features.\n   *\n   * Properties\n   * - `name` - A string indicating the name of the field in the RLP structure.\n   * - `kind` - RLP profile type.\n   */\n  static RLP_FEATURES = {\n    name: \"reserved.features\",\n    kind: new NumericKind(4)\n  };\n  /**\n   * Represents a Recursive Length Prefix (RLP) of the transaction signature.\n   *\n   * Properties\n   * - `name` - A string indicating the name of the field in the RLP structure.\n   * - `kind` - RLP profile type.\n   */\n  static RLP_SIGNATURE = {\n    name: \"signature\",\n    kind: new BufferKind()\n  };\n  /**\n   * Represents a Recursive Length Prefix (RLP) of the signed transaction.\n   *\n   * Properties\n   * - `name` - A string indicating the name of the field in the RLP structure.\n   * - `kind` - RLP profile type.\n   */\n  static RLP_SIGNED_TRANSACTION_PROFILE = {\n    name: \"tx\",\n    kind: _Transaction.RLP_FIELDS.concat([_Transaction.RLP_SIGNATURE])\n  };\n  /**\n   * Represents a Recursive Length Prefix (RLP) of the unsigned transaction.\n   *\n   * Properties\n   * - `name` - A string indicating the name of the field in the RLP structure.\n   * - `kind` - RLP profile type.\n   */\n  static RLP_UNSIGNED_TRANSACTION_PROFILE = {\n    name: \"tx\",\n    kind: _Transaction.RLP_FIELDS\n  };\n  /**\n   * It represents the content of the transaction.\n   */\n  body;\n  /**\n   * It represents the signature of the transaction content.\n   */\n  signature;\n  /**\n   * Creates a new instance of the class with the specified transaction body and optional signature.\n   *\n   * @param {TransactionBody} body The transaction body to be used.\n   * @param {Uint8Array} [signature] The optional signature for the transaction.\n   */\n  constructor(body, signature) {\n    this.body = body;\n    this.signature = signature;\n  }\n  // ********** GET COMPUTED PROPERTIES **********\n  /**\n   * Get the delegator's address if the transaction is delegated.\n   *\n   * If the transaction is delegated and a signature is available, this method recovers\n   * the delegator parameter from the signature and subsequently recovers the delegator's public key\n   * to derive the delegator's address.\n   *\n   * @return {Address} The address of the delegator.\n   * @throws {UnavailableTransactionField} If the transaction is delegated but the signature is missing.\n   * @throws {NotDelegatedTransaction} If the transaction is not delegated.\n   *\n   * @remarks Security auditable method, depends on\n   * - {@link Address.ofPublicKey};\n   * - {@link Secp256k1.recover};\n   * - {@link Transaction.getSignatureHash}.\n   */\n  get delegator() {\n    if (this.isDelegated) {\n      if (this.signature !== void 0) {\n        const delegator = this.signature.slice(\n          Secp256k1.SIGNATURE_LENGTH,\n          this.signature.length\n        );\n        const delegatorPublicKey = Secp256k1.recover(\n          this.getSignatureHash(this.origin).bytes,\n          delegator\n        );\n        return Address.ofPublicKey(delegatorPublicKey);\n      }\n      throw new UnavailableTransactionField(\n        \"Transaction.delegator()\",\n        \"missing delegator\",\n        { fieldName: \"delegator\" }\n      );\n    }\n    throw new NotDelegatedTransaction(\n      \"Transaction.delegator()\",\n      \"not delegated transaction\",\n      void 0\n    );\n  }\n  /**\n   * Get the encoded bytes as a Uint8Array.\n   * The encoding is determined by whether the data is signed.\n   *\n   * @return {Uint8Array} The encoded byte array.\n   *\n   * @see decode\n   */\n  get encoded() {\n    return this.encode(this.isSigned);\n  }\n  /**\n   * Get transaction ID.\n   *\n   * The ID is the Blake2b256 hash of the transaction's signature\n   * concatenated with the origin's address.\n   * If the transaction is not signed,\n   * it throws an UnavailableTransactionField error.\n   *\n   * @return {Blake2b256} The concatenated hash of the signature\n   * and origin if the transaction is signed.\n   * @throws {UnavailableTransactionField} If the transaction is not signed.\n   *\n   * @remarks Security auditable method, depends on\n   * - {@link Blake2b256.of}\n   */\n  get id() {\n    if (this.isSigned) {\n      return Blake2b256.of(\n        nc_utils6.concatBytes(\n          this.getSignatureHash().bytes,\n          this.origin.bytes\n        )\n      );\n    }\n    throw new UnavailableTransactionField(\n      \"Transaction.id()\",\n      \"not signed transaction: id unavailable\",\n      { fieldName: \"id\" }\n    );\n  }\n  /**\n   * Return the intrinsic gas required for this transaction.\n   *\n   * @return {VTHO} The computed intrinsic gas for the transaction.\n   */\n  get intrinsicGas() {\n    return _Transaction.intrinsicGas(this.body.clauses);\n  }\n  /**\n   * Returns `true` if the transaction is delegated, otherwise `false`.\n   *\n   * @return {boolean} `true` if the transaction is delegated,\n   * otherwise `false`.\n   */\n  get isDelegated() {\n    return _Transaction.isDelegated(this.body);\n  }\n  /**\n   * Return `true` if the signature is defined, otherwise `false`.\n   *\n   * @return {boolean} return `true` if the signature is defined, otherwise `false`.\n   */\n  get isSigned() {\n    return this.signature !== void 0;\n  }\n  /**\n   * Return the origin address of the transaction.\n   *\n   * The origin is determined by recovering the public key from the transaction's signature.\n   *\n   * @return {Address} The address derived from the public key of the transaction's signer.\n   * @throws {UnavailableTransactionField} If the transaction is not signed, an exception is thrown indicating the absence of the origin field.\n   *\n   * @remarks Security auditable method, depends on\n   * - {@link Address.ofPublicKey};\n   * - {@link Secp256k1.recover}.\n   */\n  get origin() {\n    if (this.signature !== void 0) {\n      return Address.ofPublicKey(\n        // Get the origin public key.\n        Secp256k1.recover(\n          this.getSignatureHash().bytes,\n          // Get the (r, s) of ECDSA digital signature without delegator params.\n          this.signature.slice(0, Secp256k1.SIGNATURE_LENGTH)\n        )\n      );\n    }\n    throw new UnavailableTransactionField(\n      \"Transaction.origin()\",\n      \"not signed transaction, no origin\",\n      { fieldName: \"origin\" }\n    );\n  }\n  // ********** PUBLIC METHODS **********\n  /**\n   * Decodes a raw transaction byte array into a new Transaction object.\n   *\n   * @param {Uint8Array} rawTransaction - The raw transaction bytes to decode.\n   * @param {boolean} isSigned - Flag indicating if the transaction is signed.\n   * @return {Transaction} The decoded transaction object.\n   *\n   * @see encoded\n   */\n  static decode(rawTransaction, isSigned) {\n    const profile = isSigned ? _Transaction.RLP_SIGNED_TRANSACTION_PROFILE : _Transaction.RLP_UNSIGNED_TRANSACTION_PROFILE;\n    const decodedRLPBody = RLPProfiler.ofObjectEncoded(\n      rawTransaction,\n      profile\n    ).object;\n    const bodyWithoutReservedField = {\n      blockRef: decodedRLPBody.blockRef,\n      chainTag: decodedRLPBody.chainTag,\n      clauses: decodedRLPBody.clauses,\n      dependsOn: decodedRLPBody.dependsOn,\n      expiration: decodedRLPBody.expiration,\n      gas: decodedRLPBody.gas,\n      gasPriceCoef: decodedRLPBody.gasPriceCoef,\n      nonce: decodedRLPBody.nonce\n    };\n    const correctTransactionBody = decodedRLPBody.reserved.length > 0 ? {\n      ...bodyWithoutReservedField,\n      reserved: _Transaction.decodeReservedField(\n        decodedRLPBody.reserved\n      )\n    } : bodyWithoutReservedField;\n    return decodedRLPBody.signature !== void 0 ? _Transaction.of(\n      correctTransactionBody,\n      decodedRLPBody.signature\n    ) : _Transaction.of(correctTransactionBody);\n  }\n  /**\n   * Computes the signature hash, optionally incorporating a delegator's address.\n   *\n   * @param {Address} [delegator] - Optional delegator's address to include in the hash computation.\n   * @return {Blake2b256} - The computed signature hash.\n   *\n   * @remarks\n   * `delegator` is used to sign a transaction on behalf of another account.\n   *\n   * @remarks Security auditable method, depends on\n   * - {@link Blake2b256.of}.\n   */\n  getSignatureHash(delegator) {\n    const txHash = Blake2b256.of(this.encode(false));\n    if (delegator !== void 0) {\n      return Blake2b256.of(\n        nc_utils6.concatBytes(txHash.bytes, delegator.bytes)\n      );\n    }\n    return txHash;\n  }\n  /**\n   * Calculates the intrinsic gas required for the given transaction clauses.\n   *\n   * @param {TransactionClause[]} clauses - An array of transaction clauses to calculate the intrinsic gas for.\n   * @return {VTHO} The total intrinsic gas required for the provided clauses.\n   * @throws {InvalidDataType} If clauses have invalid data as invalid addresses.\n   */\n  static intrinsicGas(clauses) {\n    if (clauses.length > 0) {\n      return VTHO.of(\n        clauses.reduce((sum, clause) => {\n          if (clause.to !== null) {\n            if (!Address.isValid(clause.to) && !clause.to.includes(\".\"))\n              throw new InvalidDataType16(\n                \"Transaction.intrinsicGas\",\n                \"invalid data type in clause: each `to` field must be a valid address.\",\n                { clause }\n              );\n            sum += _Transaction.GAS_CONSTANTS.CLAUSE_GAS;\n          } else {\n            sum += _Transaction.GAS_CONSTANTS.CLAUSE_GAS_CONTRACT_CREATION;\n          }\n          sum += _Transaction.computeUsedGasFor(clause.data);\n          return sum;\n        }, _Transaction.GAS_CONSTANTS.TX_GAS),\n        0 /* wei */\n      );\n    }\n    return VTHO.of(\n      _Transaction.GAS_CONSTANTS.TX_GAS + _Transaction.GAS_CONSTANTS.CLAUSE_GAS,\n      0 /* wei */\n    );\n  }\n  /**\n   * Return `true` if the transaction body is valid, `false` otherwise.\n   *\n   * @param {TransactionBody} body - The transaction body to validate.\n   * @return {boolean} `true` if the transaction body is valid, `false` otherwise.\n   */\n  static isValidBody(body) {\n    return (\n      // Chain tag\n      body.chainTag !== void 0 && body.chainTag >= 0 && body.chainTag <= 255 && // Block reference\n      body.blockRef !== void 0 && Hex.isValid0x(body.blockRef) && HexUInt.of(body.blockRef).bytes.length === _Transaction.BLOCK_REF_LENGTH && // Expiration\n      body.expiration !== void 0 && // Clauses\n      body.clauses !== void 0 && // Gas price coef\n      body.gasPriceCoef !== void 0 && // Gas\n      body.gas !== void 0 && // Depends on\n      body.dependsOn !== void 0 && // Nonce\n      body.nonce !== void 0\n    );\n  }\n  /**\n   * Creates a new Transaction instance if the provided body and optional\n   * signature are valid.\n   *\n   * @param {TransactionBody} body - The transaction body to be validated.\n   * @param {Uint8Array} [signature] - Optional signature to be validated.\n   * @return {Transaction} A new Transaction instance if validation is successful.\n   * @throws {InvalidSecp256k1Signature} If the provided signature is invalid.\n   * @throws {InvalidTransactionField} If the provided body is invalid.\n   */\n  static of(body, signature) {\n    if (_Transaction.isValidBody(body)) {\n      if (signature === void 0 || _Transaction.isSignatureValid(body, signature)) {\n        return new _Transaction(body, signature);\n      }\n      throw new InvalidSecp256k1Signature2(\n        \"Transaction.of\",\n        \"invalid signature\",\n        { signature }\n      );\n    }\n    throw new InvalidTransactionField(\"Transaction.of\", \"invalid body\", {\n      fieldName: \"body\",\n      body\n    });\n  }\n  /**\n   * Signs the transaction using the provided private key.\n   *\n   * @param {Uint8Array} signerPrivateKey - The private key used to sign the transaction.\n   * @return {Transaction} The signed transaction.\n   * @throws {InvalidTransactionField} If attempting to sign a delegated transaction.\n   * @throws {InvalidSecp256k1PrivateKey} If the provided private key is not valid.\n   *\n   * @remarks Security auditable method, depends on\n   * - {@link Secp256k1.isValidPrivateKey};\n   * - {@link Secp256k1.sign}.\n   */\n  sign(signerPrivateKey) {\n    if (Secp256k1.isValidPrivateKey(signerPrivateKey)) {\n      if (!this.isDelegated) {\n        const signature = Secp256k1.sign(\n          this.getSignatureHash().bytes,\n          signerPrivateKey\n        );\n        return _Transaction.of(this.body, signature);\n      }\n      throw new InvalidTransactionField(\n        `Transaction.sign`,\n        \"delegated transaction: use signWithDelegator method\",\n        { fieldName: \"delegator\", body: this.body }\n      );\n    }\n    throw new InvalidSecp256k1PrivateKey4(\n      `Transaction.sign`,\n      \"invalid private key: ensure it is a secp256k1 key\",\n      void 0\n    );\n  }\n  /**\n   * Signs the transaction using both the signer and the delegator private keys.\n   *\n   * @param {Uint8Array} signerPrivateKey - The private key of the signer.\n   * @param {Uint8Array} delegatorPrivateKey - The private key of the delegator.\n   * @return {Transaction} A new transaction with the concatenated signatures\n   * of the signer and the delegator.\n   * @throws {InvalidSecp256k1PrivateKey} - If either the signer or delegator private key is invalid.\n   * @throws {NotDelegatedTransaction} - If the transaction is not delegated.\n   *\n   * @remarks Security auditable method, depends on\n   * - {@link Address.ofPublicKey}\n   * - {@link Secp256k1.isValidPrivateKey};\n   * - {@link Secp256k1.sign}.\n   */\n  signWithDelegator(signerPrivateKey, delegatorPrivateKey) {\n    if (Secp256k1.isValidPrivateKey(signerPrivateKey)) {\n      if (Secp256k1.isValidPrivateKey(delegatorPrivateKey)) {\n        if (this.isDelegated) {\n          const transactionHash = this.getSignatureHash().bytes;\n          const delegatedHash = this.getSignatureHash(\n            Address.ofPublicKey(\n              Secp256k1.derivePublicKey(signerPrivateKey)\n            )\n          ).bytes;\n          return _Transaction.of(\n            this.body,\n            nc_utils6.concatBytes(\n              Secp256k1.sign(transactionHash, signerPrivateKey),\n              Secp256k1.sign(delegatedHash, delegatorPrivateKey)\n            )\n          );\n        }\n        throw new NotDelegatedTransaction(\n          \"Transaction.signWithDelegator\",\n          \"not delegated transaction: use sign method\",\n          void 0\n        );\n      }\n      throw new InvalidSecp256k1PrivateKey4(\n        `Transaction.signWithDelegator`,\n        \"invalid delegator private: ensure it is a secp256k1 key\",\n        void 0\n      );\n    }\n    throw new InvalidSecp256k1PrivateKey4(\n      `Transaction.signWithDelegator`,\n      \"invalid signer private key: ensure it is a secp256k1 key\",\n      void 0\n    );\n  }\n  // ********** PRIVATE FUNCTIONS **********\n  /**\n   * Computes the amount of gas used for the given data.\n   *\n   * @param {string} data - The hexadecimal string data for which the gas usage is computed.\n   * @return {bigint} The total gas used for the provided data.\n   * @throws {InvalidDataType} If the data is not a valid hexadecimal string.\n   *\n   * @remarks gas value is expressed in {@link Units.wei} unit.\n   */\n  static computeUsedGasFor(data) {\n    if (data !== \"\" && !Hex.isValid(data))\n      throw new InvalidDataType16(\n        \"calculateDataUsedGas()\",\n        `Invalid data type for gas calculation. Data should be a hexadecimal string.`,\n        { data }\n      );\n    let sum = 0n;\n    for (let i = 2; i < data.length; i += 2) {\n      if (data.substring(i, i + 2) === \"00\") {\n        sum += _Transaction.GAS_CONSTANTS.ZERO_GAS_DATA;\n      } else {\n        sum += _Transaction.GAS_CONSTANTS.NON_ZERO_GAS_DATA;\n      }\n    }\n    return sum;\n  }\n  /**\n   * Decodes the {@link TransactionBody.reserved} field from the given buffer array.\n   *\n   * @param {Buffer[]} reserved  - An array of Uint8Array objects representing the reserved field data.\n   * @return {Object} An object containing the decoded features and any unused buffer data.\n   * @return {number} [return.features] The decoded features from the reserved field.\n   * @return {Buffer[]} [return.unused] An array of Buffer objects representing unused data, if any.\n   * @throws {InvalidTransactionField} Thrown if the reserved field is not properly trimmed.\n   */\n  static decodeReservedField(reserved) {\n    if (reserved[reserved.length - 1].length > 0) {\n      const featuresField = _Transaction.RLP_FEATURES.kind.buffer(reserved[0], _Transaction.RLP_FEATURES.name).decode();\n      return reserved.length > 1 ? {\n        features: featuresField,\n        unused: reserved.slice(1)\n      } : { features: featuresField };\n    }\n    throw new InvalidTransactionField(\n      \"Transaction.decodeReservedField\",\n      \"invalid reserved field: fields in the `reserved` property must be properly trimmed\",\n      { fieldName: \"reserved\", reserved }\n    );\n  }\n  /**\n   * Encodes the transaction body using RLP encoding.\n   *\n   * @param {boolean} isSigned - Indicates whether the transaction is signed.\n   * @return {Uint8Array} The RLP encoded transaction body.\n   *\n   * @see encoded\n   */\n  encode(isSigned) {\n    return this.encodeBodyField(\n      {\n        // Existing body and the optional `reserved` field if present.\n        ...this.body,\n        /*\n         * The `body.clauses` property is already an array,\n         * albeit TypeScript realize, hence cast is needed\n         * otherwise encodeObject will throw an error.\n         */\n        clauses: this.body.clauses,\n        // New reserved field.\n        reserved: this.encodeReservedField()\n      },\n      isSigned\n    );\n  }\n  /**\n   * Encodes the given transaction body into a Uint8Array, depending on whether\n   * the transaction is signed or not.\n   *\n   * @param body - The transaction object adhering to the RLPValidObject structure.\n   * @param isSigned - A boolean indicating if the transaction is signed.\n   * @return A Uint8Array representing the encoded transaction.\n   *\n   * @see encoded\n   */\n  encodeBodyField(body, isSigned) {\n    if (isSigned) {\n      return RLPProfiler.ofObject(\n        {\n          ...body,\n          signature: Uint8Array.from(this.signature)\n        },\n        _Transaction.RLP_SIGNED_TRANSACTION_PROFILE\n      ).encoded;\n    }\n    return RLPProfiler.ofObject(\n      body,\n      _Transaction.RLP_UNSIGNED_TRANSACTION_PROFILE\n    ).encoded;\n  }\n  /**\n   * Encodes the {@link TransactionBody.reserved} field data for a transaction.\n   *\n   * @return {Uint8Array[]} The encoded list of reserved features.\n   * It removes any trailing unused features that have zero length from the list.\n   *\n   * @remarks The {@link TransactionBody.reserved} is optional, albeit\n   * is required to perform RLP encoding.\n   *\n   * @see encode\n   */\n  encodeReservedField() {\n    const reserved = this.body.reserved ?? {};\n    const featuresKind = _Transaction.RLP_FEATURES.kind;\n    const featuresList = [\n      featuresKind.data(reserved.features ?? 0, _Transaction.RLP_FEATURES.name).encode(),\n      ...reserved.unused ?? []\n    ];\n    while (featuresList.length > 0) {\n      if (featuresList[featuresList.length - 1].length === 0) {\n        featuresList.pop();\n      } else {\n        break;\n      }\n    }\n    return featuresList;\n  }\n  /**\n   * Return `true` if the transaction is delegated, else `false`.\n   *\n   * @param {TransactionBody} body - The transaction body.\n   * @return {boolean} `true` if the transaction is delegated, else `false`.\n   */\n  static isDelegated(body) {\n    const reserved = body.reserved ?? {};\n    const features = reserved.features ?? 0;\n    return (features & 1) === 1;\n  }\n  /**\n   * Return Returns true if the signature is valid, otherwise false.\n   *\n   * @param {TransactionBody} body - The transaction body to be checked.\n   * @param {Uint8Array} signature - The signature to validate.\n   * @return {boolean} - Returns true if the signature is valid, otherwise false.\n   */\n  static isSignatureValid(body, signature) {\n    const expectedSignatureLength = this.isDelegated(body) ? Secp256k1.SIGNATURE_LENGTH * 2 : Secp256k1.SIGNATURE_LENGTH;\n    return signature.length === expectedSignatureLength;\n  }\n};\n\n// src/utils/const/network.ts\nvar VECHAIN_MAINNET_CHAIN_TAG = 74;\nvar VECHAIN_TESTNET_CHAIN_TAG = 39;\nvar VECHAIN_SOLO_CHAIN_TAG = 246;\nvar ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\";\nvar VTHO_ADDRESS = \"0x0000000000000000000000000000456e65726779\";\nvar mainnetGenesisBlock = {\n  number: 0,\n  id: \"0x00000000851caf3cfdb6e899cf5958bfb1ac3413d346d43539627e6be7ec1b4a\",\n  size: 170,\n  parentID: \"0xffffffff53616c757465202620526573706563742c20457468657265756d2100\",\n  timestamp: 1530316800,\n  gasLimit: 1e7,\n  beneficiary: \"0x0000000000000000000000000000000000000000\",\n  gasUsed: 0,\n  totalScore: 0,\n  txsRoot: \"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0\",\n  txsFeatures: 0,\n  stateRoot: \"0x09bfdf9e24dd5cd5b63f3c1b5d58b97ff02ca0490214a021ed7d99b93867839c\",\n  receiptsRoot: \"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0\",\n  signer: \"0x0000000000000000000000000000000000000000\",\n  isTrunk: true,\n  transactions: []\n};\nvar testnetGenesisBlock = {\n  number: 0,\n  id: \"0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127\",\n  size: 170,\n  parentID: \"0xffffffff00000000000000000000000000000000000000000000000000000000\",\n  timestamp: 1530014400,\n  gasLimit: 1e7,\n  beneficiary: \"0x0000000000000000000000000000000000000000\",\n  gasUsed: 0,\n  totalScore: 0,\n  txsRoot: \"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0\",\n  txsFeatures: 0,\n  stateRoot: \"0x4ec3af0acbad1ae467ad569337d2fe8576fe303928d35b8cdd91de47e9ac84bb\",\n  receiptsRoot: \"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0\",\n  signer: \"0x0000000000000000000000000000000000000000\",\n  isTrunk: true,\n  transactions: []\n};\nvar soloGenesisBlock = {\n  number: 0,\n  id: \"0x00000000c05a20fbca2bf6ae3affba6af4a74b800b585bf7a4988aba7aea69f6\",\n  size: 170,\n  parentID: \"0xffffffff00000000000000000000000000000000000000000000000000000000\",\n  timestamp: 15264e5,\n  gasLimit: 1e7,\n  beneficiary: \"0x0000000000000000000000000000000000000000\",\n  gasUsed: 0,\n  totalScore: 0,\n  txsRoot: \"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0\",\n  txsFeatures: 0,\n  stateRoot: \"0x93de0ffb1f33bc0af053abc2a87c4af44594f5dcb1cb879dd823686a15d68550\",\n  receiptsRoot: \"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0\",\n  signer: \"0x0000000000000000000000000000000000000000\",\n  isTrunk: true,\n  transactions: []\n};\nvar MAINNET_NETWORK = {\n  genesisBlock: mainnetGenesisBlock,\n  chainTag: VECHAIN_MAINNET_CHAIN_TAG\n};\nvar TESTNET_NETWORK = {\n  genesisBlock: testnetGenesisBlock,\n  chainTag: VECHAIN_TESTNET_CHAIN_TAG\n};\nvar SOLO_NETWORK = {\n  genesisBlock: soloGenesisBlock,\n  chainTag: VECHAIN_SOLO_CHAIN_TAG\n};\nvar networkInfo = {\n  mainnet: MAINNET_NETWORK,\n  testnet: TESTNET_NETWORK,\n  solo: SOLO_NETWORK\n};\nexport {\n  ABIContract,\n  ABIEvent,\n  ABIFunction,\n  ABIItem,\n  Account,\n  Address,\n  Blake2b256,\n  BloomFilter,\n  BufferKind,\n  Certificate,\n  Clause,\n  Coin,\n  CompactFixedHexBlobKind,\n  ERC1155_ABI,\n  ERC20_ABI,\n  ERC721_ABI,\n  FixedHexBlobKind,\n  FixedPointNumber,\n  HDKey2 as HDKey,\n  Hex,\n  HexBlobKind,\n  HexInt,\n  HexUInt,\n  Keccak256,\n  MAINNET_NETWORK,\n  Mnemonic,\n  NUMERIC_REGEX,\n  NumericKind,\n  OptionalFixedHexBlobKind,\n  Quantity,\n  RLP,\n  RLPProfiler,\n  Revision,\n  SOLO_NETWORK,\n  ScalarKind,\n  Secp256k1,\n  Sha256,\n  TESTNET_NETWORK,\n  ThorId,\n  Transaction,\n  Txt,\n  Units,\n  VET,\n  VIP180_ABI,\n  VIP181_ABI,\n  VIP210_ABI,\n  VTHO,\n  VTHO_ADDRESS,\n  ZERO_ADDRESS,\n  ZERO_BYTES,\n  ethersAbi as abi,\n  addressUtils,\n  assertCompactFixedHexBlobBuffer,\n  assertFixedHexBlobKindBuffer,\n  assertFixedHexBlobKindData,\n  assertValidHexBlobKindData,\n  assertValidNumericKindBuffer,\n  blake2b256,\n  core_exports as core,\n  dataUtils,\n  decodeBufferToHexWithLeadingZeros,\n  decodeBufferToNumberOrHex,\n  encodeBigIntToBuffer,\n  encodeCompactFixedHexBlob,\n  keccak256,\n  keystore3 as keystore,\n  mnemonic,\n  networkInfo,\n  revisionUtils,\n  sha2562 as sha256,\n  validateNumericKindData,\n  ethers2 as vechain_sdk_core_ethers\n};\n"],"names":["__defProp","Object","defineProperty","target","all","name","get","enumerable","__export","ABIContract","ABIEvent","ABIFunction","ABIItem","Account","Address","Blake2b256","BloomFilter","BufferKind","Certificate","Clause","Coin","CompactFixedHexBlobKind","ERC1155_ABI","ERC20_ABI","ERC721_ABI","FixedHexBlobKind","FixedPointNumber","HDKey","HDKey2","Hex","HexBlobKind","HexInt","HexUInt","Keccak256","MAINNET_NETWORK","Mnemonic","NUMERIC_REGEX","NumericKind","OptionalFixedHexBlobKind","Quantity","RLP","RLPProfiler","Revision","SOLO_NETWORK","ScalarKind","Secp256k1","Sha256","TESTNET_NETWORK","ThorId","Transaction","Txt","Units","VET","VIP180_ABI","VIP181_ABI","VIP210_ABI","VTHO","VTHO_ADDRESS","ZERO_ADDRESS","ZERO_BYTES","abi","ethersAbi","addressUtils","assertCompactFixedHexBlobBuffer","assertFixedHexBlobKindBuffer","assertFixedHexBlobKindData","assertValidHexBlobKindData","assertValidNumericKindBuffer","blake2b256","dataUtils","decodeBufferToHexWithLeadingZeros","decodeBufferToNumberOrHex","encodeBigIntToBuffer","encodeCompactFixedHexBlob","keccak256","keystore","keystore3","mnemonic","networkInfo","revisionUtils","sha256","sha2562","validateNumericKindData","vechain_sdk_core_ethers","_Hex","static","digits","sign","constructor","normalize","digits2","toLowerCase","this","abs","POSITIVE","bi","BigInt","bytes","alignToBytes","n","isNumber","DataView","buffer","getFloat64","hex","toString","length","compareTo","that","Math","max","thisBytes","fit","thatBytes","i","compareByte","cue","at","slice","repeat","isEqual","isValid","exp","REGEX_HEX","test","isValid0x","REGEX_HEX_PREFIX","of","Uint8Array","NEGATIVE","dataView","ArrayBuffer","setFloat64","startsWith","e","random","ABI","_ABI","types","values","forEach","type","index","value","data","toHex","error","ofEncoded","dataEncoded","hexDataEncoded","parsedAbiParams","parseObjectValues","obj","recursiveParse","currentObj","currentValues","key","prototype","hasOwnProperty","call","push","getFirstDecodedValue","abiParametersEncoded","encode","format","replace","encodeParams","stringTypes","map","typesParam","join","decode","signature","stringSignature","super","ofSignature","ABIItemConstructor","formatType","JSON","stringify","signatureHash","localeCompare","_ABIEvent","abiEvent","parseLog","eventData","topics","topic","Array","isArray","t","decodeEventLog","event","decodeEventLogAsArray","rawDecodedData","args","encodeEventLog","dataToEncode","encodeFilterTopics","dataTypes","dataValues","inputs","param","indexed","valuesToEncode","encodeFilterTopicsNoNull","abiFunction","substring","decodeData","encodeData","decodeResult","decodeOutputAsArray","resultDecoded","outputs","_ABIContract","ofAbi","ofStringAbi","getFunction","functionAbiItem","getEvent","eventAbiItem","encodeFunctionInput","functionName","functionData","decodeFunctionInput","encodedFunctionInput","decodeFunctionOutput","encodedFunctionOutput","eventName","eventArgs","eventToDecode","dataToDecode","parseLogAsArray","eventLogDecoded","address","balance","transactions","addTransaction","transaction","typeDiff","addressDiff","codeDiff","code","_HexInt","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","isInteger","hex2","_HexUInt","REGEX_HEXUINT","hint","_Txt","String","TextDecoder","TextEncoder","NFC","txt","ENCODER","valueOf","DECODER","_Keccak256","hash2","returnType","_FixedPointNumber","NaN","NEGATIVE_INFINITY","POSITIVE_INFINITY","ef","fd","sv","isFinite","isNaN","isNegativeInfinite","isPositiveInfinite","isZero","delta","dp","comparedTo","div","isInfinite","isPositive","ZERO","isNegative","dividend","divisor","decimalPlaces","fp","dd","eq","gt","cmp","gte","idiv","isIntegerExpression","REGEX_INTEGER","isNaturalExpression","REGEX_NATURAL","isNumberExpression","REGEX_NUMBER","lt","lte","minus","modulo","mul","multiplicand","multiplicator","negated","DEFAULT_FRACTIONAL_DECIMALS","txtToSV","plus","pow","base","exponent","sf","sqr","RangeError","iteration","actualResult","storedResult","sqrt","times","decimalSeparator","padded","padStart","decimals","integers","integersShow","decimalsShow","trimEnd","str","sub","endsWith","fc","charAt","di","lastIndexOf","ie","fe","_Sha256","_Secp256k1","compressPublicKey","publicKey","UNCOMPRESS_PREFIX","x","y","isYOdd","COMPRESSED_PREFIX","derivePublicKey","privateKey","isCompressed","isValidPrivateKey","getPublicKey","generatePrivateKey","utils","randomPrivateKey","cryptoKey","global","crypto","subtle","generateKey","rawKey","exportKey","inflatePublicKey","ProjectivePoint","fromAffine","fromHex","toAffine","toRawBytes","isValidMessageHash","VALID_HASH_LENGTH","randomBytes","bytesLength","getRandomValues","recover","messageHash","sig","SIGNATURE_LENGTH","recovery","Signature","fromCompact","addRecoveryBit","recoverPublicKey","r","s","fromMnemonic","words","path","VET_DERIVATION_PATH","master","fromMasterSeed","derive","derivationPath","fromPrivateKey","chainCode","header","EXTENDED_PRIVATE_KEY_PREFIX","fill","checksum","subarray","expandedPrivateKey","fromExtendedKey","fromPublicKey","EXTENDED_PUBLIC_KEY_PREFIX","expandedPublicKey","isDerivationPathComponentValid","component","isDerivationPathValid","pathComponents","split","_Address","huint","stringAddress","parseInt","toUpperCase","addressChecksummed","ofPrivateKey","ofPublicKey","publicKeyInflated","publicKeyHash","ofMnemonic","mnemonic2","root","isAddress","addressToVerify","toERC55Checksum","_Blake2b256","create","dkLen","update","digest","_BloomFilter","k","contains","distribute","hash","byteLength","bit","computeBestBitsPerKey","ceil","computeBestHashFunctionsQuantity","m","floor","isJoinable","other","byte","keys","builder","BloomFilterBuilder","add","_BloomFilterBuilder","hashMap","Map","set","build","DEFAULT_K","nBytes","size","bits","nBits","UINT32_LIMIT","collision","bitPos","_code","_value","Units2","formatUnits","wei","unit","fpn","parseUnits","formatEther","parseEther","ether","_VET","WEI_FD","CODE","_VTHO","_RLP","encoded","decoded","context","encodedData","packData","profile","kind","item","part","unpackData","packed","parts","reduce","profile2","_RLPProfiler","ofObject","validObject","packedData","ofObjectEncoded","object","_validateNumericKindNumber","_validateNumericKindString","num","isSafeInteger","isHexUInt","isDecimal","buf","maxBytes","from","zeroIndex","findIndex","dataBI","_context","encoder","decoder","_Mnemonic","_that","wordsNoToStrength","numberOfWords","toPrivateKey","wordlistSize","randomGenerator","strength","numberOfBytes","wordsToValidate","deriveAddress","derivePrivateKey","generate","_Quantity","_Revision","REGEX_DECIMAL_REVISION","isRevisionAccount","revision","isRevisionBlock","_ThorId","DIGITS","REGEX_HEXUINT_PREFIX","_Certificate","purpose","payload","domain","timestamp","signer","isSigned","certifiable","verify","certificate","SCRYPT_PARAMS","keystore4","encrypt","async","password","keystoreAccount","encryptOptions","scrypt","N","p","keystoreJsonString","parse","decrypt","KEYSTORE_CRYPTO_CIPHER","KEYSTORE_CRYPTO_PARAMS_DKLEN","KEYSTORE_CRYPTO_KDF","KEYSTORE_VERSION","SCRYPT_PARAMS2","uuidV4","keystore2","cipher","kdf","keyDerivationFunction","version","salt","kdfparams","dklen","decodeScryptParams","ciphertext","mac","cipherparams","iv","keystoreAddress","decryptKeystore","options","encodeScryptParams","uuidRandom","uuid","macPrefix","id","encryptKeystore","copy","EXPERIMENTAL_CRYPTOGRAPHY","log","title","messages","useExperimentalCryptography","experimentalCryptography","stateMutability","internalType","anonymous","decodeBytes32String","valueInBytes","firstZeroIndex","firstNotZeroIndex","encodeBytes32String","zeroPadding","pad","_Clause","PREFIX","to","comment","amount","callFunction","contractAddress","functionAbi","clauseOptions","RADIX","includeABI","FORMAT_TYPE","deployContract","contractBytecode","deployParams","NO_VALUE","transferNFT","senderAddress","recipientAddress","tokenId","TRANSFER_NFT_FUNCTION","transferToken","tokenAddress","TRANSFER_TOKEN_FUNCTION","transferVET","NO_DATA","_Transaction","TX_GAS","CLAUSE_GAS","CLAUSE_GAS_CONTRACT_CREATION","ZERO_GAS_DATA","NON_ZERO_GAS_DATA","RLP_FIELDS","concat","RLP_SIGNATURE","body","delegator","isDelegated","delegatorPublicKey","getSignatureHash","origin","fieldName","intrinsicGas","clauses","rawTransaction","RLP_SIGNED_TRANSACTION_PROFILE","RLP_UNSIGNED_TRANSACTION_PROFILE","decodedRLPBody","bodyWithoutReservedField","blockRef","chainTag","dependsOn","expiration","gas","gasPriceCoef","nonce","correctTransactionBody","reserved","decodeReservedField","txHash","sum","clause","includes","GAS_CONSTANTS","computeUsedGasFor","isValidBody","BLOCK_REF_LENGTH","isSignatureValid","signerPrivateKey","signWithDelegator","delegatorPrivateKey","transactionHash","delegatedHash","featuresField","RLP_FEATURES","features","unused","encodeBodyField","encodeReservedField","featuresList","pop","expectedSignatureLength","genesisBlock","number","parentID","gasLimit","beneficiary","gasUsed","totalScore","txsRoot","txsFeatures","stateRoot","receiptsRoot","isTrunk","mainnet","testnet","solo"],"sourceRoot":""}