"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2800],{90354:function(e,t,n){n.d(t,{KB:function(){return Ge},pU:function(){return L},yf:function(){return re}});var i=n(99331),r=n(35035),a=n(68896),s=n(85070),o=n(50953),d=n(78398),c=n(45444),u=n(61972),p=n(7309),l=n(75247),f=n(40840),y=n(15950),h=n(59085),g=n(12985),m=n(83350),b=n(68352),v=n(88611),I=n(55629),E=n(7210),w=n(65305),T=n(55536),N=n(66890),A=n(47410),x=n(99443),S=n(43497),R=n(31042),_=n(93996),P=n(74207),F=n(25957),k=n(50319),O=n(92767),V=n(22476),B=n(23677),D=Object.defineProperty;((e,t)=>{for(var n in t)D(e,n,{get:t[n],enumerable:!0})})({},{ABIContract:()=>U,ABIEvent:()=>G,ABIFunction:()=>M,ABIItem:()=>K,Account:()=>X,Address:()=>te,Blake2b256:()=>ie,BloomFilter:()=>ae,BufferKind:()=>_e,Certificate:()=>Ge,Clause:()=>pt,Coin:()=>ue,CompactFixedHexBlobKind:()=>Ve,ERC1155_ABI:()=>rt,ERC20_ABI:()=>nt,ERC721_ABI:()=>it,FixedHexBlobKind:()=>ke,FixedPointNumber:()=>W,HDKey:()=>ee,Hex:()=>L,HexBlobKind:()=>Fe,HexInt:()=>$,HexUInt:()=>j,Keccak256:()=>Q,MAINNET_NETWORK:()=>ht,Mnemonic:()=>Be,NUMERIC_REGEX:()=>ct,NumericKind:()=>Pe,OptionalFixedHexBlobKind:()=>Oe,Quantity:()=>Le,RLP:()=>he,RLPProfiler:()=>ge,Revision:()=>Ce,SOLO_NETWORK:()=>mt,ScalarKind:()=>ye,Secp256k1:()=>J,Sha256:()=>q,TESTNET_NETWORK:()=>gt,ThorId:()=>Ke,Transaction:()=>lt,Txt:()=>Y,Units:()=>pe,VET:()=>le,VIP180_ABI:()=>at,VIP181_ABI:()=>st,VIP210_ABI:()=>ot,VTHO:()=>fe,VTHO_ADDRESS:()=>yt,ZERO_ADDRESS:()=>ft,ZERO_BYTES:()=>dt,abi:()=>H,addressUtils:()=>ne,assertCompactFixedHexBlobBuffer:()=>xe,assertFixedHexBlobKindBuffer:()=>Ae,assertFixedHexBlobKindData:()=>Ne,assertValidHexBlobKindData:()=>Te,assertValidNumericKindBuffer:()=>Ie,blake2b256:()=>re,dataUtils:()=>ut,decodeBufferToHexWithLeadingZeros:()=>Re,decodeBufferToNumberOrHex:()=>we,encodeBigIntToBuffer:()=>Ee,encodeCompactFixedHexBlob:()=>Se,keccak256:()=>Z,keystore:()=>tt,mnemonic:()=>De,networkInfo:()=>bt,revisionUtils:()=>He,sha256:()=>z,validateNumericKindData:()=>me,vechain_sdk_core_ethers:()=>i});var L=class e{static NEGATIVE=-1;static POSITIVE=1;static PREFIX="0x";static RADIX=16;static REGEX_HEX=/^-?(0x)?[0-9a-f]*$/i;static REGEX_HEX_PREFIX=/^-?0x/i;digits;sign;constructor(e,t,n=(e=>e.toLowerCase())){this.digits=n(t),this.sign=e}get abs(){return new e(e.POSITIVE,this.digits)}get bi(){return BigInt(this.sign)*u.ly(this.digits)}get bytes(){return u.hexToBytes(this.alignToBytes().digits)}get n(){if(this.isNumber())return new DataView(this.bytes.buffer).getFloat64(0);throw new a.OH("Hex.n","not an IEEE 754 float 64 number",{hex:this.toString()})}alignToBytes(){return this.digits.length%2===0?this:new e(this.sign,"0"+this.digits)}compareTo(e){if(this.sign===e.sign){const t=Math.max(this.digits.length,e.digits.length),n=this.fit(t).bytes,i=e.fit(t).bytes;let r=0,a=0;for(;0===a&&r<n.length;)a=n[r]-i[r],r++;return a}return this.sign-e.sign}fit(t){if(t<this.digits.length){let n=0;for(;this.digits.length-n>t&&"0"===this.digits.at(n);)n++;if(this.digits.length-n===t)return new e(this.sign,this.digits.slice(n));throw new a.ep("Hex.fit",`can't fit in ${t} digits`,{digits:t,hex:this})}return t>this.digits.length?new e(this.sign,"0".repeat(t-this.digits.length)+this.digits):this}isEqual(e){return 0===this.compareTo(e)}isNumber(){return 32===this.digits.length}static isValid(t){return e.REGEX_HEX.test(t)}static isValid0x(t){return e.REGEX_HEX_PREFIX.test(t)&&e.isValid(t)}static of(t){try{if(t instanceof Uint8Array)return new e(this.POSITIVE,u.ci(t));if("bigint"===typeof t)return t<0n?new e(this.NEGATIVE,u.uz(-1n*t)):new e(this.POSITIVE,u.uz(t));if("number"===typeof t){const n=new DataView(new ArrayBuffer(16));return n.setFloat64(0,t),new e(t<0?this.NEGATIVE:this.POSITIVE,u.ci(new Uint8Array(n.buffer)))}if(this.isValid(t))return t.startsWith("-")?new e(this.NEGATIVE,this.REGEX_HEX_PREFIX.test(t)?t.slice(3):t.slice(1)):new e(this.POSITIVE,this.REGEX_HEX_PREFIX.test(t)?t.slice(2):t);throw new a.ep("Hex.of","not an hexadecimal string",{exp:t})}catch(n){throw new a.ep("Hex.of","not an hexadecimal expression",{exp:`${t}`},n)}}static random(t){if(t>0)return e.of(p.O6(t));throw new a.ep("Hex.random","bytes argument not > 0",{bytes:t})}toString(){return(this.sign<0?"-0x":"0x")+this.digits}},C=class e{types;values;constructor(e=[],t=[]){this.types="string"===typeof e?(0,o.n)(e):e,this.values=t}compareTo(e){return this.types.forEach(((t,n)=>{if(t!==e.types[n])return-1})),this.values.forEach(((t,n)=>{if(t!==e.values[n])return 1})),0}isEqual(e){return 0===this.compareTo(e)}get bi(){throw new a.OH("ABI.bi","There is no big integer representation for an ABI.",{data:""})}get bytes(){return this.toHex().bytes}get n(){throw new a.OH("ABI.n","There is no number representation for an ABI.",{data:""})}static of(t,n){try{return new e(t,n)}catch(i){throw new a.j7("ABI.of","Types and values must be valid ABI parameters.",{types:t,values:n},i)}}static ofEncoded(t,n){try{const i=L.of(n);let r;if("string"===typeof t){const e=(0,o.n)(t);r=(0,d.r)(e,i.bytes)}else r=(0,d.r)([...t],i.bytes);return new e(t,[...r])}catch(i){throw new a.j7("ABI.of","Decoding failed: Data must be a valid ABI type with corresponding valid data.",{types:t,data:n},i)}}parseObjectValues(e){const t=[],n=e=>{const t=[];for(const i in e)if(Object.prototype.hasOwnProperty.call(e,i)){const r=e[i];"object"===typeof r&&null!==r?t.push(n(r)):t.push(r)}return t};return t.push(...n(e)),t}getFirstDecodedValue(){return this.values[0]instanceof Object?this.parseObjectValues(this.values[0]):this.values[0]}toHex(){try{const e=(0,c.E)(this.types,this.values);return L.of(e)}catch(e){throw new a.j7("ABI.toHex","Encoding failed: Data must be a valid ABI type with corresponding valid data.",{types:this.types,values:this.values},e)}}},H={encode:(e,t)=>C.of(e instanceof s._R?e.format("full").replace(" list",""):e,[t]).toHex().toString(),encodeParams:(e,t)=>{const n=e instanceof s._R?e.map((e=>e.format("full").replace(" list",""))):e,i=(0,o.n)(n.join(", "));return C.of([...i],t).toHex().toString()},decode:(e,t)=>C.ofEncoded(e instanceof s._R?e.format("full").replace(" list",""):e,t).getFirstDecodedValue()},K=class extends C{signature;stringSignature;constructor(e){switch(super(),typeof e){case"string":this.stringSignature=e;break;case"object":this.stringSignature=(0,g.W)(e);break;default:this.stringSignature=""}this.signature="string"===typeof e?(0,m.s)([e]):e}static ofSignature(e,t){return new e(t)}format(e="string"){return"json"===e?JSON.stringify(this.signature):this.stringSignature}get signatureHash(){return(0,b.r)(this.stringSignature)}compareTo(e){return 0!==super.compareTo(e)?-1:this.stringSignature.localeCompare(e.stringSignature)}},G=class e extends K{abiEvent;constructor(e){try{super(e),this.abiEvent=this.signature}catch(t){throw new a.Kf("ABIEvent constructor","Initialization failed: Cannot create Event ABI. Event format is invalid.",{type:"event",value:e},t)}}static parseLog(e,t){try{return(0,y.F)({abi:e,data:t.data.toString(),topics:t.topics.map((e=>null===e?e:Array.isArray(e)?e.map((e=>e.toString())):e.toString()))})}catch(n){throw new a.j7("ABIEvent.parseLog","Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",{data:{abi:e,data:t.data,topics:t.topics}},n)}}decodeEventLog(t){try{return e.parseLog([this.abiEvent],t)}catch(n){throw new a.j7("ABIEvent.decodeEventLog","Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",{data:t},n)}}decodeEventLogAsArray(e){try{const t=this.decodeEventLog(e);return void 0===t.args?[]:t.args instanceof Object?Object.values(t.args):t.args}catch(t){throw new a.j7("ABIEvent.decodeEventLogAsArray","Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",{data:e},t)}}encodeEventLog(e){try{const t=this.encodeFilterTopics(e),n=[],i=[];return this.abiEvent.inputs.forEach(((t,r)=>{if(t.indexed)return;const a=e[r];n.push(t),i.push(a)})),{data:C.of(n,i).toHex(),topics:t.map((e=>null===e?e:Array.isArray(e)?e.map((e=>L.of(e))):L.of(e)))}}catch(t){throw new a.j7("ABIEvent.encodeEventLog","Encoding failed: Data format is invalid. Event data must be correctly formatted for ABI-compliant encoding.",{dataToEncode:e},t)}}encodeFilterTopics(e){if(this.abiEvent.inputs.length<e.length)throw new a.j7("ABIEvent.encodeEventLog","Encoding failed: Data format is invalid. Number of values to encode is greater than the inputs.",{valuesToEncode:e});try{return(0,h.O)({abi:[this.abiEvent],args:e})}catch(t){throw new a.j7("ABIEvent.encodeEventLog","Encoding failed: Data format is invalid. Event topics values must be correctly formatted for ABI-compliant encoding.",{valuesToEncode:e},t)}}encodeFilterTopicsNoNull(e){return this.encodeFilterTopics(e).map((e=>null===e?void 0:e))}},M=class extends K{abiFunction;constructor(e){try{super(e),this.abiFunction=this.signature}catch(t){throw new a.Kf("ABIFunction constructor","Initialization failed: Cannot create Function ABI. Function format is invalid.",{type:"function",value:e},t)}}get signatureHash(){return super.signatureHash.substring(0,10)}decodeData(e){try{return(0,v.p)({abi:[this.abiFunction],data:e.toString()})}catch(t){throw new a.j7("ABIFunction.decodeData","Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",{data:e},t)}}encodeData(e){try{return L.of((0,I.R)({abi:[this.abiFunction],args:e}))}catch(t){throw new a.j7("ABIFunction.encodeData","Encoding failed: Data format is invalid. Function data does not match the expected format for ABI type encoding.",{dataToEncode:e},t)}}decodeResult(e){try{return(0,E.k)({abi:[this.abiFunction],data:e.toString()})}catch(t){throw new a.j7("ABIFunction.decodeResult","Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",{data:e},t)}}decodeOutputAsArray(e){const t=this.decodeResult(e);return this.abiFunction.outputs.length>1?this.parseObjectValues(t):1===this.abiFunction.outputs.length&&"tuple"===this.abiFunction.outputs[0].type?[this.parseObjectValues(t)]:[t]}},U=class e extends C{abi;constructor(e){super(),this.abi=e}static ofAbi(t){return new e(t)}static ofStringAbi(t){return new e((0,l.V)([t]))}getFunction(e){const t=(0,f.mE)({abi:this.abi,name:e});if(null===t||void 0===t)throw new a.Kf("ABIContract.getFunction()",`Function '${e}' not found in contract ABI.`,{type:"function",value:e});return new M(t)}getEvent(e){const t=(0,f.mE)({abi:this.abi,name:e});if(null===t||void 0===t)throw new a.Kf("ABIContract.getEvent()",`Function '${e}' not found in contract ABI.`,{type:"event",value:e});return new G(t)}encodeFunctionInput(e,t){try{const n=(0,f.mE)({abi:this.abi,name:e});return new M(n).encodeData(t)}catch(n){throw new a.j7("ABIContract.encodeFunctionInput()","Encoding failed: Data format is invalid. Function data does not match the expected format for ABI type encoding.",{functionName:e,functionData:t},n)}}decodeFunctionInput(e,t){try{const n=(0,f.mE)({abi:this.abi,name:e});return new M(n).decodeData(t)}catch(n){throw new a.j7("ABIContract.decodeFunctionInput()","Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",{functionName:e,encodedFunctionInput:t},n)}}decodeFunctionOutput(e,t){try{const n=(0,f.mE)({abi:this.abi,name:e});return new M(n).decodeResult(t)}catch(n){throw new a.j7("ABIContract.decodeFunctionOutput()","Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",{functionName:e,encodedFunctionOutput:t},n)}}encodeEventLog(e,t){try{const n=(0,f.mE)({abi:this.abi,name:e});return new G(n).encodeEventLog(t)}catch(n){throw new a.j7("ABIContract.encodeEventLog()","Encoding failed: Data format is invalid. Event data does not match the expected format for ABI type encoding.",{eventName:e,dataToEncode:t},n)}}decodeEventLog(e,t){try{const n=(0,f.mE)({abi:this.abi,name:e});return new G(n).decodeEventLog(t)}catch(n){throw new a.j7("ABIContract.encodeEventLog()","Encoding failed: Data format is invalid. Event data does not match the expected format for ABI type encoding.",{eventName:e,dataToDecode:t},n)}}parseLog(e,t){try{return G.parseLog(this.abi,{data:e,topics:t})}catch(n){throw new a.j7("ABIContract.parseLog()","Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",{data:e,topics:t},n)}}parseLogAsArray(e,t){const n=this.parseLog(e,t);return void 0===n.args?[]:n.args instanceof Object?Object.values(n.args):n.args}},X=class{address;balance;transactions;type;constructor(e,t,n="EOA",i){this.address=e,this.balance=t,this.type=n,this.transactions=i??[]}get bi(){throw new a.OH("Account.bi","There is no big integer representation for an account.",{data:""})}get bytes(){throw new a.OH("Account.bytes","There is no bytes representation for an account.",{data:""})}get n(){throw new a.OH("Account.n","There is no number representation for an account.",{data:""})}addTransaction(e){this.transactions.push(e)}compareTo(e){const t=this.type.localeCompare(e.type);if(0===t){const t=this.address.compareTo(e.address);if(0===t){const t=this.balance.code.compareTo(e.balance.code);return 0===t?this.balance.value.compareTo(e.balance.value):t}return t}return t}isEqual(e){return 0===this.compareTo(e)}toString(){return`${this.type} Address: ${this.address.toString()} Balance: ${this.balance.value} ${this.balance.code}`}},$=class e extends L{get n(){const e=this.bi;if(Number.MIN_SAFE_INTEGER<=e&&e<=Number.MAX_SAFE_INTEGER)return Number(e);throw new a.ep("HexInt.n","not in the safe number range",{bi:`${e}`,hex:this.toString()})}static of(t){try{if(t instanceof L)return new e(t.sign,t.digits);if("number"===typeof t){if(Number.isInteger(t)){const n=L.of(BigInt(t));return new e(n.sign,n.digits)}throw new a.ep("HexInt.of","not an integer",{exp:t})}const n=L.of(t);return new e(n.sign,n.digits)}catch(n){throw new a.ep("HexInt.of","not an hexadecimal integer expression",{exp:`${t}`,e:n})}}},j=class e extends ${static REGEX_HEXUINT=/^(0x)?[0-9a-f]*$/i;static REGEX_HEXUINT_PREFIX=/^0x/i;static isValid(t){return e.REGEX_HEXUINT.test(t)}static isValid0x(t){return e.REGEX_HEX_PREFIX.test(t)&&L.isValid(t)}static of(t){try{const n=$.of(t);if(n.sign>=L.POSITIVE)return new e(n.sign,n.digits);throw new a.ep("HexUInt.of","not positive",{exp:`${t}`})}catch(n){throw new a.ep("HexUInt.of","not a hexadecimal positive integer expression",{exp:`${t}`,e:n},n)}}},Y=class e extends String{static DECODER=new TextDecoder;static NFC="NFC";static ENCODER=new TextEncoder;constructor(t){super(t.normalize(e.NFC))}get bi(){try{return BigInt(this.toString())}catch(e){throw new a.OH("Txt.bi()","Can't cast to big integer",{txt:this.toString()},e)}}get bytes(){return e.ENCODER.encode(this.toString())}get n(){return Number(this.toString())}compareTo(e){return this.toString().localeCompare(e.toString())}isEqual(e){return 0===this.compareTo(e)}toString(){return this.valueOf()}static of(t){return t instanceof Uint8Array?new e(e.DECODER.decode(t)):new e("bigint"===typeof t||"number"===typeof t?t.toString():t)}},Q=class e extends j{static of(t){try{const n=(0,w.fr)(j.of(t).bytes);return new e(L.POSITIVE,j.of(n).digits)}catch(n){throw new a.OH("Keccak256.of","hash error",{exp:`${t}`,e:n})}}};function Z(e,t="buffer"){return"buffer"===t?Q.of(Y.of(e).bytes).bytes:Q.of(Y.of(e).bytes).toString()}var W=class e{static DEFAULT_FRACTIONAL_DECIMALS=20n;static NaN=new e(0n,0n,NaN);static NEGATIVE_INFINITY=new e(0n,0n,Number.NEGATIVE_INFINITY);static POSITIVE_INFINITY=new e(0n,0n,Number.POSITIVE_INFINITY);static REGEX_INTEGER=/^[-+]?\d+$/;static REGEX_NUMBER=/(^[-+]?\d+(\.\d+)?)$|(^[-+]?\.\d+)$/;static REGEX_NATURAL=/^\d+$/;static ZERO=new e(0n,0n,0);ef;fd;sv;get bi(){if(this.isFinite())return this.sv/10n**this.fd;throw new a.OH("FixedPointNumber.bi","not finite value cannot cast to big integer",{this:this.toString()})}get bytes(){return Y.of(this.toString()).bytes}get n(){return this.isNaN()?Number.NaN:this.isNegativeInfinite()?Number.NEGATIVE_INFINITY:this.isPositiveInfinite()?Number.POSITIVE_INFINITY:this.isZero()?0:Number(this.sv)*10**-Number(this.fd)}constructor(e,t,n=0){this.fd=e,this.ef=n,this.sv=t}abs(){return this.isNaN()?e.NaN:this.isNegativeInfinite()?e.POSITIVE_INFINITY:new e(this.fd,this.sv<0n?-this.sv:this.sv,this.ef)}compareTo(e){if(this.isNaN()||e.isNaN())throw new a.OH("FixedPointNumber.compareTo","compare between NaN",{this:`${this}`,that:`${e}`});if(this.isNegativeInfinite())return e.isNegativeInfinite()?0:-1;if(this.isPositiveInfinite())return e.isPositiveInfinite()?0:1;if(e.isNegativeInfinite())return 1;if(e.isPositiveInfinite())return-1;const t=this.fd>e.fd?this.fd:e.fd,n=this.dp(t).sv-e.dp(t).sv;return n<0n?-1:0n===n?0:1}comparedTo(e){try{return this.compareTo(e)}catch(t){return null}}div(t){if(this.isNaN()||t.isNaN())return e.NaN;if(this.isNegativeInfinite())return t.isInfinite()?e.NaN:t.isPositive()?e.NEGATIVE_INFINITY:e.POSITIVE_INFINITY;if(this.isPositiveInfinite())return t.isInfinite()?e.NaN:t.isPositive()?e.POSITIVE_INFINITY:e.NEGATIVE_INFINITY;if(t.isInfinite())return e.ZERO;if(t.isZero())return this.isZero()?e.NaN:this.isNegative()?e.NEGATIVE_INFINITY:e.POSITIVE_INFINITY;const n=this.fd>t.fd?this.fd:t.fd;return new e(n,e.div(n,this.dp(n).sv,t.dp(n).sv))}static div(e,t,n){return 10n**e*t/n}dp(t){const n=BigInt(t),i=n-this.fd;return new e(n,i<0?this.sv/10n**-i:this.sv*10n**i)}eq(e){return 0===this.comparedTo(e)}gt(e){const t=this.comparedTo(e);return null!==t&&t>0}gte(e){const t=this.comparedTo(e);return null!==t&&t>=0}idiv(t){if(this.isNaN()||t.isNaN())return e.NaN;if(this.isNegativeInfinite())return t.isInfinite()?e.NaN:t.isPositive()?e.NEGATIVE_INFINITY:e.POSITIVE_INFINITY;if(this.isPositiveInfinite())return t.isInfinite()?e.NaN:t.isPositive()?e.POSITIVE_INFINITY:e.NEGATIVE_INFINITY;if(t.isInfinite())return e.ZERO;if(t.isZero())return this.isZero()?e.NaN:this.isNegative()?e.NEGATIVE_INFINITY:e.POSITIVE_INFINITY;const n=this.fd>t.fd?this.fd:t.fd;return new e(n,e.idiv(n,this.dp(n).sv,t.dp(n).sv))}static idiv(e,t,n){return t/n*10n**e}isEqual(e){return this.eq(e)}isFinite(){return 0===this.ef}isInfinite(){return this.isNegativeInfinite()||this.isPositiveInfinite()}isInteger(){return!!this.isFinite()&&this.sv%10n**this.fd===0n}static isIntegerExpression(e){return this.REGEX_INTEGER.test(e)}isNaN(){return Number.isNaN(this.ef)}static isNaturalExpression(e){return this.REGEX_NATURAL.test(e)}isNegative(){return this.isFinite()&&this.sv<0n||this.isNegativeInfinite()}isNegativeInfinite(){return this.ef===Number.NEGATIVE_INFINITY}static isNumberExpression(t){return e.REGEX_NUMBER.test(t)}isPositive(){return this.isFinite()&&this.sv>=0n||this.isPositiveInfinite()}isPositiveInfinite(){return this.ef===Number.POSITIVE_INFINITY}isZero(){return this.isFinite()&&0n===this.sv}lt(e){const t=this.comparedTo(e);return null!==t&&t<0}lte(e){const t=this.comparedTo(e);return null!==t&&t<=0}minus(t){if(this.isNaN()||t.isNaN())return e.NaN;if(this.isNegativeInfinite())return t.isNegativeInfinite()?e.NaN:e.NEGATIVE_INFINITY;if(this.isPositiveInfinite())return t.isPositiveInfinite()?e.NaN:e.POSITIVE_INFINITY;const n=this.fd>t.fd?this.fd:t.fd;return new e(n,this.dp(n).sv-t.dp(n).sv)}modulo(t){if(this.isNaN()||t.isNaN())return e.NaN;if(this.isInfinite()||t.isInfinite())return e.NaN;if(t.isZero())return e.NaN;const n=this.fd>t.fd?this.fd:t.fd;let i=this.abs().dp(n).sv;const r=t.abs().dp(n).sv;for(;i>=r;)i-=r;return new e(n,i)}static mul(e,t,n){return e*t/10n**n}negated(){return this.isNegativeInfinite()?e.POSITIVE_INFINITY:this.isPositiveInfinite()?e.NEGATIVE_INFINITY:new e(this.fd,-this.sv,this.ef)}static of(t,n=this.DEFAULT_FRACTIONAL_DECIMALS){try{return Number.isNaN(t)?new e(n,0n,Number.NaN):t===Number.NEGATIVE_INFINITY?new e(n,-1n,Number.NEGATIVE_INFINITY):t===Number.POSITIVE_INFINITY?new e(n,1n,Number.POSITIVE_INFINITY):new e(n,this.txtToSV(t.toString(),n))}catch(i){throw new a.ep("FixedPointNumber.of","not a number",{exp:t},i)}}plus(t){if(this.isNaN()||t.isNaN())return e.NaN;if(this.isNegativeInfinite())return t.isPositiveInfinite()?e.NaN:e.NEGATIVE_INFINITY;if(this.isPositiveInfinite())return t.isNegativeInfinite()?e.NaN:e.POSITIVE_INFINITY;const n=this.fd>t.fd?this.fd:t.fd;return new e(n,this.dp(n).sv+t.dp(n).sv)}pow(t){if(this.isNaN()||t.isNaN())return e.NaN;if(this.isInfinite())return t.isZero()?e.of(1):t.isNegative()?e.ZERO:e.POSITIVE_INFINITY;if(t.isNegativeInfinite())return e.ZERO;if(t.isPositiveInfinite())return e.POSITIVE_INFINITY;const n=this.fd>t.fd?this.fd:t.fd;return new e(n,e.pow(n,this.dp(n).sv,t.dp(n).sv))}static pow(t,n,i){const r=10n**t;return i<0n?e.pow(t,e.div(t,r,n),-i):0n===i?1n*r:i===r?n:e.pow(t,this.mul(n,n,t),i-r)}static sqr(t,n){if(t<0n)throw new RangeError("Value must be positive");const i=10n*n;let r=0,a=t,s=0n;for(;a!==s&&r<i;)s=a,a=(a+e.div(n,t,a))/2n,r++;return a}sqrt(){if(this.isNaN())return e.NaN;if(this.isNegativeInfinite())return e.NaN;if(this.isPositiveInfinite())return e.POSITIVE_INFINITY;try{return new e(this.fd,e.sqr(this.sv,this.fd))}catch(t){return e.NaN}}times(t){if(this.isNaN()||t.isNaN())return e.NaN;if(this.isNegativeInfinite())return t.isNegative()?e.POSITIVE_INFINITY:e.NEGATIVE_INFINITY;if(this.isPositiveInfinite())return t.isNegative()?e.NEGATIVE_INFINITY:e.POSITIVE_INFINITY;const n=this.fd>t.fd?this.fd:t.fd;return new e(n,e.mul(this.dp(n).sv,t.dp(n).sv,n))}toString(t="."){if(0===this.ef){const n=this.sv<0n?"-":"",i=(this.sv<0n?(-this.sv).toString():this.sv.toString()).padStart(Number(this.fd),"0"),r=this.fd>0?i.slice(Number(-this.fd)):"",a=i.slice(0,i.length-r.length),s=a.length<1?"0":a,o=e.trimEnd(r);return n+s+(o.length>0?t+o:"")}return this.ef.toString()}static trimEnd(t,n="0"){return t.endsWith(n)?e.trimEnd(t.substring(0,t.length-n.length),n):t}static txtToSV(e,t,n="."){const i=e.charAt(0);let r=1n;"-"===i?(r=-1n,e=e.substring(1)):"+"===i&&(e=e.substring(1));const a=10n**t,s=e.lastIndexOf(n);if(s<0)return r*a*BigInt(e);const o=e.substring(0,s),d=e.substring(s+1);return r*a*BigInt(o)+r*(a*BigInt(d))/BigInt(10**d.length)}},q=class e extends j{static of(t){try{const n=x.J(j.of(t).bytes);return new e(L.POSITIVE,j.of(n).digits)}catch(n){throw new a.OH("Sha256.of","hash error",{exp:`${t}`,e:n})}}};function z(e,t="buffer"){return"buffer"===t?q.of(Y.of(e).bytes).bytes:q.of(Y.of(e).bytes).toString()}var J=class e{static COMPRESSED_PREFIX=2;static SIGNATURE_LENGTH=65;static UNCOMPRESS_PREFIX=4;static VALID_HASH_LENGTH=32;static compressPublicKey(t){if(t.at(0)===e.UNCOMPRESS_PREFIX){const n=t.slice(1,33),i=t.slice(33,65),r=1&i[i.length-1];return u.eV(Uint8Array.of(e.COMPRESSED_PREFIX+r),n)}return t}static derivePublicKey(t,n=!0){if(e.isValidPrivateKey(t))return S.kA.getPublicKey(t,n);throw new a.wd("Secp256k1.derivePublicKey","Invalid private key given as input. Ensure it is a valid 32-byte secp256k1 private key.",void 0)}static async generatePrivateKey(){try{return S.kA.utils.randomPrivateKey()}catch(e){const t=await global.crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),n=await global.crypto.subtle.exportKey("raw",t);return new Uint8Array(n)}}static inflatePublicKey(t){if(t.at(0)!==e.UNCOMPRESS_PREFIX){const e=t.slice(0,33);return S.kA.ProjectivePoint.fromAffine(S.kA.ProjectivePoint.fromHex(j.of(e).digits).toAffine()).toRawBytes(!1)}return t}static isValidMessageHash(t){return t.length===e.VALID_HASH_LENGTH}static isValidPrivateKey(e){return S.kA.utils.isValidPrivateKey(e)}static randomBytes(e){try{return(0,p.O6)(e)}catch(t){return global.crypto.getRandomValues(new Uint8Array(e??32))}}static recover(t,n){if(!e.isValidMessageHash(t))throw new a.sc("Secp256k1.recover","Invalid message hash given as input. Ensure it is a valid 32-byte message hash.",{messageHash:t});if(n.length!==e.SIGNATURE_LENGTH)throw new a.UM("Secp256k1.recover","Invalid signature given as input. Length must be exactly 65 bytes.",{signature:n});const i=n[64];if(0!==i&&1!==i)throw new a.UM("Secp256k1.recover","Invalid signature recovery value. Signature bytes at position 64 must be 0 or 1.",{signature:n,recovery:i});return S.kA.Signature.fromCompact(n.slice(0,64)).addRecoveryBit(i).recoverPublicKey(t).toRawBytes(!1)}static sign(t,n){if(!e.isValidMessageHash(t))throw new a.sc("Secp256k1.sign","Invalid message hash given as input. Ensure it is a valid 32-byte message hash.",{messageHash:t});if(!e.isValidPrivateKey(n))throw new a.wd("Secp256k1.sign","Invalid private key given as input. Ensure it is a valid 32-byte secp256k1 private key.",void 0);const i=S.kA.sign(t,n);return u.eV(u.tL(i.r,32),u.tL(i.s,32),u.Yt(i.recovery))}},ee=class extends T.B{static EXTENDED_PRIVATE_KEY_PREFIX=j.of("0488ade4000000000000000000").bytes;static EXTENDED_PUBLIC_KEY_PREFIX=j.of("0488b21e000000000000000000").bytes;static VET_DERIVATION_PATH="m/44'/818'/0'/0";static fromMnemonic(e,t=this.VET_DERIVATION_PATH){let n;try{n=T.B.fromMasterSeed(N.Z1(e.join(" ").toLowerCase()))}catch(i){throw new a.g4("HDNode.fromMnemonic","Invalid mnemonic words given as input.",void 0,i)}try{return n.derive(t)}catch(i){throw new a.yZ("HDNode.fromMnemonic","Invalid derivation path given as input.",{derivationPath:t},i)}}static fromPrivateKey(e,t){if(32===e.length){const i=u.eV(this.EXTENDED_PRIVATE_KEY_PREFIX,t,Uint8Array.of(0),e);e.fill(0);const r=q.of(q.of(i).bytes).bytes.subarray(0,4),s=u.eV(i,r);try{return T.B.fromExtendedKey(A.Jq.encode(s))}catch(n){throw new a.wd("HDNode.fromPrivateKey","Invalid private key path given as input.",void 0)}}throw e.fill(0),new a.wd("HDNode.fromPrivateKey()","Invalid private key path given as input. Length must be exactly 32 bytes.",void 0)}static fromPublicKey(e,t){if(32===t.length){const i=u.eV(this.EXTENDED_PUBLIC_KEY_PREFIX,t,J.compressPublicKey(e)),r=q.of(q.of(i).bytes).bytes.subarray(0,4),s=u.eV(i,r);try{return T.B.fromExtendedKey(A.Jq.encode(s))}catch(n){throw new a.yZ("HDNode.fromPublicKey()","Invalid public key path given as input.",{publicKey:e},n)}}throw new a.yZ("HDNode.fromPublicKey()","Invalid chain code given as input. Length must be exactly 32 bytes.",{chainCode:t})}static isDerivationPathComponentValid(e,t){return 0===t&&"m"===e||W.isNaturalExpression(e)||W.isNaturalExpression(e.slice(0,-1))&&e.endsWith("'")}static isDerivationPathValid(e){const t=e.split("/");for(let n=0;n<t.length;n++)if(!this.isDerivationPathComponentValid(t[n],n))return!1;return!0}},te=class e extends j{static checksum(e){const t=e.digits,n=Q.of(Y.of(t).bytes).digits;let i="";for(let r=0;r<t.length;r++)i+=parseInt(n[r],16)>7?t[r].toUpperCase():t[r];return"0x"+i}static isValid(e){return L.isValid0x(e)&&42===e.length}static of(t){try{const n=j.of(t);if(e.isValid(n.toString())){const t=e.checksum(n);return new e(L.POSITIVE,"0x0",(()=>t.substring(2)))}throw new a.ep("Address.of","not a valid address",{huint:n})}catch(n){throw new a.ep("Address.of","not a valid hexadecimal positive integer expression",{exp:`${t}`},n)}}static ofPrivateKey(t,n=!0){try{return e.ofPublicKey(J.derivePublicKey(t,n))}catch(i){if(i instanceof a.wd)throw i;throw new a.ep("Address.ofPrivateKey","not a valid private key",{privateKey:`${t}`},i)}}static ofPublicKey(t){try{const n=J.inflatePublicKey(t),i=Q.of(n.slice(1)).bytes;return e.of(i.slice(12))}catch(n){throw new a.ep("Address.ofPublicKey","not a valid public key",{publicKey:`${t}`},n)}}static ofMnemonic(t,n="m/0"){const i=ee.fromMnemonic(t);try{return e.ofPublicKey(i.derive(n).publicKey)}catch(r){throw new a.yZ("mnemonic.deriveAddress()","Invalid derivation path given as input.",{derivationPath:n},r)}}},ne={fromPrivateKey:e=>te.ofPrivateKey(e).toString(),fromPublicKey:e=>te.ofPublicKey(e).toString(),isAddress:e=>te.isValid(e),toERC55Checksum:e=>te.checksum(j.of(e)).toString()},ie=class e extends j{static of(t){try{const n=R.R.create({dkLen:32}).update(j.of(t).bytes).digest();return new e(L.POSITIVE,j.of(n).digits)}catch(n){throw new a.OH("Blake2b256.of","hash error",{exp:`${t}`,e:n})}}};function re(e,t="buffer"){return"buffer"===t?ie.of(Y.of(e).bytes).bytes:ie.of(Y.of(e).bytes).toString()}var ae=class e{bytes;k;constructor(e,t){this.bytes=e,this.k=t}get bi(){return u.bytesToNumberBE(this.bytes)}get n(){const e=this.bi;if(Number.MIN_SAFE_INTEGER<=e&&e<=Number.MAX_SAFE_INTEGER)return Number(e);throw new a.ep("BloomFilter.n","not in the safe number range",{bytes:this.bytes,k:this.k})}compareTo(e){return this.bi<e.bi?-1:this.bi===e.bi?this.k-e.k:1}isEqual(e){return this.bi===e.bi&&this.k===e.k}contains(e){return de(ce(e instanceof L?e.bytes:e),this.k,8*this.bytes.byteLength,((e,t)=>(this.bytes[e]&t)===t))}static computeBestBitsPerKey(e){return e<=1?2:e>=30?44:Math.ceil(e/.69)}static computeBestHashFunctionsQuantity(e){const t=Math.floor(.69*e);return t<1?1:t>30?30:t}isJoinable(e){return this.k===e.k&&this.bytes.length===e.bytes.length}join(t){if(this.k===t.k){if(this.bytes.length===t.bytes.length)return new e(new Uint8Array(this.bytes.map(((e,n)=>e|t.bytes[n]))),this.k);throw new a.OH("BloomFilter.join","different length values",{this:this,other:t})}throw new a.OH("BloomFilter.join","different k values",{this:this,other:t})}static of(...e){const t=new se;return t.add(...e),t}},se=class e{static DEFAULT_K=5;hashMap=new Map;add(...e){for(const t of e)this.hashMap.set(ce(t instanceof L?t.bytes:t),!0);return this}build(t=e.DEFAULT_K,n=ae.computeBestBitsPerKey(t)){let i=Math.floor((this.hashMap.size*n+7)/8);i=i<8?8:i;const r=new Uint8Array(i),a=8*i;for(const e of this.hashMap.keys())de(e,t,a,((e,t)=>(r[e]|=t,!0)));return new ae(r,t)}},oe=2**32;function de(e,t,n,i){const r=(e>>>17|e<<15)>>>0;for(let a=0;a<t;a++){const t=e%n;if(!i(Math.floor(t/8),1<<t%8))return!1;e=(e+r)%oe}return!0}function ce(e){return Number(u.bytesToNumberBE(ie.of(e).bytes.slice(0,4)))}var ue=class{_code;_value;constructor(e,t){this._code=e,this._value=t}get code(){return this._code}get value(){return this._value}get bi(){return this._value.bi}get bytes(){return Y.of(this.toString()).bytes}get n(){return this._value.n}compareTo(e){if(this.code.isEqual(e.code))return this.value.compareTo(e.value);throw new a.ep("Coin.compareTo","not VET currency",{that:`${e}`})}isEqual(e){try{return 0===this.compareTo(e)}catch(t){return!1}}toString(){return`${this.value.toString()} ${this._code}`}},pe=(e=>(e[e.wei=0]="wei",e[e.kwei=3]="kwei",e[e.mwei=6]="mwei",e[e.gwei=9]="gwei",e[e.szabo=12]="szabo",e[e.finney=15]="finney",e[e.ether=18]="ether",e))(pe||{});(e=>{function t(e,t=18){const n=e.div(W.of(10n**BigInt(t)));return n.isInteger()?`${n}.0`:`${n}`}function n(e,t=18){return W.of(e).times(W.of(10n**BigInt(t)))}e.formatEther=function(e){return t(e,18)},e.formatUnits=t,e.parseEther=function(e){return n(e,18)},e.parseUnits=n})(pe||(pe={}));var le=class e extends ue{static CODE=Y.of("\ud835\udd4d\u039eT");static WEI_FD=18n;wei=this.value.dp(e.WEI_FD).sv;constructor(t){super(e.CODE,t)}static of(t,n=18){const i=t instanceof W?t:W.of(t);return new e(i.div(W.of(10n**(e.WEI_FD-BigInt(n)))))}},fe=class e extends ue{static CODE=Y.of("\ud835\udd4dTHO");static WEI_FD=18n;wei=this.value.dp(e.WEI_FD).sv;constructor(t){super(e.CODE,t)}static of(t,n=18){const i=t instanceof W?t:W.of(t);return new e(i.div(W.of(10n**(e.WEI_FD-BigInt(n)))))}},ye=class{},he=class e{encoded;decoded;constructor(e){this.decoded=e instanceof Uint8Array?_.yH.decode(e):e,this.encoded=e instanceof Uint8Array?e:_.yH.encode(e)}get bi(){return(0,P.Hv)(this.bytes)}get bytes(){return this.encoded}get n(){const e=this.bi;if(e<=Number.MAX_SAFE_INTEGER)return Number(e);throw new a.ep("RLP.n","not in the safe number range",{bytes:this.bytes})}compareTo(e){if(this.encoded.length!==e.encoded.length)return-1;for(let t=0;t<this.encoded.length;t++)if(this.encoded[t]!==e.encoded[t])return 1;return 0}isEqual(e){return 0===this.compareTo(e)}toHex(){return L.of(this.bytes)}static of(t){try{return new e(t)}catch(n){throw new a.yv("RLP.of()",`Error when creating an RLP instance for data ${t}`,{context:"This method creates an RLP instance from a plain value.",data:{data:t}},n)}}static ofEncoded(t){try{return new e(t)}catch(n){throw new a.yv("RLP.ofEncoded()","Error when creating an RLP instance for encoded data.",{context:"This method creates an RLP instance from an encoded value.",data:{encodedData:t}},n)}}static packData(e,t,n){n=""!==n?n+"."+t.name:t.name;const i=t.kind;if(i instanceof ye)return i.data(e,n).encode();if(Array.isArray(i))return i.map((t=>this.packData(e[t.name],t,n)));if(!Array.isArray(e))throw new a.yv("RLP.packData()",`Validation error: Expected an array in ${n}.`,{context:n,data:{obj:e,profile:t}});if("item"in i&&Array.isArray(e)){const t=i.item;return e.map(((e,i)=>this.packData(e,{name:"#"+i,kind:t},n)))}}static unpackData(e,t,n){n=""!==n?n+"."+t.name:t.name;const i=t.kind;if(i instanceof ye){if(!(e instanceof Uint8Array))throw new a.yv("RLP.unpackData()","Unpacking error: Expected data type is Uint8Array.",{context:n,data:{packed:e,profile:t}});return i.buffer(e,n).decode()}if(Array.isArray(i)&&Array.isArray(e)){const r=e;if(i.length!==r.length)throw new a.yv("RLP.unpackData()",`Unpacking error: Expected ${i.length} items, but got ${r.length}.`,{context:n,data:{packed:e,profile:t}});return i.reduce(((e,t,i)=>(e[t.name]=this.unpackData(r[i],t,n),e)),{})}if(!Array.isArray(e))throw new a.yv("RLP.unpackData()",`Validation error: Expected an array in ${n}.`,{context:n,data:{packed:e,profile:t}});if("item"in i&&Array.isArray(e)){const t=i.item;return e.map(((e,i)=>this.unpackData(e,{name:"#"+i,kind:t},n)))}}},ge=class e extends he{constructor(e,t){super(e),this.profile=t}static ofObject(t,n){const i=this.packData(t,n,"");return new e(i,n)}static ofObjectEncoded(t,n){const i=he.ofEncoded(t).decoded;return new e(i,n)}get object(){return e.unpackData(this.decoded,this.profile,"")}},me=(e,t)=>{if("number"!==typeof e&&"string"!==typeof e)throw new a.yv("validateNumericKindData()",`Validation error: Input in ${t} must be a string or number.`,{context:t,data:{data:e}});return"number"===typeof e?be(e,t):"string"===typeof e&&ve(e,t),BigInt(e)},be=(e,t)=>{if(!Number.isSafeInteger(e)||e<0)throw new a.yv("_validateNumericKindNumber()",`Validation error: Number in ${t} must be a safe and non-negative integer.`,{context:t,data:{num:e}})},ve=(e,t)=>{const n=j.isValid0x(e),i=W.isNaturalExpression(e);if(!n&&!i)throw new a.yv("_validateNumericKindString()",`Validation error: String in ${t} must represent a non-negative integer in hex or decimal format.`,{context:t,data:{str:e}});if(n&&e.length<=2)throw new a.yv("_validateNumericKindString()",`Validation error: Hex string number in ${t} must be of valid length.`,{context:t,data:{str:e}})},Ie=(e,t,n)=>{if(void 0!==n&&e.length>n)throw new a.yv("assertValidNumericKindBuffer()",`Validation error: Buffer in ${t} must be less than ${n} bytes.`,{context:t,data:{buf:e,maxBytes:n}});if(0===e[0])throw new a.yv("assertValidNumericKindBuffer()",`Validation error: Buffer in ${t} must represent a canonical integer (no leading zeros).`,{context:t,data:{buf:e,maxBytes:n}})},Ee=(e,t,n)=>{if(0n===e)return Uint8Array.from([]);const i=L.of(e).digits;if(void 0!==t&&i.length>2*t)throw new a.yv("encodeBigIntToBuffer()",`Validation error: Encoded number in ${n} must fit within ${t} bytes.`,{context:n,data:{hex:i,maxBytes:t}});return L.of(i).bytes},we=e=>{if(0===e.length)return 0;const t=L.of(e).bi,n=Number(t);return Number.isSafeInteger(n)?n:"0x"+t.toString(16)},Te=(e,t)=>{if("string"!==typeof e)throw new a.yv("assertValidHexBlobKindData()","Validation error: Input must be a string.",{context:t,data:{data:e}});if(!L.isValid(e))throw new a.yv("assertValidHexBlobKindData()","Validation error: Input must be a valid hex string with a '0x' prefix.",{context:t,data:{data:e}});if(e.length%2!==0)throw new a.yv("assertValidHexBlobKindData()","Validation error: Hex string must have an even length.",{context:t,data:{data:e}})},Ne=(e,t,n)=>{if(e.length!==2*n+2)throw new a.yv("assertFixedHexBlobKindData()",`Validation error: Hex string in ${t} must be exactly ${n} bytes in length.`,{context:t,data:{data:e,bytes:n}})},Ae=(e,t,n)=>{if(e.length!==n)throw new a.yv("assertFixedHexBlobKindData()",`Validation error: Hex string in ${t} must be exactly ${n} bytes in length.`,{context:t,data:{buffer:e,bytes:n}})},xe=(e,t,n)=>{if(e.length>n)throw new a.yv("assertCompactFixedHexBlobBuffer()",`Validation error: Buffer in ${t} must be at most ${n} bytes.`,{context:t,data:{buffer:e,bytes:n}});if(0!==e.length&&0===e[0])throw new a.yv("assertCompactFixedHexBlobBuffer()",`Validation error: Buffer in ${t} should not have leading zero bytes.`,{context:t,data:{buffer:e,bytes:n}})},Se=e=>{const t=e.findIndex((e=>0!==e));return-1!==t?e.subarray(t):Uint8Array.from([])},Re=(e,t)=>L.of(e).fit(2*t).toString(),_e=class extends ye{data(e,t){if(!(e instanceof Uint8Array))throw new a.yv("BufferKind.data()",`Validation error: Expected a Uint8Array type in ${t}.`,{context:t,data:{data:e}});return{encode:()=>e}}buffer(e){return{decode:()=>e}}},Pe=class extends ye{constructor(e){super(),this.maxBytes=e}data(e,t){const n=me(e,t);return{encode:()=>Ee(n,this.maxBytes,t)}}buffer(e,t){return Ie(e,t,this.maxBytes),{decode:()=>we(e)}}},Fe=class extends ye{data(e,t){return Te(e,t),{encode:()=>j.of(e.slice(2)).bytes}}buffer(e,t){return{decode:()=>L.of(e).toString()}}},ke=class extends Fe{constructor(e){super(),this.bytes=e}data(e,t){const n=super.data(e,t);return Ne(e,t,this.bytes),n}buffer(e,t){const n=super.buffer(e,t);return Ae(e,t,this.bytes),n}},Oe=class extends ke{data(e,t){return null==e?{encode:()=>Uint8Array.from([])}:super.data(e,t)}buffer(e,t){return 0===e.length?{decode:()=>null}:super.buffer(e,t)}},Ve=class extends ke{data(e,t){const n=super.data(e,t).encode();return{encode:()=>Se(n)}}buffer(e,t){return xe(e,t,this.bytes),{decode:()=>L.of(e).fit(2*this.bytes).toString()}}},Be=class e{static ENCODER=new TextEncoder;get bi(){throw new a.OH("Mnemonic.bi","There is no big integer representation for a mnemonic.",{data:""})}get bytes(){return e.ENCODER.encode(e.of().join(" "))}get n(){throw new a.OH("Mnemonic.n","There is no number representation for a mnemonic.",{data:""})}compareTo(e){throw new a.OH("Mnemonic.compareTo","There is no comparison for a mnemonic since it is not stored in memory.",{data:""})}isEqual(e){throw new a.OH("Mnemonic.isEqual","There is no comparison for a mnemonic since it is not stored in memory.",{data:""})}static wordsNoToStrength(e){switch(e){case 12:return 128;case 15:return 160;case 18:return 192;case 21:return 224;case 24:return 256;default:throw new a.ep("Mnemonic.wordsNoToStrength","not a valid number of words",{numberOfWords:e})}}static toPrivateKey(e,t="m/0"){const n=ee.fromMnemonic(e);try{return n.derive(t).privateKey}catch(i){throw new a.yZ("mnemonic.derivePrivateKey()","Invalid derivation path given as input.",{derivationPath:t},i)}}static of(t=12,n){try{const i=e.wordsNoToStrength(t);if(null!=n){const e=i/8;return(0,N.JJ)(n(e),F.U).split(" ")}return(0,N.OF)(F.U,i).split(" ")}catch(i){throw new a.g4("Mnemonic.of","error while generating mnemonic",{wordlistSize:t},i)}}static isValid(e){const t=Array.isArray(e)?e.join(" "):e;return(0,N._I)(t,F.U)}},De={deriveAddress:(e,t="m/0")=>te.ofMnemonic(e,t).toString(),derivePrivateKey:(e,t="m/0")=>Be.toPrivateKey(e,t),generate:(e,t)=>Be.of(e,t),isValid:e=>Be.isValid(e)},Le=class e extends j{static of(t){try{const n=j.of(t);let i=0;for(;i<n.digits.length&&"0"===n.digits.at(i);)i++;return new e(n.sign,i===n.digits.length?"0":n.digits.slice(i))}catch(n){throw new a.ep("Quantity.of","not a Quantity expression",{exp:`${t}`},n)}}},Ce=class e extends Y{static REGEX_DECIMAL_REVISION=/^(best|finalized|\d+)$/;static isValid(t){return"number"===typeof t?Number.isInteger(t)&&t>=0:j.isValid0x(t)||e.REGEX_DECIMAL_REVISION.test(t)}static of(t){try{let n;if(n=t instanceof L?t.bi.toString():t instanceof Uint8Array?Y.of(t).toString():`${t}`,e.isValid(n))return new e(n);throw new a.ep("Revision.of","not a revision",{value:`${t}`})}catch(n){throw new a.ep("Revision.of","not a revision",{value:`${t}`,e:n})}}},He={isRevisionAccount:e=>Ce.isValid(e),isRevisionBlock:e=>Ce.isValid(e)},Ke=class e extends j{static DIGITS=64;constructor(t){super(L.POSITIVE,t.fit(e.DIGITS).digits)}static isValid(t){return L.isValid(t)&&j.REGEX_HEXUINT_PREFIX.test(t)?t.length===e.DIGITS+2:t.length===e.DIGITS}static isValid0x(t){return j.REGEX_HEXUINT_PREFIX.test(t)&&e.isValid(t)}static of(t){try{return new e(t instanceof j?t:j.of(t))}catch(n){throw new a.ep("ThorId.of","not a ThorId expression",{exp:`${t}`},n)}}},Ge=class e{purpose;payload;domain;timestamp;signer;signature;constructor(e,t,n,i,r,s){if(!(Number.isSafeInteger(i)&&i>=0))throw new a.ep("Certificate.constructor","not positive safe integer timestamp",{timestamp:i});if(!te.isValid(r))throw new a.ep("Certificate.constructor","signer is not an address",{signer:r});this.purpose=e,this.payload=t,this.domain=n,this.timestamp=i,this.signer=r.toString().toLowerCase();try{this.signature="string"===typeof s?j.of(s).alignToBytes().toString():s}catch(o){throw new a.ep("Certificate.constructor","invalid signature",{signature:s},o)}}static encode(e){return Y.of(r(e)).bytes}isSigned(){return"string"===typeof this.signature&&j.isValid(this.signature)}static of(t){try{return new e(t.purpose,t.payload,t.domain,t.timestamp,t.signer,t.signature)}catch(n){throw new a.ep("Certificate.of","invalid certificate data",{certifiable:t},n)}}sign(t){return this.signature=void 0,this.signature=j.of(J.sign(ie.of(e.encode(this)).bytes,t)).toString(),this}verify(){if(!this.isSigned())throw new a.kA("Certificate.verify","signature missing",{certificate:this});if(te.ofPublicKey(J.recover(ie.of(e.encode({...this,signature:void 0})).bytes,j.of(this.signature).bytes)).toString().toLowerCase()!==this.signer)throw new a.kA("Certificate.verify","signature doesn't match with signer's public key",{certificate:this})}},Me=131072,Ue=8,Xe=1;function $e(e){return O.D_((0,a.WO)(e))}var je={encrypt:async function(e,t){const n=J.derivePublicKey(e),i={address:te.ofPublicKey(n).toString(),privateKey:j.of(e).toString()},r={scrypt:{N:Me,r:Ue,p:Xe}},a=await O.BZ(i,t,r);return JSON.parse(a)},decrypt:async function(e,t){if(!$e(e))throw new a.ru("keystore.decrypt()","Invalid keystore. Ensure the keystore is properly formatted and contains the necessary data.",{keystore:e});try{return await O.Y0((0,a.WO)(e),t)}catch(n){throw new a.QQ("keystore.decrypt()","Decryption failed: Invalid Password for the given keystore.",{keystore:e})}},isValid:$e},Ye="aes-128-ctr",Qe=32,Ze="scrypt",We=3,qe={N:131072,r:8,p:1};function ze(e){e[6]=15&e[6]|64,e[8]=63&e[8]|128;const t=L.of(e).digits;return[t.substring(0,8),t.substring(8,12),t.substring(12,16),t.substring(16,20),t.substring(20,32)].join("-")}var Je={decrypt:function(e,t){return function(e,t){try{if(e.crypto.cipher.toLowerCase()!==Ye)throw new a.QQ("(EXPERIMENTAL) keystore.decryptKeystore()","Decryption failed: unsupported crypto cipher algorithm.",{cipher:e.crypto.cipher.toLowerCase()});if(e.crypto.kdf.toLowerCase()!==Ze)throw new a.QQ("(EXPERIMENTAL) keystore.decryptKeystore()","Decryption failed: unsupported crypto key derivation function.",{keyDerivationFunction:e.crypto.kdf.toLowerCase()});if(e.version!==We)throw new a.QQ("(EXPERIMENTAL) keystore.decryptKeystore()","Decryption failed: unsupported keystore version.",{version:e.version});const n=function(e){const t=u.hexToBytes(e.crypto.kdfparams.salt),n=e.crypto.kdfparams.n,i=e.crypto.kdfparams.r,r=e.crypto.kdfparams.p;if(n<=0||0!==(n&n-1))throw new a.QQ("(EXPERIMENTAL) keystore.decodeScryptParams()","Decryption failed: invalid  keystore.crypto.kdfparams.n parameter.",{keystore:e,N:n});if(i<=0||r<=0)throw new a.QQ("(EXPERIMENTAL) keystore.decodeScryptParams()","Decryption failed: both keystore.crypto.kdfparams.r or keystore.crypto.kdfparams.p parameter must be > 0.",{keystore:e,r:i,p:r});const s=e.crypto.kdfparams.dklen;if(s!==Qe)throw new a.QQ("(EXPERIMENTAL) keystore.decodeScryptParams()",`Decryption failed: keystore.crypto.kdfparams.dklen parameter must be ${Qe}`,{keystore:e,dkLen:s});return{N:n,dkLen:Qe,name:Ze,p:r,r:i,salt:t}}(e),i=(0,B.f)(t,n.salt,{N:n.N,r:n.r,p:n.p,dkLen:n.dkLen}),r=u.hexToBytes(e.crypto.ciphertext);if(e.crypto.mac!==Q.of(u.eV(i.slice(16,32),r)).digits)throw new a.QQ("(EXPERIMENTAL) keystore.decryptKeystore()","Decryption failed: Invalid Password for the given keystore.",{keystore:e});const s=(0,V.ij)(i.slice(0,16),u.hexToBytes(e.crypto.cipherparams.iv)).decrypt(r),o=te.ofPrivateKey(s).toString();if(""!==e.address&&o!==te.checksum(L.of(e.address)))throw new a.QQ("(EXPERIMENTAL) keystore.decryptKeystore()","Decryption failed: address/password mismatch.",{keystoreAddress:e.address});return{address:o,privateKey:L.of(s).toString()}}finally{t.fill(0)}}(e,t)},encrypt:function(e,t){return function(e,t,n){try{const i=function(e){const t=e.salt??J.randomBytes(Qe);let n=qe.N,i=qe.r,r=qe.p;if(null!=e.scrypt&&(null!=e.scrypt.N&&(n=e.scrypt.N),null!=e.scrypt.r&&(i=e.scrypt.r),null!=e.scrypt.p&&(r=e.scrypt.p)),n<=0||(BigInt(n)&BigInt(n-1))!==BigInt(0))throw new a.QQ("(EXPERIMENTAL) keystore.encodeScryptParams()","Encryption failed: invalid options.scrypt.N parameter.",{options:e,N:n});if(i<=0||!Number.isSafeInteger(i))throw new a.QQ("(EXPERIMENTAL) keystore.encodeScryptParams()","Encryption failed: invalid options.scrypt.r parameter.",{options:e,r:i});if(r<=0||!Number.isSafeInteger(r))throw new a.QQ("(EXPERIMENTAL) keystore.encodeScryptParams()","Encryption failed: invalid options.scrypt.p parameter.",{options:e,p:r});return{name:Ze,dkLen:Qe,N:n,p:r,r:i,salt:t}}(n),r=(0,B.f)(t,i.salt,{N:i.N,r:i.r,p:i.p,dkLen:i.dkLen}),s=n.iv??J.randomBytes(16);if(16!==s.length)throw new a.QQ("(EXPERIMENTAL) keystore.encryptKeystore()","Encryption failed: invalid options.iv length.",{iv:s});const o=n.uuid??J.randomBytes(16);if(16!==o.length)throw new a.QQ("(EXPERIMENTAL) keystore.encryptKeystore()","Encryption failed: invalid options.uuid length.",{uuidRandom:o});const d=r.slice(16,32),c=(0,V.ij)(r.slice(0,16),s).encrypt(e);return{address:te.ofPrivateKey(e).toString(),crypto:{cipher:Ye,cipherparams:{iv:L.of(s).digits},ciphertext:L.of(c).digits,kdf:"scrypt",kdfparams:{dklen:Qe,n:i.N,p:i.p,r:i.r,salt:L.of(i.salt).digits},mac:Q.of(u.eV(d,c)).digits},id:ze(o),version:We}}finally{e.fill(0),t.fill(0)}}(e,t,{scrypt:{N:qe.N,r:qe.r,p:qe.p}})},isValid:function(e){try{const t=JSON.parse((0,a.WO)(e));if(t.crypto.cipher.toLowerCase()===Ye&&t.crypto.kdf.toLowerCase()===Ze&&t.version===We)return!0}catch(t){}return!1}},et=!1;var tt={encrypt:async function(e,t){return et&&(0,k.t)("warning").log({title:"Experimental cryptography",messages:["Remember, you are using an experimental cryptography library.","functions: keystore.encrypt"]}),et?Je.encrypt(e,Y.of(t).bytes):await je.encrypt(e,t)},decrypt:async function(e,t){return et&&(0,k.t)("warning").log({title:"Experimental cryptography",messages:["Remember, you are using an experimental cryptography library.","functions: keystore.decrypt"]}),et?Je.decrypt(e,Y.of(t).bytes):await je.decrypt(e,t)},isValid:function(e){return et&&(0,k.t)("warning").log({title:"Experimental cryptography",messages:["Remember, you are using an experimental cryptography library.","functions: keystore.isValid"]}),et?Je.isValid(e):je.isValid(e)},useExperimentalCryptography:function(e){et=e}},nt=[{inputs:[],stateMutability:"nonpayable",type:"constructor"},{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"allowance",type:"uint256"},{internalType:"uint256",name:"needed",type:"uint256"}],name:"ERC20InsufficientAllowance",type:"error"},{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"uint256",name:"balance",type:"uint256"},{internalType:"uint256",name:"needed",type:"uint256"}],name:"ERC20InsufficientBalance",type:"error"},{inputs:[{internalType:"address",name:"approver",type:"address"}],name:"ERC20InvalidApprover",type:"error"},{inputs:[{internalType:"address",name:"receiver",type:"address"}],name:"ERC20InvalidReceiver",type:"error"},{inputs:[{internalType:"address",name:"sender",type:"address"}],name:"ERC20InvalidSender",type:"error"},{inputs:[{internalType:"address",name:"spender",type:"address"}],name:"ERC20InvalidSpender",type:"error"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"},{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"}],it=[{inputs:[],stateMutability:"nonpayable",type:"constructor"},{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"address",name:"owner",type:"address"}],name:"ERC721IncorrectOwner",type:"error"},{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ERC721InsufficientApproval",type:"error"},{inputs:[{internalType:"address",name:"approver",type:"address"}],name:"ERC721InvalidApprover",type:"error"},{inputs:[{internalType:"address",name:"operator",type:"address"}],name:"ERC721InvalidOperator",type:"error"},{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"ERC721InvalidOwner",type:"error"},{inputs:[{internalType:"address",name:"receiver",type:"address"}],name:"ERC721InvalidReceiver",type:"error"},{inputs:[{internalType:"address",name:"sender",type:"address"}],name:"ERC721InvalidSender",type:"error"},{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ERC721NonexistentToken",type:"error"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"},{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"receiver",type:"address"}],name:"mintItem",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function"}],rt=[{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256[]",name:"ids",type:"uint256[]"},{indexed:!1,internalType:"uint256[]",name:"values",type:"uint256[]"}],name:"TransferBatch",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"id",type:"uint256"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"TransferSingle",type:"event"},{anonymous:!1,inputs:[{indexed:!1,internalType:"string",name:"value",type:"string"},{indexed:!0,internalType:"uint256",name:"id",type:"uint256"}],name:"URI",type:"event"},{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"id",type:"uint256"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"ids",type:"uint256[]"}],name:"balanceOfBatch",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256[]",name:"ids",type:"uint256[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeBatchTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"id",type:"uint256"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"uint256",name:"id",type:"uint256"}],name:"uri",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"}],at=nt,st=it,ot=rt,dt=e=>new Uint8Array(e),ct=/(^-?\d+(\.\d+)?)$|(^-?\.\d+)$/,ut={decodeBytes32String:e=>{if(!L.isValid(e)||64!==L.of(e).digits.length)throw new a.ep("dataUtils.decodeBytes32String()",`Failed to decode value ${e} to string. Value is not a valid hex string or it is not 64 characters long`,{value:e});const t=L.of(e).bytes,n=t.findIndex((e=>0===e));if(0===n){const e=t.findIndex((e=>0!==e));return Y.of(t.subarray(e)).toString()}return-1!==n?Y.of(t.subarray(0,n)).toString():Y.of(t).toString()},encodeBytes32String:(e,t="right")=>{try{const n=Y.of(e).bytes;if(n.length>32)throw new a.ep("dataUtils.encodeBytes32String()",`Failed to encode value ${e} to bytes32 string. Value exceeds 32 bytes.`,{value:e});const i=dt(32-n.length);return"left"===t?L.of(u.eV(i,n)).toString():L.of(u.eV(n,i)).toString()}catch(n){throw new a.ep("dataUtils.encodeBytes32String()",`Failed to encode value ${e} to bytes32 string.`,{value:e},n)}}},pt=class e{static FORMAT_TYPE="json";static NO_VALUE=L.PREFIX+"0";static NO_DATA=L.PREFIX;static TRANSFER_NFT_FUNCTION="transferFrom";static TRANSFER_TOKEN_FUNCTION="transfer";to;value;data;comment;abi;constructor(e,t,n,i,r){this.to=e,this.value=t,this.data=n,this.comment=i,this.abi=r}amount(){return W.of($.of(this.value).bi)}static callFunction(t,n,i,r=le.of(W.ZERO),s){if(r.value.isFinite()&&r.value.isPositive())return new e(t.toString().toLowerCase(),L.PREFIX+r.wei.toString(L.RADIX),n.encodeData(i).toString(),s?.comment,!0===s?.includeABI?n.format(e.FORMAT_TYPE):void 0);throw new a.ep("Clause.callFunction","not finite positive amount",{amount:`${r.value}`})}static deployContract(t,n,i){const r=null!==n&&void 0!==n?t.digits+H.encodeParams(n.types,n.values).replace(L.PREFIX,""):t.digits;return new e(null,e.NO_VALUE,L.PREFIX+r,i?.comment)}static transferNFT(t,n,i,r,a){return e.callFunction(t,U.ofAbi(it).getFunction(e.TRANSFER_NFT_FUNCTION),[n.toString(),i.toString(),r.bi.toString()],void 0,a)}static transferToken(t,n,i,r){if(i.value.isFinite()&&i.value.isPositive())return this.callFunction(t,U.ofAbi(at).getFunction(e.TRANSFER_TOKEN_FUNCTION),[n.toString(),i.wei],void 0,r);throw new a.ep("Clause.transferToken","not positive integer amount",{amount:`${i.value}`})}static transferVET(t,n,i){if(n.value.isFinite()&&n.value.isPositive())return new e(t.toString().toLowerCase(),L.PREFIX+n.wei.toString(L.RADIX),e.NO_DATA,i?.comment);throw new a.ep("Clause.transferVET","not finite positive amount",{amount:`${n.value}`})}},lt=class e{static BLOCK_REF_LENGTH=8;static GAS_CONSTANTS={TX_GAS:5000n,CLAUSE_GAS:16000n,CLAUSE_GAS_CONTRACT_CREATION:48000n,ZERO_GAS_DATA:4n,NON_ZERO_GAS_DATA:68n};static RLP_FIELDS=[{name:"chainTag",kind:new Pe(1)},{name:"blockRef",kind:new Ve(8)},{name:"expiration",kind:new Pe(4)},{name:"clauses",kind:{item:[{name:"to",kind:new Oe(20)},{name:"value",kind:new Pe(32)},{name:"data",kind:new Fe}]}},{name:"gasPriceCoef",kind:new Pe(1)},{name:"gas",kind:new Pe(8)},{name:"dependsOn",kind:new Oe(32)},{name:"nonce",kind:new Pe(8)},{name:"reserved",kind:{item:new _e}}];static RLP_FEATURES={name:"reserved.features",kind:new Pe(4)};static RLP_SIGNATURE={name:"signature",kind:new _e};static RLP_SIGNED_TRANSACTION_PROFILE={name:"tx",kind:e.RLP_FIELDS.concat([e.RLP_SIGNATURE])};static RLP_UNSIGNED_TRANSACTION_PROFILE={name:"tx",kind:e.RLP_FIELDS};body;signature;constructor(e,t){this.body=e,this.signature=t}get delegator(){if(this.isDelegated){if(void 0!==this.signature){const e=this.signature.slice(J.SIGNATURE_LENGTH,this.signature.length),t=J.recover(this.getSignatureHash(this.origin).bytes,e);return te.ofPublicKey(t)}throw new a.$N("Transaction.delegator()","missing delegator",{fieldName:"delegator"})}throw new a.uS("Transaction.delegator()","not delegated transaction",void 0)}get encoded(){return this.encode(this.isSigned)}get id(){if(this.isSigned)return ie.of(u.eV(this.getSignatureHash().bytes,this.origin.bytes));throw new a.$N("Transaction.id()","not signed transaction: id unavailable",{fieldName:"id"})}get intrinsicGas(){return e.intrinsicGas(this.body.clauses)}get isDelegated(){return e.isDelegated(this.body)}get isSigned(){return void 0!==this.signature}get origin(){if(void 0!==this.signature)return te.ofPublicKey(J.recover(this.getSignatureHash().bytes,this.signature.slice(0,J.SIGNATURE_LENGTH)));throw new a.$N("Transaction.origin()","not signed transaction, no origin",{fieldName:"origin"})}static decode(t,n){const i=n?e.RLP_SIGNED_TRANSACTION_PROFILE:e.RLP_UNSIGNED_TRANSACTION_PROFILE,r=ge.ofObjectEncoded(t,i).object,a={blockRef:r.blockRef,chainTag:r.chainTag,clauses:r.clauses,dependsOn:r.dependsOn,expiration:r.expiration,gas:r.gas,gasPriceCoef:r.gasPriceCoef,nonce:r.nonce},s=r.reserved.length>0?{...a,reserved:e.decodeReservedField(r.reserved)}:a;return void 0!==r.signature?e.of(s,r.signature):e.of(s)}getSignatureHash(e){const t=ie.of(this.encode(!1));return void 0!==e?ie.of(u.eV(t.bytes,e.bytes)):t}static intrinsicGas(t){return t.length>0?fe.of(t.reduce(((t,n)=>{if(null!==n.to){if(!te.isValid(n.to)&&!n.to.includes("."))throw new a.ep("Transaction.intrinsicGas","invalid data type in clause: each `to` field must be a valid address.",{clause:n});t+=e.GAS_CONSTANTS.CLAUSE_GAS}else t+=e.GAS_CONSTANTS.CLAUSE_GAS_CONTRACT_CREATION;return t+=e.computeUsedGasFor(n.data)}),e.GAS_CONSTANTS.TX_GAS),0):fe.of(e.GAS_CONSTANTS.TX_GAS+e.GAS_CONSTANTS.CLAUSE_GAS,0)}static isValidBody(t){return void 0!==t.chainTag&&t.chainTag>=0&&t.chainTag<=255&&void 0!==t.blockRef&&L.isValid0x(t.blockRef)&&j.of(t.blockRef).bytes.length===e.BLOCK_REF_LENGTH&&void 0!==t.expiration&&void 0!==t.clauses&&void 0!==t.gasPriceCoef&&void 0!==t.gas&&void 0!==t.dependsOn&&void 0!==t.nonce}static of(t,n){if(e.isValidBody(t)){if(void 0===n||e.isSignatureValid(t,n))return new e(t,n);throw new a.UM("Transaction.of","invalid signature",{signature:n})}throw new a.u7("Transaction.of","invalid body",{fieldName:"body",body:t})}sign(t){if(J.isValidPrivateKey(t)){if(!this.isDelegated){const n=J.sign(this.getSignatureHash().bytes,t);return e.of(this.body,n)}throw new a.u7("Transaction.sign","delegated transaction: use signWithDelegator method",{fieldName:"delegator",body:this.body})}throw new a.wd("Transaction.sign","invalid private key: ensure it is a secp256k1 key",void 0)}signWithDelegator(t,n){if(J.isValidPrivateKey(t)){if(J.isValidPrivateKey(n)){if(this.isDelegated){const i=this.getSignatureHash().bytes,r=this.getSignatureHash(te.ofPublicKey(J.derivePublicKey(t))).bytes;return e.of(this.body,u.eV(J.sign(i,t),J.sign(r,n)))}throw new a.uS("Transaction.signWithDelegator","not delegated transaction: use sign method",void 0)}throw new a.wd("Transaction.signWithDelegator","invalid delegator private: ensure it is a secp256k1 key",void 0)}throw new a.wd("Transaction.signWithDelegator","invalid signer private key: ensure it is a secp256k1 key",void 0)}static computeUsedGasFor(t){if(""!==t&&!L.isValid(t))throw new a.ep("calculateDataUsedGas()","Invalid data type for gas calculation. Data should be a hexadecimal string.",{data:t});let n=0n;for(let i=2;i<t.length;i+=2)"00"===t.substring(i,i+2)?n+=e.GAS_CONSTANTS.ZERO_GAS_DATA:n+=e.GAS_CONSTANTS.NON_ZERO_GAS_DATA;return n}static decodeReservedField(t){if(t[t.length-1].length>0){const n=e.RLP_FEATURES.kind.buffer(t[0],e.RLP_FEATURES.name).decode();return t.length>1?{features:n,unused:t.slice(1)}:{features:n}}throw new a.u7("Transaction.decodeReservedField","invalid reserved field: fields in the `reserved` property must be properly trimmed",{fieldName:"reserved",reserved:t})}encode(e){return this.encodeBodyField({...this.body,clauses:this.body.clauses,reserved:this.encodeReservedField()},e)}encodeBodyField(t,n){return n?ge.ofObject({...t,signature:Uint8Array.from(this.signature)},e.RLP_SIGNED_TRANSACTION_PROFILE).encoded:ge.ofObject(t,e.RLP_UNSIGNED_TRANSACTION_PROFILE).encoded}encodeReservedField(){const t=this.body.reserved??{},n=[e.RLP_FEATURES.kind.data(t.features??0,e.RLP_FEATURES.name).encode(),...t.unused??[]];for(;n.length>0&&0===n[n.length-1].length;)n.pop();return n}static isDelegated(e){return 1===(1&((e.reserved??{}).features??0))}static isSignatureValid(e,t){const n=this.isDelegated(e)?2*J.SIGNATURE_LENGTH:J.SIGNATURE_LENGTH;return t.length===n}},ft="0x0000000000000000000000000000000000000000",yt="0x0000000000000000000000000000456e65726779",ht={genesisBlock:{number:0,id:"0x00000000851caf3cfdb6e899cf5958bfb1ac3413d346d43539627e6be7ec1b4a",size:170,parentID:"0xffffffff53616c757465202620526573706563742c20457468657265756d2100",timestamp:1530316800,gasLimit:1e7,beneficiary:"0x0000000000000000000000000000000000000000",gasUsed:0,totalScore:0,txsRoot:"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",txsFeatures:0,stateRoot:"0x09bfdf9e24dd5cd5b63f3c1b5d58b97ff02ca0490214a021ed7d99b93867839c",receiptsRoot:"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",signer:"0x0000000000000000000000000000000000000000",isTrunk:!0,transactions:[]},chainTag:74},gt={genesisBlock:{number:0,id:"0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127",size:170,parentID:"0xffffffff00000000000000000000000000000000000000000000000000000000",timestamp:1530014400,gasLimit:1e7,beneficiary:"0x0000000000000000000000000000000000000000",gasUsed:0,totalScore:0,txsRoot:"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",txsFeatures:0,stateRoot:"0x4ec3af0acbad1ae467ad569337d2fe8576fe303928d35b8cdd91de47e9ac84bb",receiptsRoot:"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",signer:"0x0000000000000000000000000000000000000000",isTrunk:!0,transactions:[]},chainTag:39},mt={genesisBlock:{number:0,id:"0x00000000c05a20fbca2bf6ae3affba6af4a74b800b585bf7a4988aba7aea69f6",size:170,parentID:"0xffffffff00000000000000000000000000000000000000000000000000000000",timestamp:15264e5,gasLimit:1e7,beneficiary:"0x0000000000000000000000000000000000000000",gasUsed:0,totalScore:0,txsRoot:"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",txsFeatures:0,stateRoot:"0x93de0ffb1f33bc0af053abc2a87c4af44594f5dcb1cb879dd823686a15d68550",receiptsRoot:"0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",signer:"0x0000000000000000000000000000000000000000",isTrunk:!0,transactions:[]},chainTag:246},bt={mainnet:ht,testnet:gt,solo:mt}}}]);