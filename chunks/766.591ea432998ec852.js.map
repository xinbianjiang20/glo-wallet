{"version":3,"file":"static/chunks/766.591ea432998ec852.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@motionone/utils/dist/defaults.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/time.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/noop.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/animate/utils/stop-animation.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/animate/utils/controls.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/is-easing-generator.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/is-number.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/is-easing-list.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/mix.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/progress.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/offset.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/wrap.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/clamp.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/interpolate.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/easing.es.js","webpack://_N_E/./node_modules/@motionone/easing/dist/cubic-bezier.es.js","webpack://_N_E/./node_modules/@motionone/easing/dist/steps.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/is-function.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/is-cubic-bezier.es.js","webpack://_N_E/./node_modules/@motionone/animation/dist/utils/easing.es.js","webpack://_N_E/./node_modules/@motionone/animation/dist/Animation.es.js","webpack://_N_E/./node_modules/@motionone/types/dist/MotionValue.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/animate/data.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/animate/utils/transforms.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/array.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/animate/utils/css-var.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/animate/utils/feature-detection.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/animate/utils/easing.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/animate/utils/keyframes.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/animate/utils/get-style-name.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/animate/style.es.js","webpack://_N_E/./node_modules/@motionone/utils/dist/is-string.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/animate/animate-style.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/animate/utils/get-unit.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/animate/utils/options.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/utils/stagger.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/animate/index.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/animate/create-animate.es.js","webpack://_N_E/./node_modules/@motionone/dom/dist/utils/resolve-elements.es.js","webpack://_N_E/./node_modules/motion/dist/animate.es.js","webpack://_N_E/./node_modules/lit-html/directives/class-map.js","webpack://_N_E/./node_modules/lit-html/directives/if-defined.js"],"sourcesContent":["const defaults = {\n    duration: 0.3,\n    delay: 0,\n    endDelay: 0,\n    repeat: 0,\n    easing: \"ease\",\n};\n\nexport { defaults };\n","const time = {\n    ms: (seconds) => seconds * 1000,\n    s: (milliseconds) => milliseconds / 1000,\n};\n\nexport { time };\n","const noop = () => { };\nconst noopReturn = (v) => v;\n\nexport { noop, noopReturn };\n","function stopAnimation(animation, needsCommit = true) {\n    if (!animation || animation.playState === \"finished\")\n        return;\n    // Suppress error thrown by WAAPI\n    try {\n        if (animation.stop) {\n            animation.stop();\n        }\n        else {\n            needsCommit && animation.commitStyles();\n            animation.cancel();\n        }\n    }\n    catch (e) { }\n}\n\nexport { stopAnimation };\n","import { defaults, noop, time } from '@motionone/utils';\nimport { stopAnimation } from './stop-animation.es.js';\n\nconst createAnimation = (factory) => factory();\nconst withControls = (animationFactory, options, duration = defaults.duration) => {\n    return new Proxy({\n        animations: animationFactory.map(createAnimation).filter(Boolean),\n        duration,\n        options,\n    }, controls);\n};\n/**\n * TODO:\n * Currently this returns the first animation, ideally it would return\n * the first active animation.\n */\nconst getActiveAnimation = (state) => state.animations[0];\nconst controls = {\n    get: (target, key) => {\n        const activeAnimation = getActiveAnimation(target);\n        switch (key) {\n            case \"duration\":\n                return target.duration;\n            case \"currentTime\":\n                return time.s((activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) || 0);\n            case \"playbackRate\":\n            case \"playState\":\n                return activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key];\n            case \"finished\":\n                if (!target.finished) {\n                    target.finished = Promise.all(target.animations.map(selectFinished)).catch(noop);\n                }\n                return target.finished;\n            case \"stop\":\n                return () => {\n                    target.animations.forEach((animation) => stopAnimation(animation));\n                };\n            case \"forEachNative\":\n                /**\n                 * This is for internal use only, fire a callback for each\n                 * underlying animation.\n                 */\n                return (callback) => {\n                    target.animations.forEach((animation) => callback(animation, target));\n                };\n            default:\n                return typeof (activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) ===\n                    \"undefined\"\n                    ? undefined\n                    : () => target.animations.forEach((animation) => animation[key]());\n        }\n    },\n    set: (target, key, value) => {\n        switch (key) {\n            case \"currentTime\":\n                value = time.ms(value);\n            // Fall-through\n            case \"playbackRate\":\n                for (let i = 0; i < target.animations.length; i++) {\n                    target.animations[i][key] = value;\n                }\n                return true;\n        }\n        return false;\n    },\n};\nconst selectFinished = (animation) => animation.finished;\n\nexport { controls, withControls };\n","const isEasingGenerator = (easing) => typeof easing === \"object\" &&\n    Boolean(easing.createAnimation);\n\nexport { isEasingGenerator };\n","const isNumber = (value) => typeof value === \"number\";\n\nexport { isNumber };\n","import { isNumber } from './is-number.es.js';\n\nconst isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);\n\nexport { isEasingList };\n","const mix = (min, max, progress) => -progress * min + progress * max + min;\n\nexport { mix };\n","const progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);\n\nexport { progress };\n","import { mix } from './mix.es.js';\nimport { progress } from './progress.es.js';\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mix(min, 1, offsetProgress));\n    }\n}\nfunction defaultOffset(length) {\n    const offset = [0];\n    fillOffset(offset, length - 1);\n    return offset;\n}\n\nexport { defaultOffset, fillOffset };\n","const wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\nexport { wrap };\n","const clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nexport { clamp };\n","import { mix } from './mix.es.js';\nimport { noopReturn } from './noop.es.js';\nimport { fillOffset, defaultOffset } from './offset.es.js';\nimport { progress } from './progress.es.js';\nimport { getEasingForSegment } from './easing.es.js';\nimport { clamp } from './clamp.es.js';\n\nfunction interpolate(output, input = defaultOffset(output.length), easing = noopReturn) {\n    const length = output.length;\n    /**\n     * If the input length is lower than the output we\n     * fill the input to match. This currently assumes the input\n     * is an animation progress value so is a good candidate for\n     * moving outside the function.\n     */\n    const remainder = length - input.length;\n    remainder > 0 && fillOffset(input, remainder);\n    return (t) => {\n        let i = 0;\n        for (; i < length - 2; i++) {\n            if (t < input[i + 1])\n                break;\n        }\n        let progressInRange = clamp(0, 1, progress(input[i], input[i + 1], t));\n        const segmentEasing = getEasingForSegment(easing, i);\n        progressInRange = segmentEasing(progressInRange);\n        return mix(output[i], output[i + 1], progressInRange);\n    };\n}\n\nexport { interpolate };\n","import { isEasingList } from './is-easing-list.es.js';\nimport { wrap } from './wrap.es.js';\n\nfunction getEasingForSegment(easing, i) {\n    return isEasingList(easing) ? easing[wrap(0, easing.length, i)] : easing;\n}\n\nexport { getEasingForSegment };\n","import { noopReturn } from '@motionone/utils';\n\n/*\n  Bezier function generator\n\n  This has been modified from Gaëtan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noopReturn;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n","import { clamp } from '@motionone/utils';\n\nconst steps = (steps, direction = \"end\") => (progress) => {\n    progress =\n        direction === \"end\"\n            ? Math.min(progress, 0.999)\n            : Math.max(progress, 0.001);\n    const expanded = progress * steps;\n    const rounded = direction === \"end\" ? Math.floor(expanded) : Math.ceil(expanded);\n    return clamp(0, 1, rounded / steps);\n};\n\nexport { steps };\n","const isFunction = (value) => typeof value === \"function\";\n\nexport { isFunction };\n","import { isNumber } from './is-number.es.js';\n\nconst isCubicBezier = (easing) => Array.isArray(easing) && isNumber(easing[0]);\n\nexport { isCubicBezier };\n","import { cubicBezier, steps } from '@motionone/easing';\nimport { isFunction, isCubicBezier, noopReturn } from '@motionone/utils';\n\nconst namedEasings = {\n    ease: cubicBezier(0.25, 0.1, 0.25, 1.0),\n    \"ease-in\": cubicBezier(0.42, 0.0, 1.0, 1.0),\n    \"ease-in-out\": cubicBezier(0.42, 0.0, 0.58, 1.0),\n    \"ease-out\": cubicBezier(0.0, 0.0, 0.58, 1.0),\n};\nconst functionArgsRegex = /\\((.*?)\\)/;\nfunction getEasingFunction(definition) {\n    // If already an easing function, return\n    if (isFunction(definition))\n        return definition;\n    // If an easing curve definition, return bezier function\n    if (isCubicBezier(definition))\n        return cubicBezier(...definition);\n    // If we have a predefined easing function, return\n    const namedEasing = namedEasings[definition];\n    if (namedEasing)\n        return namedEasing;\n    // If this is a steps function, attempt to create easing curve\n    if (definition.startsWith(\"steps\")) {\n        const args = functionArgsRegex.exec(definition);\n        if (args) {\n            const argsArray = args[1].split(\",\");\n            return steps(parseFloat(argsArray[0]), argsArray[1].trim());\n        }\n    }\n    return noopReturn;\n}\n\nexport { getEasingFunction };\n","import { noopReturn, defaults, isEasingGenerator, isEasingList, interpolate } from '@motionone/utils';\nimport { getEasingFunction } from './utils/easing.es.js';\n\nclass Animation {\n    constructor(output, keyframes = [0, 1], { easing, duration: initialDuration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, offset, direction = \"normal\", autoplay = true, } = {}) {\n        this.startTime = null;\n        this.rate = 1;\n        this.t = 0;\n        this.cancelTimestamp = null;\n        this.easing = noopReturn;\n        this.duration = 0;\n        this.totalDuration = 0;\n        this.repeat = 0;\n        this.playState = \"idle\";\n        this.finished = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n        easing = easing || defaults.easing;\n        if (isEasingGenerator(easing)) {\n            const custom = easing.createAnimation(keyframes);\n            easing = custom.easing;\n            keyframes = custom.keyframes || keyframes;\n            initialDuration = custom.duration || initialDuration;\n        }\n        this.repeat = repeat;\n        this.easing = isEasingList(easing) ? noopReturn : getEasingFunction(easing);\n        this.updateDuration(initialDuration);\n        const interpolate$1 = interpolate(keyframes, offset, isEasingList(easing) ? easing.map(getEasingFunction) : noopReturn);\n        this.tick = (timestamp) => {\n            var _a;\n            // TODO: Temporary fix for OptionsResolver typing\n            delay = delay;\n            let t = 0;\n            if (this.pauseTime !== undefined) {\n                t = this.pauseTime;\n            }\n            else {\n                t = (timestamp - this.startTime) * this.rate;\n            }\n            this.t = t;\n            // Convert to seconds\n            t /= 1000;\n            // Rebase on delay\n            t = Math.max(t - delay, 0);\n            /**\n             * If this animation has finished, set the current time\n             * to the total duration.\n             */\n            if (this.playState === \"finished\" && this.pauseTime === undefined) {\n                t = this.totalDuration;\n            }\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = t / this.duration;\n            // TODO progress += iterationStart\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            iterationProgress === 1 && currentIteration--;\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const iterationIsOdd = currentIteration % 2;\n            if (direction === \"reverse\" ||\n                (direction === \"alternate\" && iterationIsOdd) ||\n                (direction === \"alternate-reverse\" && !iterationIsOdd)) {\n                iterationProgress = 1 - iterationProgress;\n            }\n            const p = t >= this.totalDuration ? 1 : Math.min(iterationProgress, 1);\n            const latest = interpolate$1(this.easing(p));\n            output(latest);\n            const isAnimationFinished = this.pauseTime === undefined &&\n                (this.playState === \"finished\" || t >= this.totalDuration + endDelay);\n            if (isAnimationFinished) {\n                this.playState = \"finished\";\n                (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, latest);\n            }\n            else if (this.playState !== \"idle\") {\n                this.frameRequestId = requestAnimationFrame(this.tick);\n            }\n        };\n        if (autoplay)\n            this.play();\n    }\n    play() {\n        const now = performance.now();\n        this.playState = \"running\";\n        if (this.pauseTime !== undefined) {\n            this.startTime = now - this.pauseTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = now;\n        }\n        this.cancelTimestamp = this.startTime;\n        this.pauseTime = undefined;\n        this.frameRequestId = requestAnimationFrame(this.tick);\n    }\n    pause() {\n        this.playState = \"paused\";\n        this.pauseTime = this.t;\n    }\n    finish() {\n        this.playState = \"finished\";\n        this.tick(0);\n    }\n    stop() {\n        var _a;\n        this.playState = \"idle\";\n        if (this.frameRequestId !== undefined) {\n            cancelAnimationFrame(this.frameRequestId);\n        }\n        (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, false);\n    }\n    cancel() {\n        this.stop();\n        this.tick(this.cancelTimestamp);\n    }\n    reverse() {\n        this.rate *= -1;\n    }\n    commitStyles() { }\n    updateDuration(duration) {\n        this.duration = duration;\n        this.totalDuration = duration * (this.repeat + 1);\n    }\n    get currentTime() {\n        return this.t;\n    }\n    set currentTime(t) {\n        if (this.pauseTime !== undefined || this.rate === 0) {\n            this.pauseTime = t;\n        }\n        else {\n            this.startTime = performance.now() - t / this.rate;\n        }\n    }\n    get playbackRate() {\n        return this.rate;\n    }\n    set playbackRate(rate) {\n        this.rate = rate;\n    }\n}\n\nexport { Animation };\n","/**\n * The MotionValue tracks the state of a single animatable\n * value. Currently, updatedAt and current are unused. The\n * long term idea is to use this to minimise the number\n * of DOM reads, and to abstract the DOM interactions here.\n */\nclass MotionValue {\n    setAnimation(animation) {\n        this.animation = animation;\n        animation === null || animation === void 0 ? void 0 : animation.finished.then(() => this.clearAnimation()).catch(() => { });\n    }\n    clearAnimation() {\n        this.animation = this.generator = undefined;\n    }\n}\n\nexport { MotionValue };\n","import { MotionValue } from '@motionone/types';\n\nconst data = new WeakMap();\nfunction getAnimationData(element) {\n    if (!data.has(element)) {\n        data.set(element, {\n            transforms: [],\n            values: new Map(),\n        });\n    }\n    return data.get(element);\n}\nfunction getMotionValue(motionValues, name) {\n    if (!motionValues.has(name)) {\n        motionValues.set(name, new MotionValue());\n    }\n    return motionValues.get(name);\n}\n\nexport { getAnimationData, getMotionValue };\n","import { noopReturn, addUniqueItem } from '@motionone/utils';\nimport { getAnimationData } from '../data.es.js';\n\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\nconst axes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\nconst order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\nconst transformAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n};\nconst rotation = {\n    syntax: \"<angle>\",\n    initialValue: \"0deg\",\n    toDefaultUnit: (v) => v + \"deg\",\n};\nconst baseTransformProperties = {\n    translate: {\n        syntax: \"<length-percentage>\",\n        initialValue: \"0px\",\n        toDefaultUnit: (v) => v + \"px\",\n    },\n    rotate: rotation,\n    scale: {\n        syntax: \"<number>\",\n        initialValue: 1,\n        toDefaultUnit: noopReturn,\n    },\n    skew: rotation,\n};\nconst transformDefinitions = new Map();\nconst asTransformCssVar = (name) => `--motion-${name}`;\n/**\n * Generate a list of every possible transform key\n */\nconst transforms = [\"x\", \"y\", \"z\"];\norder.forEach((name) => {\n    axes.forEach((axis) => {\n        transforms.push(name + axis);\n        transformDefinitions.set(asTransformCssVar(name + axis), baseTransformProperties[name]);\n    });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\nconst compareTransformOrder = (a, b) => transforms.indexOf(a) - transforms.indexOf(b);\n/**\n * Provide a quick way to check if a string is the name of a transform\n */\nconst transformLookup = new Set(transforms);\nconst isTransform = (name) => transformLookup.has(name);\nconst addTransformToElement = (element, name) => {\n    // Map x to translateX etc\n    if (transformAlias[name])\n        name = transformAlias[name];\n    const { transforms } = getAnimationData(element);\n    addUniqueItem(transforms, name);\n    /**\n     * TODO: An optimisation here could be to cache the transform in element data\n     * and only update if this has changed.\n     */\n    element.style.transform = buildTransformTemplate(transforms);\n};\nconst buildTransformTemplate = (transforms) => transforms\n    .sort(compareTransformOrder)\n    .reduce(transformListToString, \"\")\n    .trim();\nconst transformListToString = (template, name) => `${template} ${name}(var(${asTransformCssVar(name)}))`;\n\nexport { addTransformToElement, asTransformCssVar, axes, buildTransformTemplate, compareTransformOrder, isTransform, transformAlias, transformDefinitions };\n","function addUniqueItem(array, item) {\n    array.indexOf(item) === -1 && array.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    index > -1 && arr.splice(index, 1);\n}\n\nexport { addUniqueItem, removeItem };\n","import { transformDefinitions } from './transforms.es.js';\n\nconst isCssVar = (name) => name.startsWith(\"--\");\nconst registeredProperties = new Set();\nfunction registerCssVariable(name) {\n    if (registeredProperties.has(name))\n        return;\n    registeredProperties.add(name);\n    try {\n        const { syntax, initialValue } = transformDefinitions.has(name)\n            ? transformDefinitions.get(name)\n            : {};\n        CSS.registerProperty({\n            name,\n            inherits: false,\n            syntax,\n            initialValue,\n        });\n    }\n    catch (e) { }\n}\n\nexport { isCssVar, registerCssVariable, registeredProperties };\n","const testAnimation = (keyframes, options) => document.createElement(\"div\").animate(keyframes, options);\nconst featureTests = {\n    cssRegisterProperty: () => typeof CSS !== \"undefined\" &&\n        Object.hasOwnProperty.call(CSS, \"registerProperty\"),\n    waapi: () => Object.hasOwnProperty.call(Element.prototype, \"animate\"),\n    partialKeyframes: () => {\n        try {\n            testAnimation({ opacity: [1] });\n        }\n        catch (e) {\n            return false;\n        }\n        return true;\n    },\n    finished: () => Boolean(testAnimation({ opacity: [0, 1] }, { duration: 0.001 }).finished),\n    linearEasing: () => {\n        try {\n            testAnimation({ opacity: 0 }, { easing: \"linear(0, 1)\" });\n        }\n        catch (e) {\n            return false;\n        }\n        return true;\n    },\n};\nconst results = {};\nconst supports = {};\nfor (const key in featureTests) {\n    supports[key] = () => {\n        if (results[key] === undefined)\n            results[key] =\n                featureTests[key]();\n        return results[key];\n    };\n}\n\nexport { supports };\n","import { isFunction, defaults, isCubicBezier, progress } from '@motionone/utils';\nimport { supports } from './feature-detection.es.js';\n\n// Create a linear easing point for every x second\nconst resolution = 0.015;\nconst generateLinearEasingPoints = (easing, duration) => {\n    let points = \"\";\n    const numPoints = Math.round(duration / resolution);\n    for (let i = 0; i < numPoints; i++) {\n        points += easing(progress(0, numPoints - 1, i)) + \", \";\n    }\n    return points.substring(0, points.length - 2);\n};\nconst convertEasing = (easing, duration) => {\n    if (isFunction(easing)) {\n        return supports.linearEasing()\n            ? `linear(${generateLinearEasingPoints(easing, duration)})`\n            : defaults.easing;\n    }\n    else {\n        return isCubicBezier(easing) ? cubicBezierAsString(easing) : easing;\n    }\n};\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\n\nexport { convertEasing, cubicBezierAsString, generateLinearEasingPoints };\n","function hydrateKeyframes(keyframes, readInitialValue) {\n    for (let i = 0; i < keyframes.length; i++) {\n        if (keyframes[i] === null) {\n            keyframes[i] = i ? keyframes[i - 1] : readInitialValue();\n        }\n    }\n    return keyframes;\n}\nconst keyframesList = (keyframes) => Array.isArray(keyframes) ? keyframes : [keyframes];\n\nexport { hydrateKeyframes, keyframesList };\n","import { isTransform, asTransformCssVar, transformAlias } from './transforms.es.js';\n\nfunction getStyleName(key) {\n    if (transformAlias[key])\n        key = transformAlias[key];\n    return isTransform(key) ? asTransformCssVar(key) : key;\n}\n\nexport { getStyleName };\n","import { isCssVar } from './utils/css-var.es.js';\nimport { getStyleName } from './utils/get-style-name.es.js';\nimport { transformDefinitions } from './utils/transforms.es.js';\n\nconst style = {\n    get: (element, name) => {\n        name = getStyleName(name);\n        let value = isCssVar(name)\n            ? element.style.getPropertyValue(name)\n            : getComputedStyle(element)[name];\n        // TODO Decide if value can be 0\n        if (!value && value !== 0) {\n            const definition = transformDefinitions.get(name);\n            if (definition)\n                value = definition.initialValue;\n        }\n        return value;\n    },\n    set: (element, name, value) => {\n        name = getStyleName(name);\n        if (isCssVar(name)) {\n            element.style.setProperty(name, value);\n        }\n        else {\n            element.style[name] = value;\n        }\n    },\n};\n\nexport { style };\n","const isString = (value) => typeof value === \"string\";\n\nexport { isString };\n","import { getAnimationData, getMotionValue } from './data.es.js';\nimport { isCssVar, registerCssVariable } from './utils/css-var.es.js';\nimport { defaults, isEasingGenerator, isFunction, isEasingList, isNumber, time, noop } from '@motionone/utils';\nimport { isTransform, addTransformToElement, transformDefinitions } from './utils/transforms.es.js';\nimport { convertEasing } from './utils/easing.es.js';\nimport { supports } from './utils/feature-detection.es.js';\nimport { hydrateKeyframes, keyframesList } from './utils/keyframes.es.js';\nimport { style } from './style.es.js';\nimport { getStyleName } from './utils/get-style-name.es.js';\nimport { stopAnimation } from './utils/stop-animation.es.js';\nimport { getUnitConverter } from './utils/get-unit.es.js';\n\nfunction getDevToolsRecord() {\n    return window.__MOTION_DEV_TOOLS_RECORD;\n}\nfunction animateStyle(element, key, keyframesDefinition, options = {}, AnimationPolyfill) {\n    const record = getDevToolsRecord();\n    const isRecording = options.record !== false && record;\n    let animation;\n    let { duration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, easing = defaults.easing, persist = false, direction, offset, allowWebkitAcceleration = false, autoplay = true, } = options;\n    const data = getAnimationData(element);\n    const valueIsTransform = isTransform(key);\n    let canAnimateNatively = supports.waapi();\n    /**\n     * If this is an individual transform, we need to map its\n     * key to a CSS variable and update the element's transform style\n     */\n    valueIsTransform && addTransformToElement(element, key);\n    const name = getStyleName(key);\n    const motionValue = getMotionValue(data.values, name);\n    /**\n     * Get definition of value, this will be used to convert numerical\n     * keyframes into the default value type.\n     */\n    const definition = transformDefinitions.get(name);\n    /**\n     * Stop the current animation, if any. Because this will trigger\n     * commitStyles (DOM writes) and we might later trigger DOM reads,\n     * this is fired now and we return a factory function to create\n     * the actual animation that can get called in batch,\n     */\n    stopAnimation(motionValue.animation, !(isEasingGenerator(easing) && motionValue.generator) &&\n        options.record !== false);\n    /**\n     * Batchable factory function containing all DOM reads.\n     */\n    return () => {\n        const readInitialValue = () => { var _a, _b; return (_b = (_a = style.get(element, name)) !== null && _a !== void 0 ? _a : definition === null || definition === void 0 ? void 0 : definition.initialValue) !== null && _b !== void 0 ? _b : 0; };\n        /**\n         * Replace null values with the previous keyframe value, or read\n         * it from the DOM if it's the first keyframe.\n         */\n        let keyframes = hydrateKeyframes(keyframesList(keyframesDefinition), readInitialValue);\n        /**\n         * Detect unit type of keyframes.\n         */\n        const toUnit = getUnitConverter(keyframes, definition);\n        if (isEasingGenerator(easing)) {\n            const custom = easing.createAnimation(keyframes, key !== \"opacity\", readInitialValue, name, motionValue);\n            easing = custom.easing;\n            keyframes = custom.keyframes || keyframes;\n            duration = custom.duration || duration;\n        }\n        /**\n         * If this is a CSS variable we need to register it with the browser\n         * before it can be animated natively. We also set it with setProperty\n         * rather than directly onto the element.style object.\n         */\n        if (isCssVar(name)) {\n            if (supports.cssRegisterProperty()) {\n                registerCssVariable(name);\n            }\n            else {\n                canAnimateNatively = false;\n            }\n        }\n        /**\n         * If we've been passed a custom easing function, and this browser\n         * does **not** support linear() easing, and the value is a transform\n         * (and thus a pure number) we can still support the custom easing\n         * by falling back to the animation polyfill.\n         */\n        if (valueIsTransform &&\n            !supports.linearEasing() &&\n            (isFunction(easing) || (isEasingList(easing) && easing.some(isFunction)))) {\n            canAnimateNatively = false;\n        }\n        /**\n         * If we can animate this value with WAAPI, do so.\n         */\n        if (canAnimateNatively) {\n            /**\n             * Convert numbers to default value types. Currently this only supports\n             * transforms but it could also support other value types.\n             */\n            if (definition) {\n                keyframes = keyframes.map((value) => isNumber(value) ? definition.toDefaultUnit(value) : value);\n            }\n            /**\n             * If this browser doesn't support partial/implicit keyframes we need to\n             * explicitly provide one.\n             */\n            if (keyframes.length === 1 &&\n                (!supports.partialKeyframes() || isRecording)) {\n                keyframes.unshift(readInitialValue());\n            }\n            const animationOptions = {\n                delay: time.ms(delay),\n                duration: time.ms(duration),\n                endDelay: time.ms(endDelay),\n                easing: !isEasingList(easing)\n                    ? convertEasing(easing, duration)\n                    : undefined,\n                direction,\n                iterations: repeat + 1,\n                fill: \"both\",\n            };\n            animation = element.animate({\n                [name]: keyframes,\n                offset,\n                easing: isEasingList(easing)\n                    ? easing.map((thisEasing) => convertEasing(thisEasing, duration))\n                    : undefined,\n            }, animationOptions);\n            /**\n             * Polyfill finished Promise in browsers that don't support it\n             */\n            if (!animation.finished) {\n                animation.finished = new Promise((resolve, reject) => {\n                    animation.onfinish = resolve;\n                    animation.oncancel = reject;\n                });\n            }\n            const target = keyframes[keyframes.length - 1];\n            animation.finished\n                .then(() => {\n                if (persist)\n                    return;\n                // Apply styles to target\n                style.set(element, name, target);\n                // Ensure fill modes don't persist\n                animation.cancel();\n            })\n                .catch(noop);\n            /**\n             * This forces Webkit to run animations on the main thread by exploiting\n             * this condition:\n             * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/graphics/ca/GraphicsLayerCA.cpp?rev=281238#L1099\n             *\n             * This fixes Webkit's timing bugs, like accelerated animations falling\n             * out of sync with main thread animations and massive delays in starting\n             * accelerated animations in WKWebView.\n             */\n            if (!allowWebkitAcceleration)\n                animation.playbackRate = 1.000001;\n            /**\n             * If we can't animate the value natively then we can fallback to the numbers-only\n             * polyfill for transforms.\n             */\n        }\n        else if (AnimationPolyfill && valueIsTransform) {\n            /**\n             * If any keyframe is a string (because we measured it from the DOM), we need to convert\n             * it into a number before passing to the Animation polyfill.\n             */\n            keyframes = keyframes.map((value) => typeof value === \"string\" ? parseFloat(value) : value);\n            /**\n             * If we only have a single keyframe, we need to create an initial keyframe by reading\n             * the current value from the DOM.\n             */\n            if (keyframes.length === 1) {\n                keyframes.unshift(parseFloat(readInitialValue()));\n            }\n            animation = new AnimationPolyfill((latest) => {\n                style.set(element, name, toUnit ? toUnit(latest) : latest);\n            }, keyframes, Object.assign(Object.assign({}, options), { duration,\n                easing }));\n        }\n        else {\n            const target = keyframes[keyframes.length - 1];\n            style.set(element, name, definition && isNumber(target)\n                ? definition.toDefaultUnit(target)\n                : target);\n        }\n        if (isRecording) {\n            record(element, key, keyframes, {\n                duration,\n                delay: delay,\n                easing,\n                repeat,\n                offset,\n            }, \"motion-one\");\n        }\n        motionValue.setAnimation(animation);\n        if (animation && !autoplay)\n            animation.pause();\n        return animation;\n    };\n}\n\nexport { animateStyle };\n","import { noopReturn, isString } from '@motionone/utils';\n\nfunction getUnitConverter(keyframes, definition) {\n    var _a;\n    let toUnit = (definition === null || definition === void 0 ? void 0 : definition.toDefaultUnit) || noopReturn;\n    const finalKeyframe = keyframes[keyframes.length - 1];\n    if (isString(finalKeyframe)) {\n        const unit = ((_a = finalKeyframe.match(/(-?[\\d.]+)([a-z%]*)/)) === null || _a === void 0 ? void 0 : _a[2]) || \"\";\n        if (unit)\n            toUnit = (value) => value + unit;\n    }\n    return toUnit;\n}\n\nexport { getUnitConverter };\n","const getOptions = (options, key) => \n/**\n * TODO: Make test for this\n * Always return a new object otherwise delay is overwritten by results of stagger\n * and this results in no stagger\n */\noptions[key] ? Object.assign(Object.assign({}, options), options[key]) : Object.assign({}, options);\n\nexport { getOptions };\n","import { isNumber, isFunction } from '@motionone/utils';\nimport { getEasingFunction } from '@motionone/animation';\n\nfunction stagger(duration = 0.1, { start = 0, from = 0, easing } = {}) {\n    return (i, total) => {\n        const fromIndex = isNumber(from) ? from : getFromIndex(from, total);\n        const distance = Math.abs(fromIndex - i);\n        let delay = duration * distance;\n        if (easing) {\n            const maxDelay = total * duration;\n            const easingFunction = getEasingFunction(easing);\n            delay = easingFunction(delay / maxDelay) * maxDelay;\n        }\n        return start + delay;\n    };\n}\nfunction getFromIndex(from, total) {\n    if (from === \"first\") {\n        return 0;\n    }\n    else {\n        const lastIndex = total - 1;\n        return from === \"last\" ? lastIndex : lastIndex / 2;\n    }\n}\nfunction resolveOption(option, i, total) {\n    return isFunction(option) ? option(i, total) : option;\n}\n\nexport { getFromIndex, resolveOption, stagger };\n","import { Animation } from '@motionone/animation';\nimport { createAnimate } from './create-animate.es.js';\n\nconst animate = createAnimate(Animation);\n\nexport { animate };\n","import { invariant } from 'hey-listen';\nimport { animateStyle } from './animate-style.es.js';\nimport { getOptions } from './utils/options.es.js';\nimport { resolveElements } from '../utils/resolve-elements.es.js';\nimport { withControls } from './utils/controls.es.js';\nimport { resolveOption } from '../utils/stagger.es.js';\n\nfunction createAnimate(AnimatePolyfill) {\n    return function animate(elements, keyframes, options = {}) {\n        elements = resolveElements(elements);\n        const numElements = elements.length;\n        invariant(Boolean(numElements), \"No valid element provided.\");\n        invariant(Boolean(keyframes), \"No keyframes defined.\");\n        /**\n         * Create and start new animations\n         */\n        const animationFactories = [];\n        for (let i = 0; i < numElements; i++) {\n            const element = elements[i];\n            for (const key in keyframes) {\n                const valueOptions = getOptions(options, key);\n                valueOptions.delay = resolveOption(valueOptions.delay, i, numElements);\n                const animation = animateStyle(element, key, keyframes[key], valueOptions, AnimatePolyfill);\n                animationFactories.push(animation);\n            }\n        }\n        return withControls(animationFactories, options, \n        /**\n         * TODO:\n         * If easing is set to spring or glide, duration will be dynamically\n         * generated. Ideally we would dynamically generate this from\n         * animation.effect.getComputedTiming().duration but this isn't\n         * supported in iOS13 or our number polyfill. Perhaps it's possible\n         * to Proxy animations returned from animateStyle that has duration\n         * as a getter.\n         */\n        options.duration);\n    };\n}\n\nexport { createAnimate };\n","function resolveElements(elements, selectorCache) {\n    var _a;\n    if (typeof elements === \"string\") {\n        if (selectorCache) {\n            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = document.querySelectorAll(elements));\n            elements = selectorCache[elements];\n        }\n        else {\n            elements = document.querySelectorAll(elements);\n        }\n    }\n    else if (elements instanceof Element) {\n        elements = [elements];\n    }\n    /**\n     * Return an empty array\n     */\n    return Array.from(elements || []);\n}\n\nexport { resolveElements };\n","import { animate as animate$1, withControls } from '@motionone/dom';\nimport { isFunction } from '@motionone/utils';\nimport { Animation } from '@motionone/animation';\n\nfunction animateProgress(target, options = {}) {\n    return withControls([\n        () => {\n            const animation = new Animation(target, [0, 1], options);\n            animation.finished.catch(() => { });\n            return animation;\n        },\n    ], options, options.duration);\n}\nfunction animate(target, keyframesOrOptions, options) {\n    const factory = isFunction(target) ? animateProgress : animate$1;\n    return factory(target, keyframesOrOptions, options);\n}\n\nexport { animate, animateProgress };\n","import{noChange as t}from\"../lit-html.js\";import{directive as i,Directive as s,PartType as r}from\"../directive.js\";\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */const o=i(class extends s{constructor(t){var i;if(super(t),t.type!==r.ATTRIBUTE||\"class\"!==t.name||(null===(i=t.strings)||void 0===i?void 0:i.length)>2)throw Error(\"`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.\")}render(t){return\" \"+Object.keys(t).filter((i=>t[i])).join(\" \")+\" \"}update(i,[s]){var r,o;if(void 0===this.it){this.it=new Set,void 0!==i.strings&&(this.nt=new Set(i.strings.join(\" \").split(/\\s/).filter((t=>\"\"!==t))));for(const t in s)s[t]&&!(null===(r=this.nt)||void 0===r?void 0:r.has(t))&&this.it.add(t);return this.render(s)}const e=i.element.classList;this.it.forEach((t=>{t in s||(e.remove(t),this.it.delete(t))}));for(const t in s){const i=!!s[t];i===this.it.has(t)||(null===(o=this.nt)||void 0===o?void 0:o.has(t))||(i?(e.add(t),this.it.add(t)):(e.remove(t),this.it.delete(t)))}return t}});export{o as classMap};\n//# sourceMappingURL=class-map.js.map\n","import{nothing as t}from\"../lit-html.js\";\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */const l=l=>null!=l?l:t;export{l as ifDefined};\n//# sourceMappingURL=if-defined.js.map\n"],"names":["defaults","duration","delay","endDelay","repeat","easing","time","ms","seconds","s","milliseconds","noop","noopReturn","v","stopAnimation","animation","needsCommit","playState","stop","commitStyles","cancel","e","createAnimation","factory","withControls","animationFactory","options","Proxy","animations","map","filter","Boolean","controls","get","target","key","activeAnimation","finished","Promise","all","selectFinished","catch","forEach","callback","undefined","set","value","i","length","isEasingGenerator","isEasingList","Array","isArray","mix","min","max","progress","fillOffset","offset","remaining","offsetProgress","push","wrap","rangeSize","clamp","Math","interpolate","output","input","defaultOffset","remainder","t","progressInRange","segmentEasing","getEasingForSegment","calcBezier","a1","a2","subdivisionPrecision","subdivisionMaxIterations","cubicBezier","mX1","mY1","mX2","mY2","getTForX","aX","x","lowerBound","upperBound","currentX","currentT","abs","binarySubdivide","isFunction","isCubicBezier","namedEasings","ease","functionArgsRegex","definition","namedEasing","startsWith","args","exec","argsArray","split","steps","direction","expanded","rounded","floor","ceil","parseFloat","trim","Animation","constructor","keyframes","initialDuration","autoplay","this","startTime","rate","cancelTimestamp","totalDuration","resolve","reject","custom","updateDuration","interpolate$1","tick","timestamp","_a","pauseTime","currentIteration","iterationProgress","iterationIsOdd","p","latest","call","frameRequestId","requestAnimationFrame","play","now","performance","pause","finish","cancelAnimationFrame","reverse","currentTime","playbackRate","MotionValue","setAnimation","then","clearAnimation","generator","data","WeakMap","getAnimationData","element","has","transforms","values","Map","axes","transformAlias","y","z","rotation","syntax","initialValue","toDefaultUnit","baseTransformProperties","translate","rotate","scale","skew","transformDefinitions","asTransformCssVar","name","axis","compareTransformOrder","a","b","indexOf","transformLookup","Set","isTransform","addTransformToElement","array","item","style","transform","buildTransformTemplate","sort","reduce","transformListToString","template","isCssVar","registeredProperties","testAnimation","document","createElement","animate","featureTests","cssRegisterProperty","CSS","Object","hasOwnProperty","waapi","Element","prototype","partialKeyframes","opacity","linearEasing","results","supports","convertEasing","points","numPoints","round","substring","generateLinearEasingPoints","cubicBezierAsString","c","d","keyframesList","getStyleName","getPropertyValue","getComputedStyle","setProperty","isString","animateStyle","keyframesDefinition","AnimationPolyfill","record","window","__MOTION_DEV_TOOLS_RECORD","isRecording","persist","allowWebkitAcceleration","valueIsTransform","canAnimateNatively","motionValue","motionValues","getMotionValue","readInitialValue","_b","hydrateKeyframes","toUnit","finalKeyframe","unit","match","getUnitConverter","add","registerProperty","inherits","registerCssVariable","some","unshift","animationOptions","iterations","fill","thisEasing","onfinish","oncancel","assign","getOptions","resolveOption","option","total","AnimatePolyfill","elements","numElements","selectorCache","querySelectorAll","from","resolveElements","animationFactories","valueOptions","animateProgress","keyframesOrOptions","o","super","type","ATTRIBUTE","strings","Error","render","keys","join","update","r","it","nt","classList","remove","delete","l"],"sourceRoot":""}