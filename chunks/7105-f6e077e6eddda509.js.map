{"version":3,"file":"static/chunks/7105-f6e077e6eddda509.js","mappings":"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","sources":["webpack://_N_E/./node_modules/viem/_esm/utils/encoding/fromBytes.js","webpack://_N_E/./node_modules/viem/_esm/utils/abi/decodeAbiParameters.js","webpack://_N_E/./node_modules/viem/_esm/utils/abi/decodeEventLog.js","webpack://_N_E/./node_modules/viem/_esm/utils/abi/decodeFunctionData.js","webpack://_N_E/./node_modules/viem/_esm/utils/abi/decodeFunctionResult.js","webpack://_N_E/./node_modules/viem/_esm/errors/log.js","webpack://_N_E/./node_modules/viem/_esm/utils/abi/encodeEventTopics.js","webpack://_N_E/./node_modules/viem/node_modules/abitype/dist/esm/errors.js","webpack://_N_E/./node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js","webpack://_N_E/./node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js","webpack://_N_E/./node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/signature.js","webpack://_N_E/./node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbi.js","webpack://_N_E/./node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js","webpack://_N_E/./node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js","webpack://_N_E/./node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/struct.js","webpack://_N_E/./node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/structs.js","webpack://_N_E/./node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js","webpack://_N_E/./node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/cache.js","webpack://_N_E/./node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/utils.js"],"sourcesContent":["import { InvalidBytesBooleanError } from '../../errors/encoding.js';\nimport { trim } from '../data/trim.js';\nimport { assertSize, hexToBigInt, hexToNumber, } from './fromHex.js';\nimport { bytesToHex } from './toHex.js';\n/**\n * Decodes a byte array into a UTF-8 string, hex value, number, bigint or boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes\n * - Example: https://viem.sh/docs/utilities/fromBytes#usage\n *\n * @param bytes Byte array to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(new Uint8Array([1, 164]), 'number')\n * // 420\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(\n *   new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]),\n *   'string'\n * )\n * // 'Hello world'\n */\nexport function fromBytes(bytes, toOrOpts) {\n    const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts;\n    const to = opts.to;\n    if (to === 'number')\n        return bytesToNumber(bytes, opts);\n    if (to === 'bigint')\n        return bytesToBigInt(bytes, opts);\n    if (to === 'boolean')\n        return bytesToBool(bytes, opts);\n    if (to === 'string')\n        return bytesToString(bytes, opts);\n    return bytesToHex(bytes, opts);\n}\n/**\n * Decodes a byte array into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobigint\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { bytesToBigInt } from 'viem'\n * const data = bytesToBigInt(new Uint8Array([1, 164]))\n * // 420n\n */\nexport function bytesToBigInt(bytes, opts = {}) {\n    if (typeof opts.size !== 'undefined')\n        assertSize(bytes, { size: opts.size });\n    const hex = bytesToHex(bytes, opts);\n    return hexToBigInt(hex, opts);\n}\n/**\n * Decodes a byte array into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobool\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { bytesToBool } from 'viem'\n * const data = bytesToBool(new Uint8Array([1]))\n * // true\n */\nexport function bytesToBool(bytes_, opts = {}) {\n    let bytes = bytes_;\n    if (typeof opts.size !== 'undefined') {\n        assertSize(bytes, { size: opts.size });\n        bytes = trim(bytes);\n    }\n    if (bytes.length > 1 || bytes[0] > 1)\n        throw new InvalidBytesBooleanError(bytes);\n    return Boolean(bytes[0]);\n}\n/**\n * Decodes a byte array into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestonumber\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { bytesToNumber } from 'viem'\n * const data = bytesToNumber(new Uint8Array([1, 164]))\n * // 420\n */\nexport function bytesToNumber(bytes, opts = {}) {\n    if (typeof opts.size !== 'undefined')\n        assertSize(bytes, { size: opts.size });\n    const hex = bytesToHex(bytes, opts);\n    return hexToNumber(hex, opts);\n}\n/**\n * Decodes a byte array into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestostring\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { bytesToString } from 'viem'\n * const data = bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // 'Hello world'\n */\nexport function bytesToString(bytes_, opts = {}) {\n    let bytes = bytes_;\n    if (typeof opts.size !== 'undefined') {\n        assertSize(bytes, { size: opts.size });\n        bytes = trim(bytes, { dir: 'right' });\n    }\n    return new TextDecoder().decode(bytes);\n}\n//# sourceMappingURL=fromBytes.js.map","import { AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, InvalidAbiDecodingTypeError, } from '../../errors/abi.js';\nimport { checksumAddress, } from '../address/getAddress.js';\nimport { createCursor, } from '../cursor.js';\nimport { size } from '../data/size.js';\nimport { sliceBytes } from '../data/slice.js';\nimport { trim } from '../data/trim.js';\nimport { bytesToBigInt, bytesToBool, bytesToNumber, bytesToString, } from '../encoding/fromBytes.js';\nimport { hexToBytes } from '../encoding/toBytes.js';\nimport { bytesToHex } from '../encoding/toHex.js';\nimport { getArrayComponents } from './encodeAbiParameters.js';\nexport function decodeAbiParameters(params, data) {\n    const bytes = typeof data === 'string' ? hexToBytes(data) : data;\n    const cursor = createCursor(bytes);\n    if (size(bytes) === 0 && params.length > 0)\n        throw new AbiDecodingZeroDataError();\n    if (size(data) && size(data) < 32)\n        throw new AbiDecodingDataSizeTooSmallError({\n            data: typeof data === 'string' ? data : bytesToHex(data),\n            params: params,\n            size: size(data),\n        });\n    let consumed = 0;\n    const values = [];\n    for (let i = 0; i < params.length; ++i) {\n        const param = params[i];\n        cursor.setPosition(consumed);\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            staticPosition: 0,\n        });\n        consumed += consumed_;\n        values.push(data);\n    }\n    return values;\n}\nfunction decodeParameter(cursor, param, { staticPosition }) {\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return decodeArray(cursor, { ...param, type }, { length, staticPosition });\n    }\n    if (param.type === 'tuple')\n        return decodeTuple(cursor, param, { staticPosition });\n    if (param.type === 'address')\n        return decodeAddress(cursor);\n    if (param.type === 'bool')\n        return decodeBool(cursor);\n    if (param.type.startsWith('bytes'))\n        return decodeBytes(cursor, param, { staticPosition });\n    if (param.type.startsWith('uint') || param.type.startsWith('int'))\n        return decodeNumber(cursor, param);\n    if (param.type === 'string')\n        return decodeString(cursor, { staticPosition });\n    throw new InvalidAbiDecodingTypeError(param.type, {\n        docsPath: '/docs/contract/decodeAbiParameters',\n    });\n}\n////////////////////////////////////////////////////////////////////\n// Type Decoders\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\nfunction decodeAddress(cursor) {\n    const value = cursor.readBytes(32);\n    return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32];\n}\nfunction decodeArray(cursor, param, { length, staticPosition }) {\n    // If the length of the array is not known in advance (dynamic array),\n    // this means we will need to wonder off to the pointer and decode.\n    if (!length) {\n        // Dealing with a dynamic type, so get the offset of the array data.\n        const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const startOfData = start + sizeOfLength;\n        // Get the length of the array from the offset.\n        cursor.setPosition(start);\n        const length = bytesToNumber(cursor.readBytes(sizeOfLength));\n        // Check if the array has any dynamic children.\n        const dynamicChild = hasDynamicChild(param);\n        let consumed = 0;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n            // Otherwise, elements will be the size of their encoding (consumed bytes).\n            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n            const [data, consumed_] = decodeParameter(cursor, param, {\n                staticPosition: startOfData,\n            });\n            consumed += consumed_;\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance,\n    // and the length of an element deeply nested in the array is not known,\n    // we need to decode the offset of the array data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the array data.\n        const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // Move cursor along to the next slot (next offset pointer).\n            cursor.setPosition(start + i * 32);\n            const [data] = decodeParameter(cursor, param, {\n                staticPosition: start,\n            });\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance and the array is deeply static,\n    // then we can just decode each element in sequence.\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            staticPosition: staticPosition + consumed,\n        });\n        consumed += consumed_;\n        value.push(data);\n    }\n    return [value, consumed];\n}\nfunction decodeBool(cursor) {\n    return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32];\n}\nfunction decodeBytes(cursor, param, { staticPosition }) {\n    const [_, size] = param.type.split('bytes');\n    if (!size) {\n        // Dealing with dynamic types, so get the offset of the bytes data.\n        const offset = bytesToNumber(cursor.readBytes(32));\n        // Set position of the cursor to start of bytes data.\n        cursor.setPosition(staticPosition + offset);\n        const length = bytesToNumber(cursor.readBytes(32));\n        // If there is no length, we have zero data.\n        if (length === 0) {\n            // As we have gone wondering, restore to the original position + next slot.\n            cursor.setPosition(staticPosition + 32);\n            return ['0x', 32];\n        }\n        const data = cursor.readBytes(length);\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [bytesToHex(data), 32];\n    }\n    const value = bytesToHex(cursor.readBytes(Number.parseInt(size), 32));\n    return [value, 32];\n}\nfunction decodeNumber(cursor, param) {\n    const signed = param.type.startsWith('int');\n    const size = Number.parseInt(param.type.split('int')[1] || '256');\n    const value = cursor.readBytes(32);\n    return [\n        size > 48\n            ? bytesToBigInt(value, { signed })\n            : bytesToNumber(value, { signed }),\n        32,\n    ];\n}\nfunction decodeTuple(cursor, param, { staticPosition }) {\n    // Tuples can have unnamed components (i.e. they are arrays), so we must\n    // determine whether the tuple is named or unnamed. In the case of a named\n    // tuple, the value will be an object where each property is the name of the\n    // component. In the case of an unnamed tuple, the value will be an array.\n    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);\n    // Initialize the value to an object or an array, depending on whether the\n    // tuple is named or unnamed.\n    const value = hasUnnamedChild ? [] : {};\n    let consumed = 0;\n    // If the tuple has a dynamic child, we must first decode the offset to the\n    // tuple data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the tuple data.\n        const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of referencing slot + offset.\n        const start = staticPosition + offset;\n        for (let i = 0; i < param.components.length; ++i) {\n            const component = param.components[i];\n            cursor.setPosition(start + consumed);\n            const [data, consumed_] = decodeParameter(cursor, component, {\n                staticPosition: start,\n            });\n            consumed += consumed_;\n            value[hasUnnamedChild ? i : component?.name] = data;\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the tuple has static children, we can just decode each component\n    // in sequence.\n    for (let i = 0; i < param.components.length; ++i) {\n        const component = param.components[i];\n        const [data, consumed_] = decodeParameter(cursor, component, {\n            staticPosition,\n        });\n        value[hasUnnamedChild ? i : component?.name] = data;\n        consumed += consumed_;\n    }\n    return [value, consumed];\n}\nfunction decodeString(cursor, { staticPosition }) {\n    // Get offset to start of string data.\n    const offset = bytesToNumber(cursor.readBytes(32));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    cursor.setPosition(start);\n    const length = bytesToNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data (empty string).\n    if (length === 0) {\n        cursor.setPosition(staticPosition + 32);\n        return ['', 32];\n    }\n    const data = cursor.readBytes(length, 32);\n    const value = bytesToString(trim(data));\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n}\nfunction hasDynamicChild(param) {\n    const { type } = param;\n    if (type === 'string')\n        return true;\n    if (type === 'bytes')\n        return true;\n    if (type.endsWith('[]'))\n        return true;\n    if (type === 'tuple')\n        return param.components?.some(hasDynamicChild);\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents &&\n        hasDynamicChild({ ...param, type: arrayComponents[1] }))\n        return true;\n    return false;\n}\n//# sourceMappingURL=decodeAbiParameters.js.map","import { AbiDecodingDataSizeTooSmallError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, } from '../../errors/abi.js';\nimport { size } from '../data/size.js';\nimport { toEventSelector, } from '../hash/toEventSelector.js';\nimport { PositionOutOfBoundsError } from '../../errors/cursor.js';\nimport { decodeAbiParameters, } from './decodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nconst docsPath = '/docs/contract/decodeEventLog';\nexport function decodeEventLog(parameters) {\n    const { abi, data, strict: strict_, topics, } = parameters;\n    const strict = strict_ ?? true;\n    const [signature, ...argTopics] = topics;\n    if (!signature)\n        throw new AbiEventSignatureEmptyTopicsError({ docsPath });\n    const abiItem = abi.find((x) => x.type === 'event' &&\n        signature === toEventSelector(formatAbiItem(x)));\n    if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')\n        throw new AbiEventSignatureNotFoundError(signature, { docsPath });\n    const { name, inputs } = abiItem;\n    const isUnnamed = inputs?.some((x) => !('name' in x && x.name));\n    const args = isUnnamed ? [] : {};\n    // Decode topics (indexed args).\n    const indexedInputs = inputs\n        .map((x, i) => [x, i])\n        .filter(([x]) => 'indexed' in x && x.indexed);\n    for (let i = 0; i < indexedInputs.length; i++) {\n        const [param, argIndex] = indexedInputs[i];\n        const topic = argTopics[i];\n        if (!topic)\n            throw new DecodeLogTopicsMismatch({\n                abiItem,\n                param: param,\n            });\n        args[isUnnamed ? argIndex : param.name || argIndex] = decodeTopic({\n            param,\n            value: topic,\n        });\n    }\n    // Decode data (non-indexed args).\n    const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed));\n    if (nonIndexedInputs.length > 0) {\n        if (data && data !== '0x') {\n            try {\n                const decodedData = decodeAbiParameters(nonIndexedInputs, data);\n                if (decodedData) {\n                    if (isUnnamed)\n                        for (let i = 0; i < inputs.length; i++)\n                            args[i] = args[i] ?? decodedData.shift();\n                    else\n                        for (let i = 0; i < nonIndexedInputs.length; i++)\n                            args[nonIndexedInputs[i].name] = decodedData[i];\n                }\n            }\n            catch (err) {\n                if (strict) {\n                    if (err instanceof AbiDecodingDataSizeTooSmallError ||\n                        err instanceof PositionOutOfBoundsError)\n                        throw new DecodeLogDataMismatch({\n                            abiItem,\n                            data: data,\n                            params: nonIndexedInputs,\n                            size: size(data),\n                        });\n                    throw err;\n                }\n            }\n        }\n        else if (strict) {\n            throw new DecodeLogDataMismatch({\n                abiItem,\n                data: '0x',\n                params: nonIndexedInputs,\n                size: 0,\n            });\n        }\n    }\n    return {\n        eventName: name,\n        args: Object.values(args).length > 0 ? args : undefined,\n    };\n}\nfunction decodeTopic({ param, value }) {\n    if (param.type === 'string' ||\n        param.type === 'bytes' ||\n        param.type === 'tuple' ||\n        param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n        return value;\n    const decodedArg = decodeAbiParameters([param], value) || [];\n    return decodedArg[0];\n}\n//# sourceMappingURL=decodeEventLog.js.map","import { AbiFunctionSignatureNotFoundError } from '../../errors/abi.js';\nimport { slice } from '../data/slice.js';\nimport { toFunctionSelector, } from '../hash/toFunctionSelector.js';\nimport { decodeAbiParameters, } from './decodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nexport function decodeFunctionData(parameters) {\n    const { abi, data } = parameters;\n    const signature = slice(data, 0, 4);\n    const description = abi.find((x) => x.type === 'function' &&\n        signature === toFunctionSelector(formatAbiItem(x)));\n    if (!description)\n        throw new AbiFunctionSignatureNotFoundError(signature, {\n            docsPath: '/docs/contract/decodeFunctionData',\n        });\n    return {\n        functionName: description.name,\n        args: ('inputs' in description &&\n            description.inputs &&\n            description.inputs.length > 0\n            ? decodeAbiParameters(description.inputs, slice(data, 4))\n            : undefined),\n    };\n}\n//# sourceMappingURL=decodeFunctionData.js.map","import { AbiFunctionNotFoundError, AbiFunctionOutputsNotFoundError, } from '../../errors/abi.js';\nimport { decodeAbiParameters, } from './decodeAbiParameters.js';\nimport { getAbiItem } from './getAbiItem.js';\nconst docsPath = '/docs/contract/decodeFunctionResult';\nexport function decodeFunctionResult(parameters) {\n    const { abi, args, functionName, data } = parameters;\n    let abiItem = abi[0];\n    if (functionName) {\n        const item = getAbiItem({ abi, args, name: functionName });\n        if (!item)\n            throw new AbiFunctionNotFoundError(functionName, { docsPath });\n        abiItem = item;\n    }\n    if (abiItem.type !== 'function')\n        throw new AbiFunctionNotFoundError(undefined, { docsPath });\n    if (!abiItem.outputs)\n        throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath });\n    const values = decodeAbiParameters(abiItem.outputs, data);\n    if (values && values.length > 1)\n        return values;\n    if (values && values.length === 1)\n        return values[0];\n    return undefined;\n}\n//# sourceMappingURL=decodeFunctionResult.js.map","import { BaseError } from './base.js';\nexport class FilterTypeNotSupportedError extends BaseError {\n    constructor(type) {\n        super(`Filter type \"${type}\" is not supported.`, {\n            name: 'FilterTypeNotSupportedError',\n        });\n    }\n}\n//# sourceMappingURL=log.js.map","import { AbiEventNotFoundError, } from '../../errors/abi.js';\nimport { FilterTypeNotSupportedError, } from '../../errors/log.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { toEventSelector, } from '../hash/toEventSelector.js';\nimport { encodeAbiParameters, } from './encodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nimport { getAbiItem } from './getAbiItem.js';\nconst docsPath = '/docs/contract/encodeEventTopics';\nexport function encodeEventTopics(parameters) {\n    const { abi, eventName, args } = parameters;\n    let abiItem = abi[0];\n    if (eventName) {\n        const item = getAbiItem({ abi, name: eventName });\n        if (!item)\n            throw new AbiEventNotFoundError(eventName, { docsPath });\n        abiItem = item;\n    }\n    if (abiItem.type !== 'event')\n        throw new AbiEventNotFoundError(undefined, { docsPath });\n    const definition = formatAbiItem(abiItem);\n    const signature = toEventSelector(definition);\n    let topics = [];\n    if (args && 'inputs' in abiItem) {\n        const indexedInputs = abiItem.inputs?.filter((param) => 'indexed' in param && param.indexed);\n        const args_ = Array.isArray(args)\n            ? args\n            : Object.values(args).length > 0\n                ? (indexedInputs?.map((x) => args[x.name]) ?? [])\n                : [];\n        if (args_.length > 0) {\n            topics =\n                indexedInputs?.map((param, i) => {\n                    if (Array.isArray(args_[i]))\n                        return args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] }));\n                    return typeof args_[i] !== 'undefined' && args_[i] !== null\n                        ? encodeArg({ param, value: args_[i] })\n                        : null;\n                }) ?? [];\n        }\n    }\n    return [signature, ...topics];\n}\nfunction encodeArg({ param, value, }) {\n    if (param.type === 'string' || param.type === 'bytes')\n        return keccak256(toBytes(value));\n    if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n        throw new FilterTypeNotSupportedError(param.type);\n    return encodeAbiParameters([param], [value]);\n}\n//# sourceMappingURL=encodeEventTopics.js.map","import { version } from './version.js';\nexport class BaseError extends Error {\n    constructor(shortMessage, args = {}) {\n        const details = args.cause instanceof BaseError\n            ? args.cause.details\n            : args.cause?.message\n                ? args.cause.message\n                : args.details;\n        const docsPath = args.cause instanceof BaseError\n            ? args.cause.docsPath || args.docsPath\n            : args.docsPath;\n        const message = [\n            shortMessage || 'An error occurred.',\n            '',\n            ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n            ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),\n            ...(details ? [`Details: ${details}`] : []),\n            `Version: abitype@${version}`,\n        ].join('\\n');\n        super(message);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metaMessages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiTypeError'\n        });\n        if (args.cause)\n            this.cause = args.cause;\n        this.details = details;\n        this.docsPath = docsPath;\n        this.metaMessages = args.metaMessages;\n        this.shortMessage = shortMessage;\n    }\n}\n//# sourceMappingURL=errors.js.map","import { BaseError } from '../../errors.js';\nexport class InvalidAbiItemError extends BaseError {\n    constructor({ signature }) {\n        super('Failed to parse ABI item.', {\n            details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n            docsPath: '/api/human#parseabiitem-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiItemError'\n        });\n    }\n}\nexport class UnknownTypeError extends BaseError {\n    constructor({ type }) {\n        super('Unknown type.', {\n            metaMessages: [\n                `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownTypeError'\n        });\n    }\n}\nexport class UnknownSolidityTypeError extends BaseError {\n    constructor({ type }) {\n        super('Unknown type.', {\n            metaMessages: [`Type \"${type}\" is not a valid ABI type.`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownSolidityTypeError'\n        });\n    }\n}\n//# sourceMappingURL=abiItem.js.map","import { BaseError } from '../../errors.js';\nexport class InvalidAbiParameterError extends BaseError {\n    constructor({ param }) {\n        super('Failed to parse ABI parameter.', {\n            details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n            docsPath: '/api/human#parseabiparameter-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiParameterError'\n        });\n    }\n}\nexport class InvalidAbiParametersError extends BaseError {\n    constructor({ params }) {\n        super('Failed to parse ABI parameters.', {\n            details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n            docsPath: '/api/human#parseabiparameters-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiParametersError'\n        });\n    }\n}\nexport class InvalidParameterError extends BaseError {\n    constructor({ param }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidParameterError'\n        });\n    }\n}\nexport class SolidityProtectedKeywordError extends BaseError {\n    constructor({ param, name }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `\"${name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SolidityProtectedKeywordError'\n        });\n    }\n}\nexport class InvalidModifierError extends BaseError {\n    constructor({ param, type, modifier, }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `Modifier \"${modifier}\" not allowed${type ? ` in \"${type}\" type` : ''}.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidModifierError'\n        });\n    }\n}\nexport class InvalidFunctionModifierError extends BaseError {\n    constructor({ param, type, modifier, }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `Modifier \"${modifier}\" not allowed${type ? ` in \"${type}\" type` : ''}.`,\n                `Data location can only be specified for array, struct, or mapping types, but \"${modifier}\" was given.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidFunctionModifierError'\n        });\n    }\n}\nexport class InvalidAbiTypeParameterError extends BaseError {\n    constructor({ abiParameter, }) {\n        super('Invalid ABI parameter.', {\n            details: JSON.stringify(abiParameter, null, 2),\n            metaMessages: ['ABI parameter type is invalid.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiTypeParameterError'\n        });\n    }\n}\n//# sourceMappingURL=abiParameter.js.map","import { BaseError } from '../../errors.js';\nexport class InvalidSignatureError extends BaseError {\n    constructor({ signature, type, }) {\n        super(`Invalid ${type} signature.`, {\n            details: signature,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidSignatureError'\n        });\n    }\n}\nexport class UnknownSignatureError extends BaseError {\n    constructor({ signature }) {\n        super('Unknown signature.', {\n            details: signature,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownSignatureError'\n        });\n    }\n}\nexport class InvalidStructSignatureError extends BaseError {\n    constructor({ signature }) {\n        super('Invalid struct signature.', {\n            details: signature,\n            metaMessages: ['No properties exist.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidStructSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=signature.js.map","import { isStructSignature } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { parseSignature } from './runtime/utils.js';\n/**\n * Parses human-readable ABI into JSON {@link Abi}\n *\n * @param signatures - Human-Readable ABI\n * @returns Parsed {@link Abi}\n *\n * @example\n * const abi = parseAbi([\n *   //  ^? const abi: readonly [{ name: \"balanceOf\"; type: \"function\"; stateMutability:...\n *   'function balanceOf(address owner) view returns (uint256)',\n *   'event Transfer(address indexed from, address indexed to, uint256 amount)',\n * ])\n */\nexport function parseAbi(signatures) {\n    const structs = parseStructs(signatures);\n    const abi = [];\n    const length = signatures.length;\n    for (let i = 0; i < length; i++) {\n        const signature = signatures[i];\n        if (isStructSignature(signature))\n            continue;\n        abi.push(parseSignature(signature, structs));\n    }\n    return abi;\n}\n//# sourceMappingURL=parseAbi.js.map","import { InvalidAbiItemError } from './errors/abiItem.js';\nimport { isStructSignature } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { parseSignature } from './runtime/utils.js';\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiItem(signature) {\n    let abiItem;\n    if (typeof signature === 'string')\n        abiItem = parseSignature(signature);\n    else {\n        const structs = parseStructs(signature);\n        const length = signature.length;\n        for (let i = 0; i < length; i++) {\n            const signature_ = signature[i];\n            if (isStructSignature(signature_))\n                continue;\n            abiItem = parseSignature(signature_, structs);\n            break;\n        }\n    }\n    if (!abiItem)\n        throw new InvalidAbiItemError({ signature });\n    return abiItem;\n}\n//# sourceMappingURL=parseAbiItem.js.map","import { execTyped } from '../../regex.js';\n// https://regexr.com/7gmok\nconst errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/;\nexport function isErrorSignature(signature) {\n    return errorSignatureRegex.test(signature);\n}\nexport function execErrorSignature(signature) {\n    return execTyped(errorSignatureRegex, signature);\n}\n// https://regexr.com/7gmoq\nconst eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/;\nexport function isEventSignature(signature) {\n    return eventSignatureRegex.test(signature);\n}\nexport function execEventSignature(signature) {\n    return execTyped(eventSignatureRegex, signature);\n}\n// https://regexr.com/7gmot\nconst functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\\s?\\((?<returns>.*?)\\))?$/;\nexport function isFunctionSignature(signature) {\n    return functionSignatureRegex.test(signature);\n}\nexport function execFunctionSignature(signature) {\n    return execTyped(functionSignatureRegex, signature);\n}\n// https://regexr.com/7gmp3\nconst structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \\{(?<properties>.*?)\\}$/;\nexport function isStructSignature(signature) {\n    return structSignatureRegex.test(signature);\n}\nexport function execStructSignature(signature) {\n    return execTyped(structSignatureRegex, signature);\n}\n// https://regexr.com/78u01\nconst constructorSignatureRegex = /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/;\nexport function isConstructorSignature(signature) {\n    return constructorSignatureRegex.test(signature);\n}\nexport function execConstructorSignature(signature) {\n    return execTyped(constructorSignatureRegex, signature);\n}\n// https://regexr.com/7srtn\nconst fallbackSignatureRegex = /^fallback\\(\\) external(?:\\s(?<stateMutability>payable{1}))?$/;\nexport function isFallbackSignature(signature) {\n    return fallbackSignatureRegex.test(signature);\n}\nexport function execFallbackSignature(signature) {\n    return execTyped(fallbackSignatureRegex, signature);\n}\n// https://regexr.com/78u1k\nconst receiveSignatureRegex = /^receive\\(\\) external payable$/;\nexport function isReceiveSignature(signature) {\n    return receiveSignatureRegex.test(signature);\n}\nexport const modifiers = new Set([\n    'memory',\n    'indexed',\n    'storage',\n    'calldata',\n]);\nexport const eventModifiers = new Set(['indexed']);\nexport const functionModifiers = new Set([\n    'calldata',\n    'memory',\n    'storage',\n]);\n//# sourceMappingURL=signatures.js.map","import { BaseError } from '../../errors.js';\nexport class CircularReferenceError extends BaseError {\n    constructor({ type }) {\n        super('Circular reference detected.', {\n            metaMessages: [`Struct \"${type}\" is a circular reference.`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'CircularReferenceError'\n        });\n    }\n}\n//# sourceMappingURL=struct.js.map","import { execTyped, isTupleRegex } from '../../regex.js';\nimport { UnknownTypeError } from '../errors/abiItem.js';\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js';\nimport { InvalidSignatureError, InvalidStructSignatureError, } from '../errors/signature.js';\nimport { CircularReferenceError } from '../errors/struct.js';\nimport { execStructSignature, isStructSignature } from './signatures.js';\nimport { isSolidityType, parseAbiParameter } from './utils.js';\nexport function parseStructs(signatures) {\n    // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n    const shallowStructs = {};\n    const signaturesLength = signatures.length;\n    for (let i = 0; i < signaturesLength; i++) {\n        const signature = signatures[i];\n        if (!isStructSignature(signature))\n            continue;\n        const match = execStructSignature(signature);\n        if (!match)\n            throw new InvalidSignatureError({ signature, type: 'struct' });\n        const properties = match.properties.split(';');\n        const components = [];\n        const propertiesLength = properties.length;\n        for (let k = 0; k < propertiesLength; k++) {\n            const property = properties[k];\n            const trimmed = property.trim();\n            if (!trimmed)\n                continue;\n            const abiParameter = parseAbiParameter(trimmed, {\n                type: 'struct',\n            });\n            components.push(abiParameter);\n        }\n        if (!components.length)\n            throw new InvalidStructSignatureError({ signature });\n        shallowStructs[match.name] = components;\n    }\n    // Resolve nested structs inside each parameter\n    const resolvedStructs = {};\n    const entries = Object.entries(shallowStructs);\n    const entriesLength = entries.length;\n    for (let i = 0; i < entriesLength; i++) {\n        const [name, parameters] = entries[i];\n        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);\n    }\n    return resolvedStructs;\n}\nconst typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters, structs, ancestors = new Set()) {\n    const components = [];\n    const length = abiParameters.length;\n    for (let i = 0; i < length; i++) {\n        const abiParameter = abiParameters[i];\n        const isTuple = isTupleRegex.test(abiParameter.type);\n        if (isTuple)\n            components.push(abiParameter);\n        else {\n            const match = execTyped(typeWithoutTupleRegex, abiParameter.type);\n            if (!match?.type)\n                throw new InvalidAbiTypeParameterError({ abiParameter });\n            const { array, type } = match;\n            if (type in structs) {\n                if (ancestors.has(type))\n                    throw new CircularReferenceError({ type });\n                components.push({\n                    ...abiParameter,\n                    type: `tuple${array ?? ''}`,\n                    components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type])),\n                });\n            }\n            else {\n                if (isSolidityType(type))\n                    components.push(abiParameter);\n                else\n                    throw new UnknownTypeError({ type });\n            }\n        }\n    }\n    return components;\n}\n//# sourceMappingURL=structs.js.map","import { BaseError } from '../../errors.js';\nexport class InvalidParenthesisError extends BaseError {\n    constructor({ current, depth }) {\n        super('Unbalanced parentheses.', {\n            metaMessages: [\n                `\"${current.trim()}\" has too many ${depth > 0 ? 'opening' : 'closing'} parentheses.`,\n            ],\n            details: `Depth \"${depth}\"`,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidParenthesisError'\n        });\n    }\n}\n//# sourceMappingURL=splitParameters.js.map","/**\n * Gets {@link parameterCache} cache key namespaced by {@link type}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`).\n * @param param ABI parameter string\n * @param type ABI parameter type\n * @returns Cache key for {@link parameterCache}\n */\nexport function getParameterCacheKey(param, type, structs) {\n    let structKey = '';\n    if (structs)\n        for (const struct of Object.entries(structs)) {\n            if (!struct)\n                continue;\n            let propertyKey = '';\n            for (const property of struct[1]) {\n                propertyKey += `[${property.type}${property.name ? `:${property.name}` : ''}]`;\n            }\n            structKey += `(${struct[0]}{${propertyKey}})`;\n        }\n    if (type)\n        return `${type}:${param}${structKey}`;\n    return param;\n}\n/**\n * Basic cache seeded with common ABI parameter strings.\n *\n * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**\n */\nexport const parameterCache = new Map([\n    // Unnamed\n    ['address', { type: 'address' }],\n    ['bool', { type: 'bool' }],\n    ['bytes', { type: 'bytes' }],\n    ['bytes32', { type: 'bytes32' }],\n    ['int', { type: 'int256' }],\n    ['int256', { type: 'int256' }],\n    ['string', { type: 'string' }],\n    ['uint', { type: 'uint256' }],\n    ['uint8', { type: 'uint8' }],\n    ['uint16', { type: 'uint16' }],\n    ['uint24', { type: 'uint24' }],\n    ['uint32', { type: 'uint32' }],\n    ['uint64', { type: 'uint64' }],\n    ['uint96', { type: 'uint96' }],\n    ['uint112', { type: 'uint112' }],\n    ['uint160', { type: 'uint160' }],\n    ['uint192', { type: 'uint192' }],\n    ['uint256', { type: 'uint256' }],\n    // Named\n    ['address owner', { type: 'address', name: 'owner' }],\n    ['address to', { type: 'address', name: 'to' }],\n    ['bool approved', { type: 'bool', name: 'approved' }],\n    ['bytes _data', { type: 'bytes', name: '_data' }],\n    ['bytes data', { type: 'bytes', name: 'data' }],\n    ['bytes signature', { type: 'bytes', name: 'signature' }],\n    ['bytes32 hash', { type: 'bytes32', name: 'hash' }],\n    ['bytes32 r', { type: 'bytes32', name: 'r' }],\n    ['bytes32 root', { type: 'bytes32', name: 'root' }],\n    ['bytes32 s', { type: 'bytes32', name: 's' }],\n    ['string name', { type: 'string', name: 'name' }],\n    ['string symbol', { type: 'string', name: 'symbol' }],\n    ['string tokenURI', { type: 'string', name: 'tokenURI' }],\n    ['uint tokenId', { type: 'uint256', name: 'tokenId' }],\n    ['uint8 v', { type: 'uint8', name: 'v' }],\n    ['uint256 balance', { type: 'uint256', name: 'balance' }],\n    ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],\n    ['uint256 value', { type: 'uint256', name: 'value' }],\n    // Indexed\n    [\n        'event:address indexed from',\n        { type: 'address', name: 'from', indexed: true },\n    ],\n    ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],\n    [\n        'event:uint indexed tokenId',\n        { type: 'uint256', name: 'tokenId', indexed: true },\n    ],\n    [\n        'event:uint256 indexed tokenId',\n        { type: 'uint256', name: 'tokenId', indexed: true },\n    ],\n]);\n//# sourceMappingURL=cache.js.map","import { bytesRegex, execTyped, integerRegex, isTupleRegex, } from '../../regex.js';\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js';\nimport { InvalidFunctionModifierError, InvalidModifierError, InvalidParameterError, SolidityProtectedKeywordError, } from '../errors/abiParameter.js';\nimport { InvalidSignatureError, UnknownSignatureError, } from '../errors/signature.js';\nimport { InvalidParenthesisError } from '../errors/splitParameters.js';\nimport { getParameterCacheKey, parameterCache } from './cache.js';\nimport { eventModifiers, execConstructorSignature, execErrorSignature, execEventSignature, execFallbackSignature, execFunctionSignature, functionModifiers, isConstructorSignature, isErrorSignature, isEventSignature, isFallbackSignature, isFunctionSignature, isReceiveSignature, } from './signatures.js';\nexport function parseSignature(signature, structs = {}) {\n    if (isFunctionSignature(signature))\n        return parseFunctionSignature(signature, structs);\n    if (isEventSignature(signature))\n        return parseEventSignature(signature, structs);\n    if (isErrorSignature(signature))\n        return parseErrorSignature(signature, structs);\n    if (isConstructorSignature(signature))\n        return parseConstructorSignature(signature, structs);\n    if (isFallbackSignature(signature))\n        return parseFallbackSignature(signature);\n    if (isReceiveSignature(signature))\n        return {\n            type: 'receive',\n            stateMutability: 'payable',\n        };\n    throw new UnknownSignatureError({ signature });\n}\nexport function parseFunctionSignature(signature, structs = {}) {\n    const match = execFunctionSignature(signature);\n    if (!match)\n        throw new InvalidSignatureError({ signature, type: 'function' });\n    const inputParams = splitParameters(match.parameters);\n    const inputs = [];\n    const inputLength = inputParams.length;\n    for (let i = 0; i < inputLength; i++) {\n        inputs.push(parseAbiParameter(inputParams[i], {\n            modifiers: functionModifiers,\n            structs,\n            type: 'function',\n        }));\n    }\n    const outputs = [];\n    if (match.returns) {\n        const outputParams = splitParameters(match.returns);\n        const outputLength = outputParams.length;\n        for (let i = 0; i < outputLength; i++) {\n            outputs.push(parseAbiParameter(outputParams[i], {\n                modifiers: functionModifiers,\n                structs,\n                type: 'function',\n            }));\n        }\n    }\n    return {\n        name: match.name,\n        type: 'function',\n        stateMutability: match.stateMutability ?? 'nonpayable',\n        inputs,\n        outputs,\n    };\n}\nexport function parseEventSignature(signature, structs = {}) {\n    const match = execEventSignature(signature);\n    if (!match)\n        throw new InvalidSignatureError({ signature, type: 'event' });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++)\n        abiParameters.push(parseAbiParameter(params[i], {\n            modifiers: eventModifiers,\n            structs,\n            type: 'event',\n        }));\n    return { name: match.name, type: 'event', inputs: abiParameters };\n}\nexport function parseErrorSignature(signature, structs = {}) {\n    const match = execErrorSignature(signature);\n    if (!match)\n        throw new InvalidSignatureError({ signature, type: 'error' });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++)\n        abiParameters.push(parseAbiParameter(params[i], { structs, type: 'error' }));\n    return { name: match.name, type: 'error', inputs: abiParameters };\n}\nexport function parseConstructorSignature(signature, structs = {}) {\n    const match = execConstructorSignature(signature);\n    if (!match)\n        throw new InvalidSignatureError({ signature, type: 'constructor' });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++)\n        abiParameters.push(parseAbiParameter(params[i], { structs, type: 'constructor' }));\n    return {\n        type: 'constructor',\n        stateMutability: match.stateMutability ?? 'nonpayable',\n        inputs: abiParameters,\n    };\n}\nexport function parseFallbackSignature(signature) {\n    const match = execFallbackSignature(signature);\n    if (!match)\n        throw new InvalidSignatureError({ signature, type: 'fallback' });\n    return {\n        type: 'fallback',\n        stateMutability: match.stateMutability ?? 'nonpayable',\n    };\n}\nconst abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst dynamicIntegerRegex = /^u?int$/;\nexport function parseAbiParameter(param, options) {\n    // optional namespace cache by `type`\n    const parameterCacheKey = getParameterCacheKey(param, options?.type, options?.structs);\n    if (parameterCache.has(parameterCacheKey))\n        return parameterCache.get(parameterCacheKey);\n    const isTuple = isTupleRegex.test(param);\n    const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n    if (!match)\n        throw new InvalidParameterError({ param });\n    if (match.name && isSolidityKeyword(match.name))\n        throw new SolidityProtectedKeywordError({ param, name: match.name });\n    const name = match.name ? { name: match.name } : {};\n    const indexed = match.modifier === 'indexed' ? { indexed: true } : {};\n    const structs = options?.structs ?? {};\n    let type;\n    let components = {};\n    if (isTuple) {\n        type = 'tuple';\n        const params = splitParameters(match.type);\n        const components_ = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            // remove `modifiers` from `options` to prevent from being added to tuple components\n            components_.push(parseAbiParameter(params[i], { structs }));\n        }\n        components = { components: components_ };\n    }\n    else if (match.type in structs) {\n        type = 'tuple';\n        components = { components: structs[match.type] };\n    }\n    else if (dynamicIntegerRegex.test(match.type)) {\n        type = `${match.type}256`;\n    }\n    else {\n        type = match.type;\n        if (!(options?.type === 'struct') && !isSolidityType(type))\n            throw new UnknownSolidityTypeError({ type });\n    }\n    if (match.modifier) {\n        // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n        if (!options?.modifiers?.has?.(match.modifier))\n            throw new InvalidModifierError({\n                param,\n                type: options?.type,\n                modifier: match.modifier,\n            });\n        // Check if resolved `type` is valid if there is a function modifier\n        if (functionModifiers.has(match.modifier) &&\n            !isValidDataLocation(type, !!match.array))\n            throw new InvalidFunctionModifierError({\n                param,\n                type: options?.type,\n                modifier: match.modifier,\n            });\n    }\n    const abiParameter = {\n        type: `${type}${match.array ?? ''}`,\n        ...name,\n        ...indexed,\n        ...components,\n    };\n    parameterCache.set(parameterCacheKey, abiParameter);\n    return abiParameter;\n}\n// s/o latika for this\nexport function splitParameters(params, result = [], current = '', depth = 0) {\n    const length = params.trim().length;\n    // biome-ignore lint/correctness/noUnreachable: recursive\n    for (let i = 0; i < length; i++) {\n        const char = params[i];\n        const tail = params.slice(i + 1);\n        switch (char) {\n            case ',':\n                return depth === 0\n                    ? splitParameters(tail, [...result, current.trim()])\n                    : splitParameters(tail, result, `${current}${char}`, depth);\n            case '(':\n                return splitParameters(tail, result, `${current}${char}`, depth + 1);\n            case ')':\n                return splitParameters(tail, result, `${current}${char}`, depth - 1);\n            default:\n                return splitParameters(tail, result, `${current}${char}`, depth);\n        }\n    }\n    if (current === '')\n        return result;\n    if (depth !== 0)\n        throw new InvalidParenthesisError({ current, depth });\n    result.push(current.trim());\n    return result;\n}\nexport function isSolidityType(type) {\n    return (type === 'address' ||\n        type === 'bool' ||\n        type === 'function' ||\n        type === 'string' ||\n        bytesRegex.test(type) ||\n        integerRegex.test(type));\n}\nconst protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\n/** @internal */\nexport function isSolidityKeyword(name) {\n    return (name === 'address' ||\n        name === 'bool' ||\n        name === 'function' ||\n        name === 'string' ||\n        name === 'tuple' ||\n        bytesRegex.test(name) ||\n        integerRegex.test(name) ||\n        protectedKeywordsRegex.test(name));\n}\n/** @internal */\nexport function isValidDataLocation(type, isArray) {\n    return isArray || type === 'bytes' || type === 'string' || type === 'tuple';\n}\n//# sourceMappingURL=utils.js.map"],"names":["bytesToBigInt","bytes","opts","size","hex","bytesToBool","bytes_","trim","length","Boolean","bytesToNumber","bytesToString","dir","TextDecoder","decode","decodeAbiParameters","params","data","cursor","consumed","values","i","param","setPosition","consumed_","decodeParameter","staticPosition","push","arrayComponents","type","start","readBytes","sizeOfOffset","startOfData","sizeOfLength","dynamicChild","hasDynamicChild","value","decodeArray","hasUnnamedChild","components","some","name","component","decodeTuple","slice","decodeAddress","decodeBool","startsWith","_","split","offset","Number","parseInt","decodeBytes","signed","decodeNumber","decodeString","docsPath","endsWith","decodeEventLog","parameters","abi","strict","strict_","topics","signature","argTopics","abiItem","find","x","inputs","isUnnamed","args","indexedInputs","map","filter","indexed","argIndex","topic","decodeTopic","nonIndexedInputs","decodedData","shift","err","eventName","Object","undefined","match","decodeFunctionData","description","functionName","decodeFunctionResult","item","outputs","FilterTypeNotSupportedError","constructor","super","encodeEventTopics","getAbiItem","definition","formatAbiItem","toEventSelector","args_","Array","isArray","j","encodeArg","keccak256","toBytes","encodeAbiParameters","BaseError","Error","shortMessage","details","cause","message","metaMessages","join","defineProperty","this","enumerable","configurable","writable","InvalidAbiItemError","JSON","stringify","UnknownTypeError","UnknownSolidityTypeError","InvalidAbiParametersError","InvalidParameterError","SolidityProtectedKeywordError","InvalidModifierError","modifier","InvalidFunctionModifierError","InvalidAbiTypeParameterError","abiParameter","InvalidSignatureError","UnknownSignatureError","InvalidStructSignatureError","parseAbi","signatures","structs","parseAbiItem","signature_","errorSignatureRegex","isErrorSignature","test","execErrorSignature","eventSignatureRegex","isEventSignature","execEventSignature","functionSignatureRegex","isFunctionSignature","execFunctionSignature","structSignatureRegex","isStructSignature","execStructSignature","constructorSignatureRegex","isConstructorSignature","execConstructorSignature","fallbackSignatureRegex","isFallbackSignature","execFallbackSignature","receiveSignatureRegex","isReceiveSignature","modifiers","Set","eventModifiers","functionModifiers","CircularReferenceError","parseStructs","shallowStructs","signaturesLength","properties","propertiesLength","k","trimmed","resolvedStructs","entries","entriesLength","resolveStructs","typeWithoutTupleRegex","abiParameters","ancestors","array","has","InvalidParenthesisError","current","depth","parameterCache","Map","parseSignature","inputParams","splitParameters","inputLength","parseAbiParameter","returns","outputParams","outputLength","stateMutability","parseFunctionSignature","parseEventSignature","parseErrorSignature","parseConstructorSignature","parseFallbackSignature","abiParameterWithoutTupleRegex","abiParameterWithTupleRegex","dynamicIntegerRegex","options","parameterCacheKey","structKey","struct","propertyKey","property","getParameterCacheKey","get","isTuple","protectedKeywordsRegex","isSolidityKeyword","components_","isSolidityType","isValidDataLocation","set","result","char","tail"],"sourceRoot":""}