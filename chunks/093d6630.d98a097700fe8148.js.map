{"version":3,"file":"static/chunks/093d6630.d98a097700fe8148.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@confio/ics23/build/generated/codecimpl.js"],"sourcesContent":["/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.ics23 = (function() {\n\n    /**\n     * Namespace ics23.\n     * @exports ics23\n     * @namespace\n     */\n    var ics23 = {};\n\n    /**\n     * HashOp enum.\n     * @name ics23.HashOp\n     * @enum {string}\n     * @property {number} NO_HASH=0 NO_HASH value\n     * @property {number} SHA256=1 SHA256 value\n     * @property {number} SHA512=2 SHA512 value\n     * @property {number} KECCAK=3 KECCAK value\n     * @property {number} RIPEMD160=4 RIPEMD160 value\n     * @property {number} BITCOIN=5 BITCOIN value\n     * @property {number} SHA512_256=6 SHA512_256 value\n     */\n    ics23.HashOp = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"NO_HASH\"] = 0;\n        values[valuesById[1] = \"SHA256\"] = 1;\n        values[valuesById[2] = \"SHA512\"] = 2;\n        values[valuesById[3] = \"KECCAK\"] = 3;\n        values[valuesById[4] = \"RIPEMD160\"] = 4;\n        values[valuesById[5] = \"BITCOIN\"] = 5;\n        values[valuesById[6] = \"SHA512_256\"] = 6;\n        return values;\n    })();\n\n    /**\n     * LengthOp defines how to process the key and value of the LeafOp\n     * to include length information. After encoding the length with the given\n     * algorithm, the length will be prepended to the key and value bytes.\n     * (Each one with it's own encoded length)\n     * @name ics23.LengthOp\n     * @enum {string}\n     * @property {number} NO_PREFIX=0 NO_PREFIX value\n     * @property {number} VAR_PROTO=1 VAR_PROTO value\n     * @property {number} VAR_RLP=2 VAR_RLP value\n     * @property {number} FIXED32_BIG=3 FIXED32_BIG value\n     * @property {number} FIXED32_LITTLE=4 FIXED32_LITTLE value\n     * @property {number} FIXED64_BIG=5 FIXED64_BIG value\n     * @property {number} FIXED64_LITTLE=6 FIXED64_LITTLE value\n     * @property {number} REQUIRE_32_BYTES=7 REQUIRE_32_BYTES value\n     * @property {number} REQUIRE_64_BYTES=8 REQUIRE_64_BYTES value\n     */\n    ics23.LengthOp = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"NO_PREFIX\"] = 0;\n        values[valuesById[1] = \"VAR_PROTO\"] = 1;\n        values[valuesById[2] = \"VAR_RLP\"] = 2;\n        values[valuesById[3] = \"FIXED32_BIG\"] = 3;\n        values[valuesById[4] = \"FIXED32_LITTLE\"] = 4;\n        values[valuesById[5] = \"FIXED64_BIG\"] = 5;\n        values[valuesById[6] = \"FIXED64_LITTLE\"] = 6;\n        values[valuesById[7] = \"REQUIRE_32_BYTES\"] = 7;\n        values[valuesById[8] = \"REQUIRE_64_BYTES\"] = 8;\n        return values;\n    })();\n\n    ics23.ExistenceProof = (function() {\n\n        /**\n         * Properties of an ExistenceProof.\n         * @memberof ics23\n         * @interface IExistenceProof\n         * @property {Uint8Array|null} [key] ExistenceProof key\n         * @property {Uint8Array|null} [value] ExistenceProof value\n         * @property {ics23.ILeafOp|null} [leaf] ExistenceProof leaf\n         * @property {Array.<ics23.IInnerOp>|null} [path] ExistenceProof path\n         */\n\n        /**\n         * Constructs a new ExistenceProof.\n         * @memberof ics23\n         * @classdesc ExistenceProof takes a key and a value and a set of steps to perform on it.\n         * The result of peforming all these steps will provide a \"root hash\", which can\n         * be compared to the value in a header.\n         * \n         * Since it is computationally infeasible to produce a hash collission for any of the used\n         * cryptographic hash functions, if someone can provide a series of operations to transform\n         * a given key and value into a root hash that matches some trusted root, these key and values\n         * must be in the referenced merkle tree.\n         * \n         * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,\n         * which should be controlled by a spec. Eg. with lengthOp as NONE,\n         * prefix = FOO, key = BAR, value = CHOICE\n         * and\n         * prefix = F, key = OOBAR, value = CHOICE\n         * would produce the same value.\n         * \n         * With LengthOp this is tricker but not impossible. Which is why the \"leafPrefixEqual\" field\n         * in the ProofSpec is valuable to prevent this mutability. And why all trees should\n         * length-prefix the data before hashing it.\n         * @implements IExistenceProof\n         * @constructor\n         * @param {ics23.IExistenceProof=} [properties] Properties to set\n         */\n        function ExistenceProof(properties) {\n            this.path = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * ExistenceProof value.\n         * @member {Uint8Array} value\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.value = $util.newBuffer([]);\n\n        /**\n         * ExistenceProof leaf.\n         * @member {ics23.ILeafOp|null|undefined} leaf\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.leaf = null;\n\n        /**\n         * ExistenceProof path.\n         * @member {Array.<ics23.IInnerOp>} path\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.path = $util.emptyArray;\n\n        /**\n         * Creates a new ExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof=} [properties] Properties to set\n         * @returns {ics23.ExistenceProof} ExistenceProof instance\n         */\n        ExistenceProof.create = function create(properties) {\n            return new ExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified ExistenceProof message. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                $root.ics23.LeafOp.encode(message.leaf, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.path != null && message.path.length)\n                for (var i = 0; i < message.path.length; ++i)\n                    $root.ics23.InnerOp.encode(message.path[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ExistenceProof message, length delimited. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an ExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.ExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                case 3:\n                    message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.path && message.path.length))\n                        message.path = [];\n                    message.path.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an ExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an ExistenceProof message.\n         * @function verify\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n                    return \"value: buffer expected\";\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n                var error = $root.ics23.LeafOp.verify(message.leaf);\n                if (error)\n                    return \"leaf.\" + error;\n            }\n            if (message.path != null && message.hasOwnProperty(\"path\")) {\n                if (!Array.isArray(message.path))\n                    return \"path: array expected\";\n                for (var i = 0; i < message.path.length; ++i) {\n                    var error = $root.ics23.InnerOp.verify(message.path[i]);\n                    if (error)\n                        return \"path.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates an ExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         */\n        ExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.ExistenceProof)\n                return object;\n            var message = new $root.ics23.ExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.value != null)\n                if (typeof object.value === \"string\")\n                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n                else if (object.value.length)\n                    message.value = object.value;\n            if (object.leaf != null) {\n                if (typeof object.leaf !== \"object\")\n                    throw TypeError(\".ics23.ExistenceProof.leaf: object expected\");\n                message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n            }\n            if (object.path) {\n                if (!Array.isArray(object.path))\n                    throw TypeError(\".ics23.ExistenceProof.path: array expected\");\n                message.path = [];\n                for (var i = 0; i < object.path.length; ++i) {\n                    if (typeof object.path[i] !== \"object\")\n                        throw TypeError(\".ics23.ExistenceProof.path: object expected\");\n                    message.path[i] = $root.ics23.InnerOp.fromObject(object.path[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an ExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.ExistenceProof} message ExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.path = [];\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                if (options.bytes === String)\n                    object.value = \"\";\n                else {\n                    object.value = [];\n                    if (options.bytes !== Array)\n                        object.value = $util.newBuffer(object.value);\n                }\n                object.leaf = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n            if (message.path && message.path.length) {\n                object.path = [];\n                for (var j = 0; j < message.path.length; ++j)\n                    object.path[j] = $root.ics23.InnerOp.toObject(message.path[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this ExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.ExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ExistenceProof;\n    })();\n\n    ics23.NonExistenceProof = (function() {\n\n        /**\n         * Properties of a NonExistenceProof.\n         * @memberof ics23\n         * @interface INonExistenceProof\n         * @property {Uint8Array|null} [key] NonExistenceProof key\n         * @property {ics23.IExistenceProof|null} [left] NonExistenceProof left\n         * @property {ics23.IExistenceProof|null} [right] NonExistenceProof right\n         */\n\n        /**\n         * Constructs a new NonExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a NonExistenceProof.\n         * @implements INonExistenceProof\n         * @constructor\n         * @param {ics23.INonExistenceProof=} [properties] Properties to set\n         */\n        function NonExistenceProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * NonExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * NonExistenceProof left.\n         * @member {ics23.IExistenceProof|null|undefined} left\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.left = null;\n\n        /**\n         * NonExistenceProof right.\n         * @member {ics23.IExistenceProof|null|undefined} right\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.right = null;\n\n        /**\n         * Creates a new NonExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof=} [properties] Properties to set\n         * @returns {ics23.NonExistenceProof} NonExistenceProof instance\n         */\n        NonExistenceProof.create = function create(properties) {\n            return new NonExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified NonExistenceProof message. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NonExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                $root.ics23.ExistenceProof.encode(message.left, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                $root.ics23.ExistenceProof.encode(message.right, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified NonExistenceProof message, length delimited. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a NonExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NonExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.NonExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.left = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.right = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a NonExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a NonExistenceProof message.\n         * @function verify\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        NonExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.left != null && message.hasOwnProperty(\"left\")) {\n                var error = $root.ics23.ExistenceProof.verify(message.left);\n                if (error)\n                    return \"left.\" + error;\n            }\n            if (message.right != null && message.hasOwnProperty(\"right\")) {\n                var error = $root.ics23.ExistenceProof.verify(message.right);\n                if (error)\n                    return \"right.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a NonExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         */\n        NonExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.NonExistenceProof)\n                return object;\n            var message = new $root.ics23.NonExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.left != null) {\n                if (typeof object.left !== \"object\")\n                    throw TypeError(\".ics23.NonExistenceProof.left: object expected\");\n                message.left = $root.ics23.ExistenceProof.fromObject(object.left);\n            }\n            if (object.right != null) {\n                if (typeof object.right !== \"object\")\n                    throw TypeError(\".ics23.NonExistenceProof.right: object expected\");\n                message.right = $root.ics23.ExistenceProof.fromObject(object.right);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a NonExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.NonExistenceProof} message NonExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        NonExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                object.left = null;\n                object.right = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                object.left = $root.ics23.ExistenceProof.toObject(message.left, options);\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                object.right = $root.ics23.ExistenceProof.toObject(message.right, options);\n            return object;\n        };\n\n        /**\n         * Converts this NonExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        NonExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return NonExistenceProof;\n    })();\n\n    ics23.CommitmentProof = (function() {\n\n        /**\n         * Properties of a CommitmentProof.\n         * @memberof ics23\n         * @interface ICommitmentProof\n         * @property {ics23.IExistenceProof|null} [exist] CommitmentProof exist\n         * @property {ics23.INonExistenceProof|null} [nonexist] CommitmentProof nonexist\n         * @property {ics23.IBatchProof|null} [batch] CommitmentProof batch\n         * @property {ics23.ICompressedBatchProof|null} [compressed] CommitmentProof compressed\n         */\n\n        /**\n         * Constructs a new CommitmentProof.\n         * @memberof ics23\n         * @classdesc Represents a CommitmentProof.\n         * @implements ICommitmentProof\n         * @constructor\n         * @param {ics23.ICommitmentProof=} [properties] Properties to set\n         */\n        function CommitmentProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CommitmentProof exist.\n         * @member {ics23.IExistenceProof|null|undefined} exist\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.exist = null;\n\n        /**\n         * CommitmentProof nonexist.\n         * @member {ics23.INonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.nonexist = null;\n\n        /**\n         * CommitmentProof batch.\n         * @member {ics23.IBatchProof|null|undefined} batch\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.batch = null;\n\n        /**\n         * CommitmentProof compressed.\n         * @member {ics23.ICompressedBatchProof|null|undefined} compressed\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.compressed = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * CommitmentProof proof.\n         * @member {\"exist\"|\"nonexist\"|\"batch\"|\"compressed\"|undefined} proof\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        Object.defineProperty(CommitmentProof.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\", \"batch\", \"compressed\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new CommitmentProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof=} [properties] Properties to set\n         * @returns {ics23.CommitmentProof} CommitmentProof instance\n         */\n        CommitmentProof.create = function create(properties) {\n            return new CommitmentProof(properties);\n        };\n\n        /**\n         * Encodes the specified CommitmentProof message. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CommitmentProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.batch != null && message.hasOwnProperty(\"batch\"))\n                $root.ics23.BatchProof.encode(message.batch, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\"))\n                $root.ics23.CompressedBatchProof.encode(message.compressed, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CommitmentProof message, length delimited. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CommitmentProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CommitmentProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CommitmentProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CommitmentProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.batch = $root.ics23.BatchProof.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.compressed = $root.ics23.CompressedBatchProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CommitmentProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CommitmentProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CommitmentProof message.\n         * @function verify\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CommitmentProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.ExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.BatchProof.verify(message.batch);\n                    if (error)\n                        return \"batch.\" + error;\n                }\n            }\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedBatchProof.verify(message.compressed);\n                    if (error)\n                        return \"compressed.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CommitmentProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         */\n        CommitmentProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CommitmentProof)\n                return object;\n            var message = new $root.ics23.CommitmentProof();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.exist: object expected\");\n                message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.nonexist: object expected\");\n                message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n            }\n            if (object.batch != null) {\n                if (typeof object.batch !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.batch: object expected\");\n                message.batch = $root.ics23.BatchProof.fromObject(object.batch);\n            }\n            if (object.compressed != null) {\n                if (typeof object.compressed !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.compressed: object expected\");\n                message.compressed = $root.ics23.CompressedBatchProof.fromObject(object.compressed);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CommitmentProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.CommitmentProof} message CommitmentProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CommitmentProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n                object.batch = $root.ics23.BatchProof.toObject(message.batch, options);\n                if (options.oneofs)\n                    object.proof = \"batch\";\n            }\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n                object.compressed = $root.ics23.CompressedBatchProof.toObject(message.compressed, options);\n                if (options.oneofs)\n                    object.proof = \"compressed\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CommitmentProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CommitmentProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CommitmentProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CommitmentProof;\n    })();\n\n    ics23.LeafOp = (function() {\n\n        /**\n         * Properties of a LeafOp.\n         * @memberof ics23\n         * @interface ILeafOp\n         * @property {ics23.HashOp|null} [hash] LeafOp hash\n         * @property {ics23.HashOp|null} [prehashKey] LeafOp prehashKey\n         * @property {ics23.HashOp|null} [prehashValue] LeafOp prehashValue\n         * @property {ics23.LengthOp|null} [length] LeafOp length\n         * @property {Uint8Array|null} [prefix] LeafOp prefix\n         */\n\n        /**\n         * Constructs a new LeafOp.\n         * @memberof ics23\n         * @classdesc LeafOp represents the raw key-value data we wish to prove, and\n         * must be flexible to represent the internal transformation from\n         * the original key-value pairs into the basis hash, for many existing\n         * merkle trees.\n         * \n         * key and value are passed in. So that the signature of this operation is:\n         * leafOp(key, value) -> output\n         * \n         * To process this, first prehash the keys and values if needed (ANY means no hash in this case):\n         * hkey = prehashKey(key)\n         * hvalue = prehashValue(value)\n         * \n         * Then combine the bytes, and hash it\n         * output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)\n         * @implements ILeafOp\n         * @constructor\n         * @param {ics23.ILeafOp=} [properties] Properties to set\n         */\n        function LeafOp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * LeafOp hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.hash = 0;\n\n        /**\n         * LeafOp prehashKey.\n         * @member {ics23.HashOp} prehashKey\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prehashKey = 0;\n\n        /**\n         * LeafOp prehashValue.\n         * @member {ics23.HashOp} prehashValue\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prehashValue = 0;\n\n        /**\n         * LeafOp length.\n         * @member {ics23.LengthOp} length\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.length = 0;\n\n        /**\n         * LeafOp prefix.\n         * @member {Uint8Array} prefix\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prefix = $util.newBuffer([]);\n\n        /**\n         * Creates a new LeafOp instance using the specified properties.\n         * @function create\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp=} [properties] Properties to set\n         * @returns {ics23.LeafOp} LeafOp instance\n         */\n        LeafOp.create = function create(properties) {\n            return new LeafOp(properties);\n        };\n\n        /**\n         * Encodes the specified LeafOp message. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LeafOp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hash);\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.prehashKey);\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.prehashValue);\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.length);\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.prefix);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified LeafOp message, length delimited. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LeafOp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a LeafOp message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.LeafOp} LeafOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LeafOp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.LeafOp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.int32();\n                    break;\n                case 2:\n                    message.prehashKey = reader.int32();\n                    break;\n                case 3:\n                    message.prehashValue = reader.int32();\n                    break;\n                case 4:\n                    message.length = reader.int32();\n                    break;\n                case 5:\n                    message.prefix = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a LeafOp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.LeafOp} LeafOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LeafOp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a LeafOp message.\n         * @function verify\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        LeafOp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                switch (message.prehashKey) {\n                default:\n                    return \"prehashKey: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                switch (message.prehashValue) {\n                default:\n                    return \"prehashValue: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                switch (message.length) {\n                default:\n                    return \"length: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                case 8:\n                    break;\n                }\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix)))\n                    return \"prefix: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a LeafOp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.LeafOp} LeafOp\n         */\n        LeafOp.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.LeafOp)\n                return object;\n            var message = new $root.ics23.LeafOp();\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            switch (object.prehashKey) {\n            case \"NO_HASH\":\n            case 0:\n                message.prehashKey = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.prehashKey = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.prehashKey = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.prehashKey = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.prehashKey = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.prehashKey = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.prehashKey = 6;\n                break;\n            }\n            switch (object.prehashValue) {\n            case \"NO_HASH\":\n            case 0:\n                message.prehashValue = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.prehashValue = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.prehashValue = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.prehashValue = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.prehashValue = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.prehashValue = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.prehashValue = 6;\n                break;\n            }\n            switch (object.length) {\n            case \"NO_PREFIX\":\n            case 0:\n                message.length = 0;\n                break;\n            case \"VAR_PROTO\":\n            case 1:\n                message.length = 1;\n                break;\n            case \"VAR_RLP\":\n            case 2:\n                message.length = 2;\n                break;\n            case \"FIXED32_BIG\":\n            case 3:\n                message.length = 3;\n                break;\n            case \"FIXED32_LITTLE\":\n            case 4:\n                message.length = 4;\n                break;\n            case \"FIXED64_BIG\":\n            case 5:\n                message.length = 5;\n                break;\n            case \"FIXED64_LITTLE\":\n            case 6:\n                message.length = 6;\n                break;\n            case \"REQUIRE_32_BYTES\":\n            case 7:\n                message.length = 7;\n                break;\n            case \"REQUIRE_64_BYTES\":\n            case 8:\n                message.length = 8;\n                break;\n            }\n            if (object.prefix != null)\n                if (typeof object.prefix === \"string\")\n                    $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);\n                else if (object.prefix.length)\n                    message.prefix = object.prefix;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a LeafOp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.LeafOp} message LeafOp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        LeafOp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n                object.prehashKey = options.enums === String ? \"NO_HASH\" : 0;\n                object.prehashValue = options.enums === String ? \"NO_HASH\" : 0;\n                object.length = options.enums === String ? \"NO_PREFIX\" : 0;\n                if (options.bytes === String)\n                    object.prefix = \"\";\n                else {\n                    object.prefix = [];\n                    if (options.bytes !== Array)\n                        object.prefix = $util.newBuffer(object.prefix);\n                }\n            }\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                object.prehashKey = options.enums === String ? $root.ics23.HashOp[message.prehashKey] : message.prehashKey;\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                object.prehashValue = options.enums === String ? $root.ics23.HashOp[message.prehashValue] : message.prehashValue;\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                object.length = options.enums === String ? $root.ics23.LengthOp[message.length] : message.length;\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n            return object;\n        };\n\n        /**\n         * Converts this LeafOp to JSON.\n         * @function toJSON\n         * @memberof ics23.LeafOp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        LeafOp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return LeafOp;\n    })();\n\n    ics23.InnerOp = (function() {\n\n        /**\n         * Properties of an InnerOp.\n         * @memberof ics23\n         * @interface IInnerOp\n         * @property {ics23.HashOp|null} [hash] InnerOp hash\n         * @property {Uint8Array|null} [prefix] InnerOp prefix\n         * @property {Uint8Array|null} [suffix] InnerOp suffix\n         */\n\n        /**\n         * Constructs a new InnerOp.\n         * @memberof ics23\n         * @classdesc InnerOp represents a merkle-proof step that is not a leaf.\n         * It represents concatenating two children and hashing them to provide the next result.\n         * \n         * The result of the previous step is passed in, so the signature of this op is:\n         * innerOp(child) -> output\n         * \n         * The result of applying InnerOp should be:\n         * output = op.hash(op.prefix || child || op.suffix)\n         * \n         * where the || operator is concatenation of binary data,\n         * and child is the result of hashing all the tree below this step.\n         * \n         * Any special data, like prepending child with the length, or prepending the entire operation with\n         * some value to differentiate from leaf nodes, should be included in prefix and suffix.\n         * If either of prefix or suffix is empty, we just treat it as an empty string\n         * @implements IInnerOp\n         * @constructor\n         * @param {ics23.IInnerOp=} [properties] Properties to set\n         */\n        function InnerOp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * InnerOp hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.hash = 0;\n\n        /**\n         * InnerOp prefix.\n         * @member {Uint8Array} prefix\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.prefix = $util.newBuffer([]);\n\n        /**\n         * InnerOp suffix.\n         * @member {Uint8Array} suffix\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.suffix = $util.newBuffer([]);\n\n        /**\n         * Creates a new InnerOp instance using the specified properties.\n         * @function create\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp=} [properties] Properties to set\n         * @returns {ics23.InnerOp} InnerOp instance\n         */\n        InnerOp.create = function create(properties) {\n            return new InnerOp(properties);\n        };\n\n        /**\n         * Encodes the specified InnerOp message. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerOp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hash);\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.prefix);\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.suffix);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified InnerOp message, length delimited. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerOp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an InnerOp message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.InnerOp} InnerOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerOp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.InnerOp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.int32();\n                    break;\n                case 2:\n                    message.prefix = reader.bytes();\n                    break;\n                case 3:\n                    message.suffix = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an InnerOp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.InnerOp} InnerOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerOp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an InnerOp message.\n         * @function verify\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        InnerOp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix)))\n                    return \"prefix: buffer expected\";\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                if (!(message.suffix && typeof message.suffix.length === \"number\" || $util.isString(message.suffix)))\n                    return \"suffix: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates an InnerOp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.InnerOp} InnerOp\n         */\n        InnerOp.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.InnerOp)\n                return object;\n            var message = new $root.ics23.InnerOp();\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            if (object.prefix != null)\n                if (typeof object.prefix === \"string\")\n                    $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);\n                else if (object.prefix.length)\n                    message.prefix = object.prefix;\n            if (object.suffix != null)\n                if (typeof object.suffix === \"string\")\n                    $util.base64.decode(object.suffix, message.suffix = $util.newBuffer($util.base64.length(object.suffix)), 0);\n                else if (object.suffix.length)\n                    message.suffix = object.suffix;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an InnerOp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.InnerOp} message InnerOp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        InnerOp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n                if (options.bytes === String)\n                    object.prefix = \"\";\n                else {\n                    object.prefix = [];\n                    if (options.bytes !== Array)\n                        object.prefix = $util.newBuffer(object.prefix);\n                }\n                if (options.bytes === String)\n                    object.suffix = \"\";\n                else {\n                    object.suffix = [];\n                    if (options.bytes !== Array)\n                        object.suffix = $util.newBuffer(object.suffix);\n                }\n            }\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                object.suffix = options.bytes === String ? $util.base64.encode(message.suffix, 0, message.suffix.length) : options.bytes === Array ? Array.prototype.slice.call(message.suffix) : message.suffix;\n            return object;\n        };\n\n        /**\n         * Converts this InnerOp to JSON.\n         * @function toJSON\n         * @memberof ics23.InnerOp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        InnerOp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return InnerOp;\n    })();\n\n    ics23.ProofSpec = (function() {\n\n        /**\n         * Properties of a ProofSpec.\n         * @memberof ics23\n         * @interface IProofSpec\n         * @property {ics23.ILeafOp|null} [leafSpec] ProofSpec leafSpec\n         * @property {ics23.IInnerSpec|null} [innerSpec] ProofSpec innerSpec\n         * @property {number|null} [maxDepth] ProofSpec maxDepth\n         * @property {number|null} [minDepth] ProofSpec minDepth\n         */\n\n        /**\n         * Constructs a new ProofSpec.\n         * @memberof ics23\n         * @classdesc ProofSpec defines what the expected parameters are for a given proof type.\n         * This can be stored in the client and used to validate any incoming proofs.\n         * \n         * verify(ProofSpec, Proof) -> Proof | Error\n         * \n         * As demonstrated in tests, if we don't fix the algorithm used to calculate the\n         * LeafHash for a given tree, there are many possible key-value pairs that can\n         * generate a given hash (by interpretting the preimage differently).\n         * We need this for proper security, requires client knows a priori what\n         * tree format server uses. But not in code, rather a configuration object.\n         * @implements IProofSpec\n         * @constructor\n         * @param {ics23.IProofSpec=} [properties] Properties to set\n         */\n        function ProofSpec(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ProofSpec leafSpec.\n         * @member {ics23.ILeafOp|null|undefined} leafSpec\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.leafSpec = null;\n\n        /**\n         * ProofSpec innerSpec.\n         * @member {ics23.IInnerSpec|null|undefined} innerSpec\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.innerSpec = null;\n\n        /**\n         * ProofSpec maxDepth.\n         * @member {number} maxDepth\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.maxDepth = 0;\n\n        /**\n         * ProofSpec minDepth.\n         * @member {number} minDepth\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.minDepth = 0;\n\n        /**\n         * Creates a new ProofSpec instance using the specified properties.\n         * @function create\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec=} [properties] Properties to set\n         * @returns {ics23.ProofSpec} ProofSpec instance\n         */\n        ProofSpec.create = function create(properties) {\n            return new ProofSpec(properties);\n        };\n\n        /**\n         * Encodes the specified ProofSpec message. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ProofSpec.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\"))\n                $root.ics23.LeafOp.encode(message.leafSpec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\"))\n                $root.ics23.InnerSpec.encode(message.innerSpec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.maxDepth);\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minDepth);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ProofSpec message, length delimited. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ProofSpec.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a ProofSpec message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.ProofSpec} ProofSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ProofSpec.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.ProofSpec();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.leafSpec = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.innerSpec = $root.ics23.InnerSpec.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.maxDepth = reader.int32();\n                    break;\n                case 4:\n                    message.minDepth = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a ProofSpec message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.ProofSpec} ProofSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ProofSpec.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a ProofSpec message.\n         * @function verify\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ProofSpec.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\")) {\n                var error = $root.ics23.LeafOp.verify(message.leafSpec);\n                if (error)\n                    return \"leafSpec.\" + error;\n            }\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\")) {\n                var error = $root.ics23.InnerSpec.verify(message.innerSpec);\n                if (error)\n                    return \"innerSpec.\" + error;\n            }\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                if (!$util.isInteger(message.maxDepth))\n                    return \"maxDepth: integer expected\";\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                if (!$util.isInteger(message.minDepth))\n                    return \"minDepth: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a ProofSpec message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.ProofSpec} ProofSpec\n         */\n        ProofSpec.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.ProofSpec)\n                return object;\n            var message = new $root.ics23.ProofSpec();\n            if (object.leafSpec != null) {\n                if (typeof object.leafSpec !== \"object\")\n                    throw TypeError(\".ics23.ProofSpec.leafSpec: object expected\");\n                message.leafSpec = $root.ics23.LeafOp.fromObject(object.leafSpec);\n            }\n            if (object.innerSpec != null) {\n                if (typeof object.innerSpec !== \"object\")\n                    throw TypeError(\".ics23.ProofSpec.innerSpec: object expected\");\n                message.innerSpec = $root.ics23.InnerSpec.fromObject(object.innerSpec);\n            }\n            if (object.maxDepth != null)\n                message.maxDepth = object.maxDepth | 0;\n            if (object.minDepth != null)\n                message.minDepth = object.minDepth | 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a ProofSpec message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.ProofSpec} message ProofSpec\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ProofSpec.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.leafSpec = null;\n                object.innerSpec = null;\n                object.maxDepth = 0;\n                object.minDepth = 0;\n            }\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\"))\n                object.leafSpec = $root.ics23.LeafOp.toObject(message.leafSpec, options);\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\"))\n                object.innerSpec = $root.ics23.InnerSpec.toObject(message.innerSpec, options);\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                object.maxDepth = message.maxDepth;\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                object.minDepth = message.minDepth;\n            return object;\n        };\n\n        /**\n         * Converts this ProofSpec to JSON.\n         * @function toJSON\n         * @memberof ics23.ProofSpec\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ProofSpec.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ProofSpec;\n    })();\n\n    ics23.InnerSpec = (function() {\n\n        /**\n         * Properties of an InnerSpec.\n         * @memberof ics23\n         * @interface IInnerSpec\n         * @property {Array.<number>|null} [childOrder] InnerSpec childOrder\n         * @property {number|null} [childSize] InnerSpec childSize\n         * @property {number|null} [minPrefixLength] InnerSpec minPrefixLength\n         * @property {number|null} [maxPrefixLength] InnerSpec maxPrefixLength\n         * @property {Uint8Array|null} [emptyChild] InnerSpec emptyChild\n         * @property {ics23.HashOp|null} [hash] InnerSpec hash\n         */\n\n        /**\n         * Constructs a new InnerSpec.\n         * @memberof ics23\n         * @classdesc Represents an InnerSpec.\n         * @implements IInnerSpec\n         * @constructor\n         * @param {ics23.IInnerSpec=} [properties] Properties to set\n         */\n        function InnerSpec(properties) {\n            this.childOrder = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * InnerSpec childOrder.\n         * @member {Array.<number>} childOrder\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.childOrder = $util.emptyArray;\n\n        /**\n         * InnerSpec childSize.\n         * @member {number} childSize\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.childSize = 0;\n\n        /**\n         * InnerSpec minPrefixLength.\n         * @member {number} minPrefixLength\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.minPrefixLength = 0;\n\n        /**\n         * InnerSpec maxPrefixLength.\n         * @member {number} maxPrefixLength\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.maxPrefixLength = 0;\n\n        /**\n         * InnerSpec emptyChild.\n         * @member {Uint8Array} emptyChild\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.emptyChild = $util.newBuffer([]);\n\n        /**\n         * InnerSpec hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.hash = 0;\n\n        /**\n         * Creates a new InnerSpec instance using the specified properties.\n         * @function create\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec=} [properties] Properties to set\n         * @returns {ics23.InnerSpec} InnerSpec instance\n         */\n        InnerSpec.create = function create(properties) {\n            return new InnerSpec(properties);\n        };\n\n        /**\n         * Encodes the specified InnerSpec message. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerSpec.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.childOrder != null && message.childOrder.length) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                for (var i = 0; i < message.childOrder.length; ++i)\n                    writer.int32(message.childOrder[i]);\n                writer.ldelim();\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.childSize);\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.minPrefixLength);\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.maxPrefixLength);\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.emptyChild);\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.hash);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified InnerSpec message, length delimited. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerSpec.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an InnerSpec message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.InnerSpec} InnerSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerSpec.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.InnerSpec();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.childOrder && message.childOrder.length))\n                        message.childOrder = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.childOrder.push(reader.int32());\n                    } else\n                        message.childOrder.push(reader.int32());\n                    break;\n                case 2:\n                    message.childSize = reader.int32();\n                    break;\n                case 3:\n                    message.minPrefixLength = reader.int32();\n                    break;\n                case 4:\n                    message.maxPrefixLength = reader.int32();\n                    break;\n                case 5:\n                    message.emptyChild = reader.bytes();\n                    break;\n                case 6:\n                    message.hash = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an InnerSpec message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.InnerSpec} InnerSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerSpec.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an InnerSpec message.\n         * @function verify\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        InnerSpec.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.childOrder != null && message.hasOwnProperty(\"childOrder\")) {\n                if (!Array.isArray(message.childOrder))\n                    return \"childOrder: array expected\";\n                for (var i = 0; i < message.childOrder.length; ++i)\n                    if (!$util.isInteger(message.childOrder[i]))\n                        return \"childOrder: integer[] expected\";\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                if (!$util.isInteger(message.childSize))\n                    return \"childSize: integer expected\";\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                if (!$util.isInteger(message.minPrefixLength))\n                    return \"minPrefixLength: integer expected\";\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                if (!$util.isInteger(message.maxPrefixLength))\n                    return \"maxPrefixLength: integer expected\";\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                if (!(message.emptyChild && typeof message.emptyChild.length === \"number\" || $util.isString(message.emptyChild)))\n                    return \"emptyChild: buffer expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            return null;\n        };\n\n        /**\n         * Creates an InnerSpec message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.InnerSpec} InnerSpec\n         */\n        InnerSpec.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.InnerSpec)\n                return object;\n            var message = new $root.ics23.InnerSpec();\n            if (object.childOrder) {\n                if (!Array.isArray(object.childOrder))\n                    throw TypeError(\".ics23.InnerSpec.childOrder: array expected\");\n                message.childOrder = [];\n                for (var i = 0; i < object.childOrder.length; ++i)\n                    message.childOrder[i] = object.childOrder[i] | 0;\n            }\n            if (object.childSize != null)\n                message.childSize = object.childSize | 0;\n            if (object.minPrefixLength != null)\n                message.minPrefixLength = object.minPrefixLength | 0;\n            if (object.maxPrefixLength != null)\n                message.maxPrefixLength = object.maxPrefixLength | 0;\n            if (object.emptyChild != null)\n                if (typeof object.emptyChild === \"string\")\n                    $util.base64.decode(object.emptyChild, message.emptyChild = $util.newBuffer($util.base64.length(object.emptyChild)), 0);\n                else if (object.emptyChild.length)\n                    message.emptyChild = object.emptyChild;\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an InnerSpec message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.InnerSpec} message InnerSpec\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        InnerSpec.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.childOrder = [];\n            if (options.defaults) {\n                object.childSize = 0;\n                object.minPrefixLength = 0;\n                object.maxPrefixLength = 0;\n                if (options.bytes === String)\n                    object.emptyChild = \"\";\n                else {\n                    object.emptyChild = [];\n                    if (options.bytes !== Array)\n                        object.emptyChild = $util.newBuffer(object.emptyChild);\n                }\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n            }\n            if (message.childOrder && message.childOrder.length) {\n                object.childOrder = [];\n                for (var j = 0; j < message.childOrder.length; ++j)\n                    object.childOrder[j] = message.childOrder[j];\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                object.childSize = message.childSize;\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                object.minPrefixLength = message.minPrefixLength;\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                object.maxPrefixLength = message.maxPrefixLength;\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                object.emptyChild = options.bytes === String ? $util.base64.encode(message.emptyChild, 0, message.emptyChild.length) : options.bytes === Array ? Array.prototype.slice.call(message.emptyChild) : message.emptyChild;\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            return object;\n        };\n\n        /**\n         * Converts this InnerSpec to JSON.\n         * @function toJSON\n         * @memberof ics23.InnerSpec\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        InnerSpec.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return InnerSpec;\n    })();\n\n    ics23.BatchProof = (function() {\n\n        /**\n         * Properties of a BatchProof.\n         * @memberof ics23\n         * @interface IBatchProof\n         * @property {Array.<ics23.IBatchEntry>|null} [entries] BatchProof entries\n         */\n\n        /**\n         * Constructs a new BatchProof.\n         * @memberof ics23\n         * @classdesc Represents a BatchProof.\n         * @implements IBatchProof\n         * @constructor\n         * @param {ics23.IBatchProof=} [properties] Properties to set\n         */\n        function BatchProof(properties) {\n            this.entries = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BatchProof entries.\n         * @member {Array.<ics23.IBatchEntry>} entries\n         * @memberof ics23.BatchProof\n         * @instance\n         */\n        BatchProof.prototype.entries = $util.emptyArray;\n\n        /**\n         * Creates a new BatchProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof=} [properties] Properties to set\n         * @returns {ics23.BatchProof} BatchProof instance\n         */\n        BatchProof.create = function create(properties) {\n            return new BatchProof(properties);\n        };\n\n        /**\n         * Encodes the specified BatchProof message. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.entries != null && message.entries.length)\n                for (var i = 0; i < message.entries.length; ++i)\n                    $root.ics23.BatchEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BatchProof message, length delimited. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BatchProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.BatchProof} BatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.BatchProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.entries && message.entries.length))\n                        message.entries = [];\n                    message.entries.push($root.ics23.BatchEntry.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BatchProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.BatchProof} BatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BatchProof message.\n         * @function verify\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BatchProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n                if (!Array.isArray(message.entries))\n                    return \"entries: array expected\";\n                for (var i = 0; i < message.entries.length; ++i) {\n                    var error = $root.ics23.BatchEntry.verify(message.entries[i]);\n                    if (error)\n                        return \"entries.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BatchProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.BatchProof} BatchProof\n         */\n        BatchProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.BatchProof)\n                return object;\n            var message = new $root.ics23.BatchProof();\n            if (object.entries) {\n                if (!Array.isArray(object.entries))\n                    throw TypeError(\".ics23.BatchProof.entries: array expected\");\n                message.entries = [];\n                for (var i = 0; i < object.entries.length; ++i) {\n                    if (typeof object.entries[i] !== \"object\")\n                        throw TypeError(\".ics23.BatchProof.entries: object expected\");\n                    message.entries[i] = $root.ics23.BatchEntry.fromObject(object.entries[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BatchProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.BatchProof} message BatchProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BatchProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.entries = [];\n            if (message.entries && message.entries.length) {\n                object.entries = [];\n                for (var j = 0; j < message.entries.length; ++j)\n                    object.entries[j] = $root.ics23.BatchEntry.toObject(message.entries[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this BatchProof to JSON.\n         * @function toJSON\n         * @memberof ics23.BatchProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BatchProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BatchProof;\n    })();\n\n    ics23.BatchEntry = (function() {\n\n        /**\n         * Properties of a BatchEntry.\n         * @memberof ics23\n         * @interface IBatchEntry\n         * @property {ics23.IExistenceProof|null} [exist] BatchEntry exist\n         * @property {ics23.INonExistenceProof|null} [nonexist] BatchEntry nonexist\n         */\n\n        /**\n         * Constructs a new BatchEntry.\n         * @memberof ics23\n         * @classdesc Represents a BatchEntry.\n         * @implements IBatchEntry\n         * @constructor\n         * @param {ics23.IBatchEntry=} [properties] Properties to set\n         */\n        function BatchEntry(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BatchEntry exist.\n         * @member {ics23.IExistenceProof|null|undefined} exist\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        BatchEntry.prototype.exist = null;\n\n        /**\n         * BatchEntry nonexist.\n         * @member {ics23.INonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        BatchEntry.prototype.nonexist = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * BatchEntry proof.\n         * @member {\"exist\"|\"nonexist\"|undefined} proof\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        Object.defineProperty(BatchEntry.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new BatchEntry instance using the specified properties.\n         * @function create\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry=} [properties] Properties to set\n         * @returns {ics23.BatchEntry} BatchEntry instance\n         */\n        BatchEntry.create = function create(properties) {\n            return new BatchEntry(properties);\n        };\n\n        /**\n         * Encodes the specified BatchEntry message. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchEntry.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BatchEntry message, length delimited. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BatchEntry message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.BatchEntry} BatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchEntry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.BatchEntry();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BatchEntry message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.BatchEntry} BatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchEntry.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BatchEntry message.\n         * @function verify\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BatchEntry.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.ExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BatchEntry message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.BatchEntry} BatchEntry\n         */\n        BatchEntry.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.BatchEntry)\n                return object;\n            var message = new $root.ics23.BatchEntry();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.BatchEntry.exist: object expected\");\n                message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.BatchEntry.nonexist: object expected\");\n                message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BatchEntry message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.BatchEntry} message BatchEntry\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BatchEntry.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this BatchEntry to JSON.\n         * @function toJSON\n         * @memberof ics23.BatchEntry\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BatchEntry.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BatchEntry;\n    })();\n\n    ics23.CompressedBatchProof = (function() {\n\n        /**\n         * Properties of a CompressedBatchProof.\n         * @memberof ics23\n         * @interface ICompressedBatchProof\n         * @property {Array.<ics23.ICompressedBatchEntry>|null} [entries] CompressedBatchProof entries\n         * @property {Array.<ics23.IInnerOp>|null} [lookupInners] CompressedBatchProof lookupInners\n         */\n\n        /**\n         * Constructs a new CompressedBatchProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedBatchProof.\n         * @implements ICompressedBatchProof\n         * @constructor\n         * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n         */\n        function CompressedBatchProof(properties) {\n            this.entries = [];\n            this.lookupInners = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedBatchProof entries.\n         * @member {Array.<ics23.ICompressedBatchEntry>} entries\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         */\n        CompressedBatchProof.prototype.entries = $util.emptyArray;\n\n        /**\n         * CompressedBatchProof lookupInners.\n         * @member {Array.<ics23.IInnerOp>} lookupInners\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         */\n        CompressedBatchProof.prototype.lookupInners = $util.emptyArray;\n\n        /**\n         * Creates a new CompressedBatchProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof instance\n         */\n        CompressedBatchProof.create = function create(properties) {\n            return new CompressedBatchProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedBatchProof message. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.entries != null && message.entries.length)\n                for (var i = 0; i < message.entries.length; ++i)\n                    $root.ics23.CompressedBatchEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.lookupInners != null && message.lookupInners.length)\n                for (var i = 0; i < message.lookupInners.length; ++i)\n                    $root.ics23.InnerOp.encode(message.lookupInners[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedBatchProof message, length delimited. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedBatchProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.entries && message.entries.length))\n                        message.entries = [];\n                    message.entries.push($root.ics23.CompressedBatchEntry.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    if (!(message.lookupInners && message.lookupInners.length))\n                        message.lookupInners = [];\n                    message.lookupInners.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedBatchProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedBatchProof message.\n         * @function verify\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedBatchProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n                if (!Array.isArray(message.entries))\n                    return \"entries: array expected\";\n                for (var i = 0; i < message.entries.length; ++i) {\n                    var error = $root.ics23.CompressedBatchEntry.verify(message.entries[i]);\n                    if (error)\n                        return \"entries.\" + error;\n                }\n            }\n            if (message.lookupInners != null && message.hasOwnProperty(\"lookupInners\")) {\n                if (!Array.isArray(message.lookupInners))\n                    return \"lookupInners: array expected\";\n                for (var i = 0; i < message.lookupInners.length; ++i) {\n                    var error = $root.ics23.InnerOp.verify(message.lookupInners[i]);\n                    if (error)\n                        return \"lookupInners.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedBatchProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         */\n        CompressedBatchProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedBatchProof)\n                return object;\n            var message = new $root.ics23.CompressedBatchProof();\n            if (object.entries) {\n                if (!Array.isArray(object.entries))\n                    throw TypeError(\".ics23.CompressedBatchProof.entries: array expected\");\n                message.entries = [];\n                for (var i = 0; i < object.entries.length; ++i) {\n                    if (typeof object.entries[i] !== \"object\")\n                        throw TypeError(\".ics23.CompressedBatchProof.entries: object expected\");\n                    message.entries[i] = $root.ics23.CompressedBatchEntry.fromObject(object.entries[i]);\n                }\n            }\n            if (object.lookupInners) {\n                if (!Array.isArray(object.lookupInners))\n                    throw TypeError(\".ics23.CompressedBatchProof.lookupInners: array expected\");\n                message.lookupInners = [];\n                for (var i = 0; i < object.lookupInners.length; ++i) {\n                    if (typeof object.lookupInners[i] !== \"object\")\n                        throw TypeError(\".ics23.CompressedBatchProof.lookupInners: object expected\");\n                    message.lookupInners[i] = $root.ics23.InnerOp.fromObject(object.lookupInners[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedBatchProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.CompressedBatchProof} message CompressedBatchProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedBatchProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.entries = [];\n                object.lookupInners = [];\n            }\n            if (message.entries && message.entries.length) {\n                object.entries = [];\n                for (var j = 0; j < message.entries.length; ++j)\n                    object.entries[j] = $root.ics23.CompressedBatchEntry.toObject(message.entries[j], options);\n            }\n            if (message.lookupInners && message.lookupInners.length) {\n                object.lookupInners = [];\n                for (var j = 0; j < message.lookupInners.length; ++j)\n                    object.lookupInners[j] = $root.ics23.InnerOp.toObject(message.lookupInners[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedBatchProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedBatchProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedBatchProof;\n    })();\n\n    ics23.CompressedBatchEntry = (function() {\n\n        /**\n         * Properties of a CompressedBatchEntry.\n         * @memberof ics23\n         * @interface ICompressedBatchEntry\n         * @property {ics23.ICompressedExistenceProof|null} [exist] CompressedBatchEntry exist\n         * @property {ics23.ICompressedNonExistenceProof|null} [nonexist] CompressedBatchEntry nonexist\n         */\n\n        /**\n         * Constructs a new CompressedBatchEntry.\n         * @memberof ics23\n         * @classdesc Represents a CompressedBatchEntry.\n         * @implements ICompressedBatchEntry\n         * @constructor\n         * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n         */\n        function CompressedBatchEntry(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedBatchEntry exist.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} exist\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        CompressedBatchEntry.prototype.exist = null;\n\n        /**\n         * CompressedBatchEntry nonexist.\n         * @member {ics23.ICompressedNonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        CompressedBatchEntry.prototype.nonexist = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * CompressedBatchEntry proof.\n         * @member {\"exist\"|\"nonexist\"|undefined} proof\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        Object.defineProperty(CompressedBatchEntry.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new CompressedBatchEntry instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry instance\n         */\n        CompressedBatchEntry.create = function create(properties) {\n            return new CompressedBatchEntry(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedBatchEntry message. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchEntry.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.CompressedExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedBatchEntry message, length delimited. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedBatchEntry message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchEntry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchEntry();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.CompressedNonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedBatchEntry message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchEntry.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedBatchEntry message.\n         * @function verify\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedBatchEntry.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedNonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedBatchEntry message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         */\n        CompressedBatchEntry.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedBatchEntry)\n                return object;\n            var message = new $root.ics23.CompressedBatchEntry();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.CompressedBatchEntry.exist: object expected\");\n                message.exist = $root.ics23.CompressedExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.CompressedBatchEntry.nonexist: object expected\");\n                message.nonexist = $root.ics23.CompressedNonExistenceProof.fromObject(object.nonexist);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedBatchEntry message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.CompressedBatchEntry} message CompressedBatchEntry\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedBatchEntry.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.CompressedExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.CompressedNonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedBatchEntry to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedBatchEntry.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedBatchEntry;\n    })();\n\n    ics23.CompressedExistenceProof = (function() {\n\n        /**\n         * Properties of a CompressedExistenceProof.\n         * @memberof ics23\n         * @interface ICompressedExistenceProof\n         * @property {Uint8Array|null} [key] CompressedExistenceProof key\n         * @property {Uint8Array|null} [value] CompressedExistenceProof value\n         * @property {ics23.ILeafOp|null} [leaf] CompressedExistenceProof leaf\n         * @property {Array.<number>|null} [path] CompressedExistenceProof path\n         */\n\n        /**\n         * Constructs a new CompressedExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedExistenceProof.\n         * @implements ICompressedExistenceProof\n         * @constructor\n         * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n         */\n        function CompressedExistenceProof(properties) {\n            this.path = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * CompressedExistenceProof value.\n         * @member {Uint8Array} value\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.value = $util.newBuffer([]);\n\n        /**\n         * CompressedExistenceProof leaf.\n         * @member {ics23.ILeafOp|null|undefined} leaf\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.leaf = null;\n\n        /**\n         * CompressedExistenceProof path.\n         * @member {Array.<number>} path\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.path = $util.emptyArray;\n\n        /**\n         * Creates a new CompressedExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof instance\n         */\n        CompressedExistenceProof.create = function create(properties) {\n            return new CompressedExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedExistenceProof message. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                $root.ics23.LeafOp.encode(message.leaf, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.path != null && message.path.length) {\n                writer.uint32(/* id 4, wireType 2 =*/34).fork();\n                for (var i = 0; i < message.path.length; ++i)\n                    writer.int32(message.path[i]);\n                writer.ldelim();\n            }\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                case 3:\n                    message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.path && message.path.length))\n                        message.path = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.path.push(reader.int32());\n                    } else\n                        message.path.push(reader.int32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedExistenceProof message.\n         * @function verify\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n                    return \"value: buffer expected\";\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n                var error = $root.ics23.LeafOp.verify(message.leaf);\n                if (error)\n                    return \"leaf.\" + error;\n            }\n            if (message.path != null && message.hasOwnProperty(\"path\")) {\n                if (!Array.isArray(message.path))\n                    return \"path: array expected\";\n                for (var i = 0; i < message.path.length; ++i)\n                    if (!$util.isInteger(message.path[i]))\n                        return \"path: integer[] expected\";\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         */\n        CompressedExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedExistenceProof)\n                return object;\n            var message = new $root.ics23.CompressedExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.value != null)\n                if (typeof object.value === \"string\")\n                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n                else if (object.value.length)\n                    message.value = object.value;\n            if (object.leaf != null) {\n                if (typeof object.leaf !== \"object\")\n                    throw TypeError(\".ics23.CompressedExistenceProof.leaf: object expected\");\n                message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n            }\n            if (object.path) {\n                if (!Array.isArray(object.path))\n                    throw TypeError(\".ics23.CompressedExistenceProof.path: array expected\");\n                message.path = [];\n                for (var i = 0; i < object.path.length; ++i)\n                    message.path[i] = object.path[i] | 0;\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.CompressedExistenceProof} message CompressedExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.path = [];\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                if (options.bytes === String)\n                    object.value = \"\";\n                else {\n                    object.value = [];\n                    if (options.bytes !== Array)\n                        object.value = $util.newBuffer(object.value);\n                }\n                object.leaf = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n            if (message.path && message.path.length) {\n                object.path = [];\n                for (var j = 0; j < message.path.length; ++j)\n                    object.path[j] = message.path[j];\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedExistenceProof;\n    })();\n\n    ics23.CompressedNonExistenceProof = (function() {\n\n        /**\n         * Properties of a CompressedNonExistenceProof.\n         * @memberof ics23\n         * @interface ICompressedNonExistenceProof\n         * @property {Uint8Array|null} [key] CompressedNonExistenceProof key\n         * @property {ics23.ICompressedExistenceProof|null} [left] CompressedNonExistenceProof left\n         * @property {ics23.ICompressedExistenceProof|null} [right] CompressedNonExistenceProof right\n         */\n\n        /**\n         * Constructs a new CompressedNonExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedNonExistenceProof.\n         * @implements ICompressedNonExistenceProof\n         * @constructor\n         * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n         */\n        function CompressedNonExistenceProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedNonExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * CompressedNonExistenceProof left.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} left\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.left = null;\n\n        /**\n         * CompressedNonExistenceProof right.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} right\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.right = null;\n\n        /**\n         * Creates a new CompressedNonExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof instance\n         */\n        CompressedNonExistenceProof.create = function create(properties) {\n            return new CompressedNonExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedNonExistenceProof message. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedNonExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                $root.ics23.CompressedExistenceProof.encode(message.left, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                $root.ics23.CompressedExistenceProof.encode(message.right, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedNonExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedNonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedNonExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedNonExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedNonExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.left = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.right = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedNonExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedNonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedNonExistenceProof message.\n         * @function verify\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedNonExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.left != null && message.hasOwnProperty(\"left\")) {\n                var error = $root.ics23.CompressedExistenceProof.verify(message.left);\n                if (error)\n                    return \"left.\" + error;\n            }\n            if (message.right != null && message.hasOwnProperty(\"right\")) {\n                var error = $root.ics23.CompressedExistenceProof.verify(message.right);\n                if (error)\n                    return \"right.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedNonExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         */\n        CompressedNonExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedNonExistenceProof)\n                return object;\n            var message = new $root.ics23.CompressedNonExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.left != null) {\n                if (typeof object.left !== \"object\")\n                    throw TypeError(\".ics23.CompressedNonExistenceProof.left: object expected\");\n                message.left = $root.ics23.CompressedExistenceProof.fromObject(object.left);\n            }\n            if (object.right != null) {\n                if (typeof object.right !== \"object\")\n                    throw TypeError(\".ics23.CompressedNonExistenceProof.right: object expected\");\n                message.right = $root.ics23.CompressedExistenceProof.fromObject(object.right);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedNonExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.CompressedNonExistenceProof} message CompressedNonExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedNonExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                object.left = null;\n                object.right = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                object.left = $root.ics23.CompressedExistenceProof.toObject(message.left, options);\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                object.right = $root.ics23.CompressedExistenceProof.toObject(message.right, options);\n            return object;\n        };\n\n        /**\n         * Converts this CompressedNonExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedNonExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedNonExistenceProof;\n    })();\n\n    return ics23;\n})();\n\nmodule.exports = $root;\n"],"names":["$protobuf","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","ics23","HashOp","valuesById","values","Object","create","LengthOp","ExistenceProof","properties","this","path","keys","i","length","prototype","key","newBuffer","value","leaf","emptyArray","encode","message","writer","hasOwnProperty","uint32","bytes","LeafOp","fork","ldelim","InnerOp","encodeDelimited","decode","reader","end","undefined","len","pos","tag","push","skipType","decodeDelimited","verify","isString","error","Array","isArray","fromObject","object","base64","TypeError","toObject","options","arrays","defaults","String","slice","call","j","toJSON","constructor","toJSONOptions","NonExistenceProof","left","right","CommitmentProof","$oneOfFields","exist","nonexist","batch","compressed","defineProperty","get","oneOfGetter","set","oneOfSetter","BatchProof","CompressedBatchProof","proof","oneofs","hash","prehashKey","prehashValue","prefix","int32","enums","suffix","ProofSpec","leafSpec","innerSpec","maxDepth","minDepth","InnerSpec","isInteger","childOrder","childSize","minPrefixLength","maxPrefixLength","emptyChild","end2","entries","BatchEntry","lookupInners","CompressedBatchEntry","CompressedExistenceProof","CompressedNonExistenceProof","module","exports"],"sourceRoot":""}