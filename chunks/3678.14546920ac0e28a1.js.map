{"version":3,"file":"static/chunks/3678.14546920ac0e28a1.js","mappings":"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","sources":["webpack://_N_E/./node_modules/viem/_esm/constants/strings.js","webpack://_N_E/./node_modules/viem/_esm/utils/signature/hashMessage.js","webpack://_N_E/./node_modules/viem/_esm/utils/signature/toPrefixedMessage.js","webpack://_N_E/./node_modules/viem/_esm/utils/signature/hashTypedData.js","webpack://_N_E/./node_modules/viem/_esm/errors/typedData.js","webpack://_N_E/./node_modules/viem/_esm/utils/typedData.js"],"sourcesContent":["export const presignMessagePrefix = '\\x19Ethereum Signed Message:\\n';\n//# sourceMappingURL=strings.js.map","import { keccak256 } from '../hash/keccak256.js';\nimport { toPrefixedMessage } from './toPrefixedMessage.js';\nexport function hashMessage(message, to_) {\n    return keccak256(toPrefixedMessage(message), to_);\n}\n//# sourceMappingURL=hashMessage.js.map","import { presignMessagePrefix } from '../../constants/strings.js';\nimport { concat } from '../data/concat.js';\nimport { size } from '../data/size.js';\nimport { bytesToHex, stringToHex, } from '../encoding/toHex.js';\nexport function toPrefixedMessage(message_) {\n    const message = (() => {\n        if (typeof message_ === 'string')\n            return stringToHex(message_);\n        if (typeof message_.raw === 'string')\n            return message_.raw;\n        return bytesToHex(message_.raw);\n    })();\n    const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`);\n    return concat([prefix, message]);\n}\n//# sourceMappingURL=toPrefixedMessage.js.map","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\nimport { encodeAbiParameters, } from '../abi/encodeAbiParameters.js';\nimport { concat } from '../data/concat.js';\nimport { toHex } from '../encoding/toHex.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { getTypesForEIP712Domain, validateTypedData, } from '../typedData.js';\nexport function hashTypedData(parameters) {\n    const { domain = {}, message, primaryType, } = parameters;\n    const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...parameters.types,\n    };\n    // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n    // as we can't statically check this with TypeScript.\n    validateTypedData({\n        domain,\n        message,\n        primaryType,\n        types,\n    });\n    const parts = ['0x1901'];\n    if (domain)\n        parts.push(hashDomain({\n            domain,\n            types: types,\n        }));\n    if (primaryType !== 'EIP712Domain')\n        parts.push(hashStruct({\n            data: message,\n            primaryType,\n            types: types,\n        }));\n    return keccak256(concat(parts));\n}\nexport function hashDomain({ domain, types, }) {\n    return hashStruct({\n        data: domain,\n        primaryType: 'EIP712Domain',\n        types,\n    });\n}\nexport function hashStruct({ data, primaryType, types, }) {\n    const encoded = encodeData({\n        data,\n        primaryType,\n        types,\n    });\n    return keccak256(encoded);\n}\nfunction encodeData({ data, primaryType, types, }) {\n    const encodedTypes = [{ type: 'bytes32' }];\n    const encodedValues = [hashType({ primaryType, types })];\n    for (const field of types[primaryType]) {\n        const [type, value] = encodeField({\n            types,\n            name: field.name,\n            type: field.type,\n            value: data[field.name],\n        });\n        encodedTypes.push(type);\n        encodedValues.push(value);\n    }\n    return encodeAbiParameters(encodedTypes, encodedValues);\n}\nfunction hashType({ primaryType, types, }) {\n    const encodedHashType = toHex(encodeType({ primaryType, types }));\n    return keccak256(encodedHashType);\n}\nexport function encodeType({ primaryType, types, }) {\n    let result = '';\n    const unsortedDeps = findTypeDependencies({ primaryType, types });\n    unsortedDeps.delete(primaryType);\n    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n    for (const type of deps) {\n        result += `${type}(${types[type]\n            .map(({ name, type: t }) => `${t} ${name}`)\n            .join(',')})`;\n    }\n    return result;\n}\nfunction findTypeDependencies({ primaryType: primaryType_, types, }, results = new Set()) {\n    const match = primaryType_.match(/^\\w*/u);\n    const primaryType = match?.[0];\n    if (results.has(primaryType) || types[primaryType] === undefined) {\n        return results;\n    }\n    results.add(primaryType);\n    for (const field of types[primaryType]) {\n        findTypeDependencies({ primaryType: field.type, types }, results);\n    }\n    return results;\n}\nfunction encodeField({ types, name, type, value, }) {\n    if (types[type] !== undefined) {\n        return [\n            { type: 'bytes32' },\n            keccak256(encodeData({ data: value, primaryType: type, types })),\n        ];\n    }\n    if (type === 'bytes') {\n        const prepend = value.length % 2 ? '0' : '';\n        value = `0x${prepend + value.slice(2)}`;\n        return [{ type: 'bytes32' }, keccak256(value)];\n    }\n    if (type === 'string')\n        return [{ type: 'bytes32' }, keccak256(toHex(value))];\n    if (type.lastIndexOf(']') === type.length - 1) {\n        const parsedType = type.slice(0, type.lastIndexOf('['));\n        const typeValuePairs = value.map((item) => encodeField({\n            name,\n            type: parsedType,\n            types,\n            value: item,\n        }));\n        return [\n            { type: 'bytes32' },\n            keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),\n        ];\n    }\n    return [{ type }, value];\n}\n//# sourceMappingURL=hashTypedData.js.map","import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nexport class InvalidDomainError extends BaseError {\n    constructor({ domain }) {\n        super(`Invalid domain \"${stringify(domain)}\".`, {\n            metaMessages: ['Must be a valid EIP-712 domain.'],\n        });\n    }\n}\nexport class InvalidPrimaryTypeError extends BaseError {\n    constructor({ primaryType, types, }) {\n        super(`Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`, {\n            docsPath: '/api/glossary/Errors#typeddatainvalidprimarytypeerror',\n            metaMessages: ['Check that the primary type is a key in `types`.'],\n        });\n    }\n}\nexport class InvalidStructTypeError extends BaseError {\n    constructor({ type }) {\n        super(`Struct type \"${type}\" is invalid.`, {\n            metaMessages: ['Struct type must not be a Solidity type.'],\n            name: 'InvalidStructTypeError',\n        });\n    }\n}\n//# sourceMappingURL=typedData.js.map","import { BytesSizeMismatchError } from '../errors/abi.js';\nimport { InvalidAddressError } from '../errors/address.js';\nimport { InvalidDomainError, InvalidPrimaryTypeError, InvalidStructTypeError, } from '../errors/typedData.js';\nimport { isAddress } from './address/isAddress.js';\nimport { size } from './data/size.js';\nimport { numberToHex } from './encoding/toHex.js';\nimport { bytesRegex, integerRegex } from './regex.js';\nimport { hashDomain, } from './signature/hashTypedData.js';\nimport { stringify } from './stringify.js';\nexport function serializeTypedData(parameters) {\n    const { domain: domain_, message: message_, primaryType, types, } = parameters;\n    const normalizeData = (struct, data_) => {\n        const data = { ...data_ };\n        for (const param of struct) {\n            const { name, type } = param;\n            if (type === 'address')\n                data[name] = data[name].toLowerCase();\n        }\n        return data;\n    };\n    const domain = (() => {\n        if (!types.EIP712Domain)\n            return {};\n        if (!domain_)\n            return {};\n        return normalizeData(types.EIP712Domain, domain_);\n    })();\n    const message = (() => {\n        if (primaryType === 'EIP712Domain')\n            return undefined;\n        return normalizeData(types[primaryType], message_);\n    })();\n    return stringify({ domain, message, primaryType, types });\n}\nexport function validateTypedData(parameters) {\n    const { domain, message, primaryType, types } = parameters;\n    const validateData = (struct, data) => {\n        for (const param of struct) {\n            const { name, type } = param;\n            const value = data[name];\n            const integerMatch = type.match(integerRegex);\n            if (integerMatch &&\n                (typeof value === 'number' || typeof value === 'bigint')) {\n                const [_type, base, size_] = integerMatch;\n                // If number cannot be cast to a sized hex value, it is out of range\n                // and will throw.\n                numberToHex(value, {\n                    signed: base === 'int',\n                    size: Number.parseInt(size_) / 8,\n                });\n            }\n            if (type === 'address' && typeof value === 'string' && !isAddress(value))\n                throw new InvalidAddressError({ address: value });\n            const bytesMatch = type.match(bytesRegex);\n            if (bytesMatch) {\n                const [_type, size_] = bytesMatch;\n                if (size_ && size(value) !== Number.parseInt(size_))\n                    throw new BytesSizeMismatchError({\n                        expectedSize: Number.parseInt(size_),\n                        givenSize: size(value),\n                    });\n            }\n            const struct = types[type];\n            if (struct) {\n                validateReference(type);\n                validateData(struct, value);\n            }\n        }\n    };\n    // Validate domain types.\n    if (types.EIP712Domain && domain) {\n        if (typeof domain !== 'object')\n            throw new InvalidDomainError({ domain });\n        validateData(types.EIP712Domain, domain);\n    }\n    // Validate message types.\n    if (primaryType !== 'EIP712Domain') {\n        if (types[primaryType])\n            validateData(types[primaryType], message);\n        else\n            throw new InvalidPrimaryTypeError({ primaryType, types });\n    }\n}\nexport function getTypesForEIP712Domain({ domain, }) {\n    return [\n        typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n        domain?.version && { name: 'version', type: 'string' },\n        (typeof domain?.chainId === 'number' ||\n            typeof domain?.chainId === 'bigint') && {\n            name: 'chainId',\n            type: 'uint256',\n        },\n        domain?.verifyingContract && {\n            name: 'verifyingContract',\n            type: 'address',\n        },\n        domain?.salt && { name: 'salt', type: 'bytes32' },\n    ].filter(Boolean);\n}\nexport function domainSeparator({ domain }) {\n    return hashDomain({\n        domain,\n        types: {\n            EIP712Domain: getTypesForEIP712Domain({ domain }),\n        },\n    });\n}\n/** @internal */\nfunction validateReference(type) {\n    // Struct type must not be a Solidity type.\n    if (type === 'address' ||\n        type === 'bool' ||\n        type === 'string' ||\n        type.startsWith('bytes') ||\n        type.startsWith('uint') ||\n        type.startsWith('int'))\n        throw new InvalidStructTypeError({ type });\n}\n//# sourceMappingURL=typedData.js.map"],"names":["presignMessagePrefix","hashMessage","message","to_","keccak256","message_","raw","prefix","size","concat","toPrefixedMessage","hashTypedData","parameters","domain","primaryType","types","EIP712Domain","parts","push","hashStruct","data","hashDomain","encoded","encodeData","encodedTypes","type","encodedValues","hashType","field","value","encodeField","name","encodedHashType","result","unsortedDeps","findTypeDependencies","delete","deps","Array","from","sort","map","t","join","encodeType","primaryType_","results","Set","match","has","undefined","add","length","slice","lastIndexOf","parsedType","typeValuePairs","item","v","InvalidDomainError","constructor","super","stringify","metaMessages","InvalidPrimaryTypeError","JSON","Object","keys","docsPath","InvalidStructTypeError","serializeTypedData","domain_","normalizeData","struct","data_","param","toLowerCase","validateTypedData","validateData","integerMatch","_type","base","size_","signed","Number","parseInt","isAddress","address","bytesMatch","expectedSize","givenSize","validateReference","getTypesForEIP712Domain","version","chainId","verifyingContract","salt","filter","Boolean","startsWith"],"sourceRoot":""}